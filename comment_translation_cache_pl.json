{"!b is true, which evaluates to 1": "!b ma wartość true, co daje wartość 1", "!true evaluates to 0": "!true daje wartość 0", "\"45\" is not the same as integer 45!": "\"45\" to nie to samo, co liczba całkowita 45!", "\"Alex\"s creates a temporary std::string": "\"Alex\" tworzy tymczasowe std::string", "\"Hello world!\" is a C-style string literal.": "\"Witaj, świecie!\" jest literałem łańcuchowym w stylu C.", "\"Hello world!\" is a literal that evaluates to text \"Hello world!\"": "\"Witaj, świecie!\" jest literałem, którego wynikiem jest tekst „Witaj, świecie!”", "\"Hello, world!\" is a C-style string literal": "„Witaj, świecie!” to literał łańcuchowy w stylu C", "\"east const\" style, okay but not preferred": "styl „east const”, OK, ale nie preferowany", "\"enum class\" defines this as a scoped enum rather than an unscoped enum": "„klasa wyliczeniowa” definiuje to jako wyliczenie o określonym zakresie, a nie wyliczenie bez zakresu", "\"enum class\" defines this as a scoped enumeration rather than an unscoped enumeration": "„enum class” definiuje to jako wyliczenie o określonym zakresie, a nie wyliczenie bez zakresu", "\"goo\"s is a std::string literal, so s1 will be deduced as a std::string": "„goo”s to literał std::string, więc s1 zostanie wydedukowane jako std::string", "\"hello\" cannot be converted to an int": "\"hello\" nie może zostać przekonwertowane na int", "\"moo\"sv is a std::string_view literal, so s2 will be deduced as a std::string_view": "\"moo\"sv jest literałem std::string_view, zatem s2 zostanie wydedukowane jako std::string_view", "\"rotl\" stands for \"rotate left\"": "\"rotl\" oznacza \"obróć w lewo\"", "\"true\" and \"false\" are not destroyed at the end of the function": "\"true\" i „false” nie są niszczone na końcu funkcji", "#include <string> // for C++14": "#include <string> // dla C++14", "#include other .h and .cpp template definitions you need here": "#include inne definicje szablonów .h i .cpp, których tutaj potrzebujesz", "& qualifier overloads function to match only lvalue implicit objects": "& kwalifikator przeciąża funkcję, aby dopasować tylko lwartość obiektów ukrytych", "& qualifier overloads function to match only lvalue implicit objects, returns by reference": "& przeciąża kwalifikator funkcji, aby dopasować tylko ukryte obiekty lwartości, zwraca przez referencja", "&& is logical and -- checks if both conditions are true": "&& jest logiczna i -- sprawdza, czy oba warunki są spełnione", "&& qualifier overloads function to match only rvalue implicit objects": "Kwalifikator && przeciąża funkcję, aby dopasować tylko ukryte obiekty o wartości", "&& qualifier overloads function to match only rvalue implicit objects, returns by value": "&& kwalifikator przeciąża funkcję, aby dopasować tylko ukryte obiekty o wartości r, zwraca według wartości", "&ammo means ammo is captured by reference": "&ammo oznacza, że amunicja jest przechwytywana przez referencję", "&value = 0012FF60": "&wartość = 0012FF60", "'a' converted to match foo(double)": "'a' skonwertowane na foo(double)", "'c' converted to type int, prints 99": "'c' skonwertowane na typ int, wypisuje 99", "(Note: it's exactly the same as the previous ascending() function)": "(Uwaga: to dokładnie to samo, co poprzednia funkcja ascending())", "(We have to use the global namespace selector to prevent a collision": "(Musimy użyć selektora globalnej przestrzeni nazw, aby zapobiec kolizja", "(e.g. if we wanted to move the won/lost messages out of the function, or conditionalize other behavior based on won/lost)": "(np. gdybyśmy chcieli usunąć wygrane/przegrane wiadomości z funkcji lub uzależnić inne zachowanie na podstawie wygranych/przegranych)", "(except the last one, which will already be sorted by the time we get there)": "(z wyjątkiem ostatniego, który będzie już posortowany, zanim tam dotrzemy)", "(just like you would do in real life)": "(tak jak zrobiłbyś to w prawdziwym życiu)", "(like std::string), we won't end up making expensive copies.": "(jak std::string), nie sprawimy, że będzie to drogie kopie.", "(optionally) handle this as an error case in production mode so we don't crash if it does happen": "(opcjonalnie) potraktuj to jako przypadek błędu w trybie produkcyjnym, abyśmy nie zawiesili się, jeśli tak się stanie", "(we don't need the definition any more since it's not used)": "(nie potrzebujemy już definicji, ponieważ nie jest używana)", "(we'll explain what a struct is and how to use them later in this chapter)": "(wyjaśnimy, czym jest struktura i jak z niej korzystać w dalszej części tego rozdziału)", "(we'll use static_cast<bool> to interpret the results as a boolean value)": "(użyjemy static_cast<bool> do interpretacji wyników jako wartość logiczna)", "*    short, int, long, long long": "* short, int, long, long long", "*    unsigned short, unsigned int, unsigned long, or unsigned long long": "* unsigned short, unsigned int, unsigned long lub unsigned long long", "* also handles cases where the two arguments have different types but can be converted to int": "* obsługuje również przypadki, gdy dwa argumenty mają różne typy, ale można je przekonwertować na int", "* min and max can have different types": "* min i max mogą mieć różne typy", "* min and max must have the same type": "* min i max muszą mieć wartość tego samego typu", "* min and max will be converted to the return type": "* min i max zostaną skonwertowane na typ zwracany", "* return type must be explicitly specified as a template argument": "* typ zwracany musi być jawnie określony jako argument szablonu", "* return value has same type as min and max": "* wartość zwracana ma ten sam typ co min i max", "++ to move to next element": "++ aby przejść do następnego elementu", "++ to move to next element.": "++ aby przejść do następnego elementu.", "-1 is implicitly converted to 4294967295, and 4294967295 < 1 is false": "-1 jest domyślnie konwertowane na 4294967295 i 4294967295 < 1 to false", "-1 is not a valid index, so we can use it as an error return value": "-1 nie jest prawidłowym indeksem, więc możemy go użyć jako wartości zwracanej błędu", "-1 is out of our range, so we get modulo wrap-around": "-1 jest poza naszym zakresem, więc otrzymujemy zawijanie modulo", "-2 is out of our range, so we get modulo wrap-around": "-2 jest poza naszym zakresem, więc otrzymujemy modulo zawijanie", "... but no explicit delete needed": "... ale nie jest potrzebne żadne jawne usuwanie", "... it would be destroyed here": "... zostałoby tutaj zniszczone", "...then compare the make": "...następnie porównaj make", "// Can also be implemented outside the class definition": "// Można również zaimplementować poza definicją klasy", "// Ensure the dynamic cast succeeds by checking for a null pointer result": "// Upewnij się, że rzutowanie dynamiczne zakończyło się pomyślnie, sprawdzając wynik zerowego wskaźnika", "// change ptr to point at y": "// zmień ptr na punkt y", "// function-style cast of x to double": "// Rzutowanie x w stylu funkcji na double", "//If C++20 capable, you can use an abbreviated function template instead": "//Jeśli obsługuje C++20, możesz zamiast tego użyć skróconego szablonu funkcji", "0 before the number means this is octal": "0 przed liczbą oznaczającą, że jest to liczba ósemkowa", "0 is an integer": "0 to liczba całkowita", "0.0 is a double": "0.0 to double", "0x before the number means this is hexadecimal": "0x przed liczbą oznacza, że jest to liczba szesnastkowa", "1 + 2 evaluates to an int, so i will be deduced as an int": "1 + 2 daje wartość int, więc i zostanie wydedukowane jako int", "1 -- construct value to be passed to function": "1 -- skonstruuj wartość, która ma zostać przekazana do funkcji", "1 and 2 are rvalues, operator+ returns an rvalue": "1 i 2 to rwartości, operator+ zwraca wartość", "1) Put all of the items of the desired rarity on a list": "1) Umieść wszystkie elementy o żądanej rzadkości na lista", "1.2 is an rvalue expression": "1.2 jest wyrażeniem wartości", "10 is the default argument": "10 jest argumentem domyślnym", "10 not an initializer list, copy init won't match explicit constructor: compilation error": "10 nie jest listą inicjującą, kopiowanie init nie pasuje do jawnego konstruktora: błąd kompilacji", "10 not an initializer list, matches explicit single-argument constructor": "10 nie jest listą inicjatorów, pasuje do jawnego jednoargumentowego konstruktora", "12 is assumed to be a decimal number": "12 przyjmuje się jako liczbę dziesiętną", "2 + 3 is an expression that has no semicolon -- the semicolon is at the end of the statement containing the expression": "2 + 3 jest wyrażenie, które nie zawiera średnika — średnik znajduje się na końcu instrukcji zawierającej wyrażenie", "2 + 3 uses operator+ to evaluate to value 5": "2 + 3 używa operatora+ do obliczenia wartości 5", "2 -- actually pass value": "2 --w rzeczywistości przekazuje wartość", "2 and 3 are the arguments passed to function add()": "2 i 3 są argumentami przekazywanymi do funkcji add()", "2 is a literal that evaluates to value 2": "2 to literał, którego wynikiem jest wartość 2", "2) Calculate a probability for each item based on level and weight factor": "2) Oblicz a prawdopodobieństwo dla każdego elementu na podstawie poziomu i współczynnika wagi", "3 -- construct value to be returned to caller": "3 -- skonstruowana wartość zwracana do wywołującego", "3 to the 4th power": "3 do potęgi czwartej", "3.14159 is a double literal in standard notation": "3,14159 to podwójny literał w notacji standardowej", "3.4 is a double literal": "3,4 to podwójny literał", "32768 overflows if int is 16-bits, okay if int is 32-bits": "32768 przepełnienia, jeśli int ma 16 bitów, OK, jeśli int ma 32 bity", "4 + 5 evaluates to value 9, which is then assigned to variable x": "4 + 5 daje wartość 9, która jest następnie przypisana do zmiennej x", "4 -- actually return value": "4 -- faktycznie zwracana wartość", "4 is the default argument": "4 jest argumentem domyślnym", "4) Figure out which item that random number corresponds to": "4) Dowiedz się, któremu elementowi odpowiada ta liczba losowa", "5 (no suffix) is type int (by default)": "5 (bez przyrostka) wpisz int (przez domyślnie)", "5 converted to temporary double, bound to parameter d": "5 przekonwertowane na tymczasowe double, powiązane z parametrem d", "5 converted to temporary double, copied to parameter d": "5 przekonwertowane na tymczasowe double, skopiowane do parametru d", "5 is an int, so this matches print(int)": "5 to int, więc odpowiada to print(int)", "5 is an integer literal": "5 to literał całkowity", "5 is an rvalue expression": "5 to wyrażenie wartości", "5 is our non-type template argument": "5 to nasz szablon nietypowy argument", "5 will be used as the initializer for x": "5 zostanie użyty jako inicjator dla x", "5) Return the appropriate item": "5) Zwróć odpowiednią pozycję", "5.0 (no suffix) is type double (by default)": "5.0 (bez przyrostka) jest typu double (domyślnie)", "5.0 is a double literal, so d will be deduced as a double": "5.0 jest literałem podwójnym, więc d zostanie wydedukowane jako double", "5.0 is a floating point literal (no suffix means double type by default)": "5.0 to literał zmiennoprzecinkowy (brak sufiksu oznacza podwójny typ przez domyślnie)", "5.0 is a floating point literal, f suffix means float type": "5.0 to literał zmiennoprzecinkowy, przyrostek f oznacza typ zmiennoprzecinkowy", "5.0f is type float": "5.0f to typ float", "5L is type long": "5L to typ long", "5u is type unsigned int": "5u to typ unsigned int", "5u means treat 5 as an unsigned integer": "5u oznacza traktowanie 5 jako liczbę całkowitą bez znaku", "6 will be used as the initializer for x": "6 zostanie użyte jako inicjator dla x", "6.02 x 10^23 is a double literal in scientific notation": "6,02 x 10^23 to podwójny literał w notacji naukowej", "6.7 is a double, so this matches print(double)": "6.7 to double, więc to pasuje print(double)", "65536 is out of our range, so we get modulo wrap-around": "65536 jest poza naszym zakresem, więc otrzymamy modulo zawijanie", "65537 is out of our range, so we get modulo wrap-around": "65537 jest poza naszym zakresem, więc otrzymujemy zawijanie modulo", "7 to the 12th power": "7 do potęgi 12", "70 to the 12th power (will return the max 64-bit int value)": "70 do potęgi 12 (zwróci maksymalną 64-bitową wartość int)", "8 bits in size means room for 8 flags": "8 bitów oznacza miejsce na 8 flag", "97 is ASCII code for 'a'": "97 wynosi Kod ASCII dla 'a'", "A Triad with three arguments of the same type should deduce to a Triad<T>": "Triada z trzema argumentami tego samego typu powinna wydedukować Triadę<T>", "A copy constructor that implements move semantics": "Konstruktor kopiujący, który implementuje semantykę przenoszenia", "A couple of additional functions just for convenience": "Kilka dodatkowych funkcji tylko dla wygody", "A declaration for our Pair class template": "Deklaracja naszego szablonu klasy Pair", "A few more tests to ensure copy constructing / assigning arrays": "Kilka dodatkowych testów zapewniających konstruowanie/przypisywanie kopii arrays", "A full specialization of primary template print<T> for type double": "Pełna specjalizacja podstawowego wydruku szablonu<T> dla typu double", "A helper macro (#expr prints whatever is passed in for expr as text)": "Makro pomocnicze (#expr drukuje wszystko, co jest przekazywane do wyrażenia jako tekst)", "A initialized in member initializer list of B": "Inicjowana na liście inicjatorów składowych B", "A modifiable view that allows us to work with an ArrayFlat2d using two dimensions": "Modyfikowalny widok, który pozwala nam pracować z ArrayFlat2d przy użyciu dwóch wymiarów", "A modular square root function": "Modułowy pierwiastek kwadratowy funkcja", "A regular function pointer. Only works with an empty capture clause (empty []).": "Zwykły wskaźnik funkcji. Działa tylko z pustą klauzulą ​​przechwytującą (pustą []).", "A return type of int means the function will return some integer value to the caller (the specific value is not specified here)": "Zwracany typ int oznacza, że ​​funkcja zwróci wywołującemu pewną wartość całkowitą (tutaj nie określono konkretnej wartości)", "A row has been printed, move to the next row": "Wydrukowano wiersz, przejdź do następnego wiersza", "A safer (but slower) version of powint() that checks for overflow": "Bezpieczniejsza (ale wolniejsza) wersja powint(), która sprawdza przepełnienie", "A sample class to prove the above works": "Przykładowa klasa potwierdzająca działanie powyższego", "A simplistic implementation of operator= (do not use)": "Prosta implementacja operatora= (nie używać)", "A simplistic implementation of operator= (see better implementation below)": "Uproszczona implementacja operatora= (patrz lepsza implementacja poniżej)", "Acceptable but not preferred version": "Wersja akceptowalna, ale nie preferowana", "Account for the fact that the last element is already sorted with each subsequent iteration": "Uwzględnij fakt, że ostatni element jest już posortowany przy każdej kolejnej iteracji", "Add 30 and 40 to the end and beginning": "Dodaj 30 i 40 na końcu i początku", "Add the vector components to the corresponding point coordinates": "Dodaj składowe wektora do odpowiednich współrzędnych punktu", "Add three values with any type": "Dodaj trzy wartości dowolnym typem", "Add two values with matching types": "Dodaj dwie wartości pasującymi typami", "Add two values with non-matching types": "Dodaj dwie wartości niepasującymi typami", "Add your code here": "Dodaj tutaj swój kod", "Alex is himself": "Alex jest sobą", "Alex is our newest employee": "Alex jest naszym najnowszym pracownik", "Algorithms that don't find what they were looking for return the end iterator.": "Algorytmy, które nie znajdują tego, czego szukali, zwracają iterator końcowy.", "Alias templates must be defined in global scope": "Szablony aliasów muszą być zdefiniowane w zasięgu globalnym", "All of the following statements are part of the global namespace": "Wszystkie poniższe instrukcje są częścią globalnej przestrzeni nazw", "All possible types of potions": "Wszystkie możliwe typy mikstur", "Allocate a Simple on the stack": "Przydziel Simple na stosie", "Allocate a buffer equal to this length": "Przydziel bufor równy tej długości", "Allocate a new array": "Przydziel nową tablicę", "Allocate an array to hold the names": "Przydziel tablicę do przechowywania nazw", "Allow the user to enter up to 10 numbers": "Pozwól użytkownikowi na wprowadzenie do 10 liczb", "Allow the user to input 'true' or 'false' for boolean values": "Pozwól użytkownikowi na wprowadzenie „prawdy” lub „fałszu” dla wartości logicznych", "Allow this function to access private members": "Pozwól tej funkcji na dostęp do prywatnych członków", "Allow us to convert Dollars into Cents": "Zezwól nam przeliczyć dolary na centy", "Also note that we use <Resource>, not <Resource*>": "Pamiętaj też, że używamy <Resource>, a nie <Resource*>", "Alternatively, don't initialize res2 and then assign res2 = res1;": "Alternatywnie nie inicjuj res2, a następnie przypisuj res2 = res1;", "An alias template for a three-dimensional std::array": "Szablon aliasu dla trójwymiarowego std::array", "An alias template for a two-dimensional std::array": "Szablon aliasu dla dwuwymiarowego std::array", "An alias template to allow us to define a one-dimensional std::array using two dimensions": "Szablon aliasu umożliwiający zdefiniowanie jednowymiarowego std::array przy użyciu dwóch wymiarów", "An array of our enumerators": "Tablica naszych modułów wyliczających", "An assignment operator that implements move semantics": "Operator przypisania implementujący semantykę przenoszenia", "An integer can only hold non-fractional values.": "Liczba całkowita może przechowywać tylko wartości nieułamkowe.", "An overloaded output operator": "Przeciążone wyjście operator", "And a main program to display the first 13 Fibonacci numbers": "I program główny wyświetlający pierwsze 13 liczb Fibonacciego", "And here are the results that we expect for those test values": "A oto wyniki, których oczekujemy dla tych wartości testowych", "And increase the count by 1": "I zwiększ liczbę o 1", "And remove the bad input": "I usuń błędne wejście", "And use the new array instead!  Note that this simply makes m_data point": "I zamiast tego użyj nowej tablicy! Zauważ, że to po prostu powoduje, że punkt m_data", "Any exceptions of type double thrown within the above try block get sent here": "Wszelkie wyjątki typu double zgłoszone w powyższym bloku try zostaną wysłane tutaj", "Any exceptions of type int thrown within the above try block get sent here": "Wszelkie wyjątki typu int zgłoszone w powyższym bloku try zostaną wysłane tutaj", "Any exceptions of type std::string thrown within the above try block get sent here": "Wszelkie wyjątki typu std::string zgłoszone w powyższym bloku try zostaną wysłane tutaj", "Any fractions that are overwritten will need to be re-reduced": "Wszelkie nadpisane ułamki będą musiały zostać ponownie zredukowany", "Any members defined here would default to private": "Każdy zdefiniowany tutaj element będzie domyślnie prywatny", "Applies a potion's effect to the player": "Stosuje efekt mikstury do gracza", "Apply the effect": "Zastosuj efekt", "Arguments 4 and 5 are passed to function add()": "Argumenty 4 i 5 są przekazywane do funkcji add()", "Arithmetic can be done at compile-time, and no non-constexpr functions are called.": "Arytmetykę można wykonywać w czasie kompilacji i nie są wykonywane żadne funkcje inne niż constexpr", "As of C++20 we could also use auto add(auto x, auto y)": "Od C++20 możemy również użyć automatycznego dodawania (auto x, auto y)", "As of C++20 we could also use auto add(auto x, auto y, auto z)": "Od C++20 możemy również użyć automatycznego dodawania (auto x, auto y, auto z)", "Ask our array for the begin and end points (via the begin and end member functions).": "Zapytaj naszą tablicę o punkty początkowe i końcowe (poprzez funkcje elementu początkowego i końcowego).", "Ask the user what to search for.": "Zapytaj użytkownika, czego szukać for.", "Ask user for input": "Pytaj użytkownika o wprowadzenie", "Asks the user to enter three values and then print those values as a sentence.": "Prosi użytkownika o wprowadzenie trzech wartości, a następnie wydrukuje je jako zdanie.", "Asks the user to input starting number, then generates array of numbers": "Prosi użytkownika o wprowadzenie numeru początkowego, następnie generuje tablicę liczb", "Asks user to enter all the names": "Prosi użytkownika o wprowadzenie wszystkich nazw", "Assign a C-style string": "Przypisz ciąg w stylu C", "Assign a string value": "Przypisz ciąg wartość", "Assign it a name (we can do this directly because m_name is public)": "Przypisz mu nazwę (możemy to zrobić bezpośrednio, ponieważ m_name jest publiczna)", "Assignment operator that does a deep copy": "Operator przypisania wykonujący głęboką kopię", "Assignment requires the left operand to be a modifiable lvalue expression and the right operand to be an rvalue expression": "Przypisanie wymaga, aby lewy operand był modyfikowalnym wyrażeniem l-wartości, a prawy operand był wyrażeniem r-wartości", "Assume Dollars(int) is explicit": "Załóż, że Dollars(int) jest jawne", "Assume element 0 is the minimum and the maximum": "Załóż element 0 to minimum i maksimum", "Assume ptr is some pointer that may or may not be a null pointer": "Załóż, że ptr jest wskaźnikiem, który może być wskaźnikiem zerowym lub nie", "At this point, the player is either dead or has won": "W tym momencie gracz albo jest martwy, albo wygrał", "Attempts to access it from another file via a function forward declaration will fail": "Próby uzyskania dostępu do niego z innego pliku poprzez deklarację przekazania funkcji nie powiodą się", "Bad: We have to read the lambda to understand what's happening.": "Źle: musimy przeczytać lambdę, aby zrozumieć, co się dzieje.", "Base::printValue was inherited as protected, so the public has no access": "Base::printValue zostało odziedziczone jako chronione, więc opinia publiczna nie ma dostępu", "Because Display is a friend of Storage, Display members can access the private members of Storage": "Ponieważ Display jest przyjacielem Storage, członkowie Display mogą uzyskać dostęp do prywatnych członków Storage", "Because Printer is a member of Employee,": "Ponieważ Drukarka jest członkiem Employee,", "Because identifiers can't start with a number, we'll use a \"rank_\" prefix for these": "Ponieważ identyfikatory nie mogą zaczynać się od liczby, użyjemy dla nich przedrostka „rank_”", "Because identify() is a normal member function, it can be virtualized": "Ponieważident() jest normalną funkcją składową, można ją zwirtualizować", "Because it's static, we don't need to allocate an object of type CarLot to use it": "Ponieważ jest statyczna, nie musimy przydzielać obiektu typu CarLot, aby z niego korzystać", "Because operator+= modifies its left operand, we'll write it as a member": "Ponieważ operator+= modyfikuje jego lewą stronę operand, napiszemy go jako element", "Because print() is a friend of Accumulator": "Ponieważ print() jest przyjacielem akumulatora", "Because print() is a normal member function, it can be virtualized": "Ponieważ print() jest normalną funkcją składową, można ją zwirtualizować", "Because variable x is constexpr, expr must be evaluatable at compile-time": "Ponieważ zmienna x to constexpr, wyrażenie musi być obliczalne w czasie kompilacji", "Because we did a seek, we can now safely do a write, so": "Ponieważ przeprowadziliśmy wyszukiwanie, możemy teraz bezpiecznie wykonać zapis, więc", "Because we're lazy and want to access Foo:: qualified names without typing the Foo:: prefix": "Ponieważ jesteśmy leniwi i chcemy uzyskać dostęp do kwalifikowanych nazw Foo:: bez wpisywania przedrostka Foo::", "Before C++17, we had to specify the element type when we create std::greater": "Przed C++17 musieliśmy określić typ elementu podczas tworzenia std::greater", "Before C++20": "Przed C++20", "Before C++20, use": "Przed C++20, użyj", "Before C++20, with the array size being explicitly specified": "Przed C++20, z jawnie określonym rozmiarem tablicy", "Before C++20, without ranges": "Przed C++20, bez zakresów", "Before drawing always print some empty lines": "Przed rysowaniem zawsze drukuj puste linie", "Being robust means handling unexpected parameters as well, even though getOperator() guarantees operation is valid in this particular program": "Bycie solidnym oznacza również obsługę nieoczekiwanych parametrów, nawet jeśli getOperator() gwarantuje, że operacja jest poprawna w tym konkretnym programie", "Best: non-member function print() is not part of the class interface": "Najlepiej: funkcja niebędąca członkiem print() nie jest częścią klasy interfejs", "Better: member function print() has no direct access to members": "Lepiej: funkcja składowa print() nie ma bezpośredniego dostępu do członków", "Better: use -> to select member from pointer to object": "Lepiej: użyj ->, aby wybrać element ze wskaźnika do obiektu", "Both ref and the temporary object die here": "Zarówno ref, jak i obiekt tymczasowy tutaj umierają", "But doSomething changed it to 2!": "Ale doSomething zmienił to na 2!", "But here if you want to retest things later": "Ale tutaj, jeśli chcesz ponownie przetestować wszystko później", "But our programs that use the class do not need to be updated!": "Ale nasze programy korzystające z tej klasy nie trzeba aktualizować!", "But the problem arises when we try to move that pair into another pair.": "Ale problem pojawia się, gdy próbujemy przenieść tę parę do innej pary.", "But we're changing it to public via a using declaration": "Ale zmieniamy ją na publiczną poprzez deklarację using", "Button using three mixins": "Przycisk używający trzech miksów", "By explicitly specifying std::string_view as a function template argument,": "Poprzez jawne określenie std::string_view jako argumentu szablonu funkcji,", "C++11, deduces to std::reference_wrapper<const int>": "C++11 wnioskuje, że std::reference_wrapper<const int>", "C++11, deduces to std::reference_wrapper<int>": "C++ 11, wyprowadza std::reference_wrapper<int>", "C++17, returns length as type `size_type` (alias for `std::size_t`)": "C++17, zwraca długość jako typ `size_type` (alias dla `std::size_t`)", "C++17, returns unsigned integral value 5": "C++17, zwraca wartość całkowitą bez znaku 5", "C++20, returns length as a large signed integral type": "C++20, zwraca długość jako dużą liczbę całkowitą ze znakiem", "C++20, returns signed integral value 5": "C++20, zwraca wartość całkowitą ze znakiem 5", "C++20, {:#b} formats the argument as 0b-prefixed binary digits": "C++20, {:#b} formatuje argument jako cyfry binarne z przedrostkiem 0b", "C++20, {:b} formats the argument as binary digits": "C++20, {:b} formatuje argument jako binarny cyfry", "C++23, format/print two arguments (same as above) and a newline": "C++23, sformatuj/wypisz dwa argumenty (tak samo jak powyżej) i znak nowej linii", "C-style cast of x to double": "Rzutowanie x w stylu C na double", "C-style string": "Ciąg w stylu C", "COMPARISON DONE HERE": "PORÓWNANIE ZROBIONE TUTAJ", "CTAD allowed for static members": "CTAD dozwolone dla elementów statycznych", "CTAD not allowed for non-static members": "CTAD nie jest dozwolone dla elementów niestatycznych członkowie", "CTAD used to deduce Pair<int, int> from the initializers (C++17)": "CTAD użyte do wydedukowania Pair<int, int> z inicjatorów (C++17)", "CTAD used to deduce Pair<int> from the initializers (C++17)": "CTAD użyte do wydedukowania Pair<int> z inicjatorów (C++17)", "CTAD used to deduce std::pair<int, int> from the initializers (C++17)": "CTAD użyte do wydedukowania std::pair<int, int> z inicjatorów (C++17)", "CTAD, single braces due to brace elision": "CTAD, pojedyncze nawiasy z powodu elizji nawiasów", "Calculate the cost of the items": "Oblicz koszt elementów", "Calculates the current ball height and then prints it": "Oblicza aktualną wysokość kulki, a następnie ją drukuje", "Call Base(int) constructor with value id!": "Wywołaj konstruktor Base(int) z identyfikatorem wartości!", "Call Employee(std::string_view, int) to initialize m_name and m_id": "Wywołaj Employee(std::string_view, int), aby zainicjować m_name i m_id", "Call the function that fcn is pointing to with x and y as parameters": "Zadzwoń funkcja, na którą wskazuje fcn z parametrami x i y.", "Call the lambda": "Wywołaj lambdę", "Call the lambda function that makeWalrus returned.": "Wywołaj funkcję lambda, która zwróciła makeWalrus.", "Call virtual function identify() to get the string to be printed": "Wywołaj funkcję wirtualną identyfikuj(), aby uzyskać ciąg znaków do wydrukowania", "Called when the user guesses a number correctly.": "Wywoływana, gdy użytkownik poprawnie odgadnie liczbę.", "Called when the user guesses a number that is not in the numbers.": "Wywoływane, gdy użytkownik odgadnie liczbę, której nie ma w liczbach.", "Calls Base::getName() instead of the virtualized Derived::getName()": "Wywołuje Base::getName() zamiast zwirtualizowanej Derived::getName()", "Calls Foo::print(double)": "Wywołuje Foo::print(double)", "Calls Foo::print(int)": "Wywołuje Foo::print(int)", "Calls Fraction(const Fraction&) copy constructor": "Wywołuje Fraction(const Konstruktor kopiujący ułamek&)", "Calls foo(const Foo&) copy constructor": "Wywołuje konstruktor kopiujący foo(const Foo&)", "Calls std::vector::vector(std::initializer_list<int>), 1 element: 5": "Wywołuje std::vector::vector(std::initializer_list<int>), 1 element: 5", "Calls std::vector::vector(std::vector::size_type), 5 value-initialized elements: 0 0 0 0 0": "Wywołuje std::vector::vector(std::vector::size_type), 5 elementów inicjowanych wartością: 0 0 0 0 0", "Can assign nullptr to make the pointer a null pointer": "Można przypisać nullptr, aby wskaźnik był wskaźnikiem zerowym", "Capture @comparisons by reference.": "Przechwytuj @porównania przez odniesienie.", "Capture armor by value and everything else by reference.": "Przechwytuj zbroję według wartości i wszystko inne przez odniesienie.", "Capture enemies by reference and everything else by value.": "Przechwytuj wrogów według odniesienia i wszystko inne według wartości.", "Capture health and armor by value, and enemies by reference.": "Przechwytuj zdrowie i zbroję według wartości, a wrogów według wartości reference.", "Capture name by reference and return the lambda.": "Przechwyć nazwę przez referencję i zwróć lambdę.", "Case 1: Create named variable and return": "Przypadek 1: Utwórz nazwaną zmienną i zwróć", "Case 1: okay: use returned reference to member of rvalue class object in same expression": "Przypadek 1: OK: użyj zwróconej referencji do członka obiektu klasy rvalue w tym samym wyrażeniu", "Case 1: static_cast returns a temporary std::string direct-initialized with sv": "Przypadek 1: static_cast zwraca tymczasowy std::string bezpośrednio zainicjowany przez sv", "Case 1: use a `std::function` parameter": "Przypadek 1: użyj parametru `std::function`", "Case 2: Construct temporary IntPair and pass to function": "Przypadek 2: Skonstruuj tymczasową IntPair i przejdź do funkcji", "Case 2: Create temporary IntPair and return": "Przypadek 2: Utwórz tymczasową IntPair i zwróć", "Case 2: bad: save returned reference to member of rvalue class object for use later": "Przypadek 2: źle: zapisz zwrócone odwołanie do członka obiektu klasy rvalue do późniejszego wykorzystania", "Case 2: explicitly creates a temporary std::string list-initialized with sv": "Przypadek 2: jawnie tworzy tymczasowy std::string lista-inicjowana za pomocą sv", "Case 2: use a function template with a type template parameter": "Przypadek 2: użyj szablonu funkcji z parametrem szablonu typu", "Case 3: C-style cast returns temporary std::string direct-initialized with sv (avoid this one!)": "Przypadek 3: Rzutowanie w stylu C zwraca tymczasowe std::string bezpośrednio zainicjowane za pomocą sv (unikaj tego!)", "Case 3: Implicitly convert { 7, 8 } to a temporary Intpair and pass to function": "Przypadek 3: Niejawnie konwertuj { 7, 8 } na tymczasową parę Intpair i przekaż do funkcja", "Case 3: implicitly convert { 7, 8 } to IntPair and return": "Przypadek 3: niejawnie przekonwertuj { 7, 8 } na IntPair i zwróć", "Case 3: okay: copy referenced value to local variable for use later": "Przypadek 3: OK: skopiuj wartość odniesienia do zmiennej lokalnej do późniejszego wykorzystania", "Case 3: use the abbreviated function template syntax (C++20)": "Przypadek 3: użyj skróconej składni szablonu funkcji (C++20)", "Case 4: use function pointer (only for lambda with no captures)": "Przypadek 4: użyj wskaźnika funkcji (tylko dla lambda bez przechwytywania)", "Cast to double, make the double negative, then convert back to FixedPoint2": "Rzutuj na podwójną, zrób podwójną ujemną, a następnie przekonwertuj z powrotem na StałyPoint2", "Cat and Dog from the example above": "Kot i pies z powyższego przykładu", "Change the Boolean value with index 4 to false": "Zmień wartość logiczną z indeksem 4 na fałszywą", "Changes to ammo will affect main's ammo": "Zmiany w amunicji wpłyną na amunicję główną", "Check for failed extraction": "Sprawdź, czy ekstrakcja nie powiodła się", "Check if base will overflow when multiplied by base": "Sprawdź, czy baza tak przepełnienie przy mnożeniu przez podstawę", "Check if result will overflow when multiplied by base": "Sprawdź, czy wynik będzie przepełniony przy pomnożeniu przez podstawę", "Check if the numbers are really close -- needed when comparing numbers near zero.": "Sprawdź, czy liczby są naprawdę blisko - potrzebne przy porównywaniu liczb bliskich zera.", "Check the current number against each possible divisor": "Sprawdź bieżącą liczbę względem każdego możliwego dzielnika", "Check whether the user entered meaningful input": "Sprawdź, czy użytkownik wprowadził sensowne dane wejściowe", "Class identifier": "Identyfikator klasy", "Cleanup the va_list when we're done.": "Wyczyść listę va_list, gdy skończyliśmy.", "Clear out any extraneous input": "Usuń wszelkie niepotrzebne dane wejściowe", "Code to time goes here": "Tutaj znajduje się kod do czasu", "Compare two boards to see if they are equal": "Porównaj dwie tablice, aby sprawdzić, czy są równe", "Compile error!  Which cout do we want here?  The one in the std namespace or the one we defined above?": "Błąd kompilacji! Którego cout tu chcemy? Ten w przestrzeni nazw std czy ten, który zdefiniowaliśmy powyżej?", "Compile error: can not set non-virtual functions to 0": "Błąd kompilacji: nie można ustawić funkcji niewirtualnych na 0", "Compile error: can't use operator. with pointers": "Błąd kompilacji: nie można użyć operatora. ze wskaźnikami", "Compile error: classSize not defined": "Błąd kompilacji: classSize nie zdefiniowany", "Compile error: compiler hasn't seen definitions of x and y yet": "Błąd kompilacji: kompilator nie widział jeszcze definicji x i y", "Compile error: main not allowed to be called explicitly": "Błąd kompilacji: nie można jawnie wywołać funkcji main", "Compile error: main not allowed to have non-int return type": "Błąd kompilacji: main nie może mieć typu powrotu innego niż int", "Complex code goes here": "Tutaj znajduje się złożony kod", "Const integral variables with a constant expression initializer can be used in constant expressions:": "Const zmienne całkowite z inicjatorem wyrażenia stałego mogą być używane w wyrażeniach stałych:", "Constructor with both color and radius parameters": "Konstruktor z parametrami koloru i promienia", "Constructor with only color parameter (radius will use default value)": "Konstruktor tylko z parametrem koloru (promień użyje wartości domyślnej)", "Constructor with only radius parameter (color will use default value)": "Konstruktor tylko z parametrem promienia (kolor użyje wartości domyślnej)", "Contents of add.h copied here": "Zawartość add.h skopiowana tutaj", "Convert a Point into its negative equivalent": "Przekształć punkt na jego ujemną odpowiednik", "Convert the char to a number and see if it's a valid potion selection": "Przekształć znak na liczbę i sprawdź, czy jest to prawidłowy wybór mikstury", "Convert value of s2 to an unsigned int": "Konwertuj wartość s2 na liczbę int bez znaku", "Convert value of u1 to a signed int": "Konwertuj wartość u1 na int ze znakiem", "Coord is an alias for Pair<T>": "Współrzędny jest aliasem pary<T>", "Copy all of the elements up to the index": "Kopiuj wszystkie elementy aż do indeksu", "Copy all of the values after the inserted element": "Kopiuj wszystkie wartości po wstawionym elemencie", "Copy all of the values after the removed element": "Kopiuj wszystkie wartości po usuniętym element", "Copy assignment": "Kopiuj przypisanie", "Copy assignment -- no copying allowed!": "Kopiuj przypisanie — kopiowanie jest zabronione!", "Copy constructor": "Kopiuj konstruktor", "Copy constructor -- no copying allowed!": "Kopiuj konstruktor — kopiowanie nie jest dozwolone!", "Copy constructor that does a deep copy": "Kopiuj konstruktor wykonujący głęboką kopię", "Copy constructor throws an exception when copying from": "Konstruktor kopiujący zgłasza wyjątek podczas kopiowania z", "Copy elements from original array to new array": "Kopiuj elementy z oryginalnej tablicy do nowej array", "Copy init": "Kopiuj init", "Copy list init": "Kopiuj listę init", "Copy some data into it": "Kopiuj do niej część danych", "Copy src into arr": "Kopiuj src do arr", "Copy the parameter string into our internal buffer": "Skopiuj ciąg parametrów do naszego wewnętrznego bufora", "Copy the resource": "Kopiuj zasób", "Count how many months consist of 5 letters": "Policz, ile miesięcy składa się z 5 litery", "Create a Patient outside the scope of the Doctor": "Utwórz Pacjenta poza zakresem Doktora", "Create a department and add some Teachers to it": "Utwórz oddział i dodaj do niego kilku Nauczycieli", "Create a department and use the constructor parameter to pass": "Utwórz oddział i użyj parametru konstruktora do przekazania", "Create a dynamically allocated array of Fractions of length 4": "Utwórz dynamicznie przydzielaną tablicę Ułamków o długości 4", "Create a new BaseballPlayer object": "Utwórz nowego BaseballPlayera obiekt", "Create a new lambda named count": "Utwórz nową lambdę o nazwie count", "Create a new walrus whose name is Roofus.": "Utwórz nowego morsa o nazwie Roofus.", "Create a null pointer": "Utwórz wskaźnik zerowy", "Create a reusable random number generator that generates uniform numbers between 1 and 6": "Utwórz generator liczb losowych wielokrotnego użytku, który generuje liczby jednolite od 1 do 6", "Create a signed view of our std::vector": "Utwórz podpisany widok naszego std::vector", "Create a single dynamically allocated Fraction with numerator 3 and denominator 5": "Utwórz pojedynczy, dynamicznie przydzielany ułamek z licznikiem 3 i mianownikiem 5", "Create a std::string_view of m_string, so we can use std::string_view::substr() instead of std::string::substr()": "Utwórz std::string_view m_string, abyśmy mogli użyć std::string_view::substr() zamiast std::string::substr()", "Create a teacher outside the scope of the Department": "Utwórz nauczyciela poza zakresem Dział", "Create a temporary variable with our current digit": "Utwórz zmienną tymczasową z naszą obecną cyfrą", "Create a vector with 5 elements": "Utwórz wektor z 5 elementami", "Create a vector with length 5": "Utwórz wektor o długości 5", "Create our own swap friend function to swap the members of Name": "Utwórz własną funkcję wymiany znajomych, aby zamienić człony Imię", "Create seed_seq with clock and 7 random numbers from std::random_device": "Utwórz seq_seq z zegarem i 7 losowymi liczbami z std::random_device", "Create seed_seq with high-res clock and 7 random numbers from std::random_device": "Utwórz seed_seq z zegarem o wysokiej rozdzielczości i 7 losowymi liczbami ze std::random_device", "Dan has the most points (8).": "Dan ma najwięcej punktów (8).", "Danger: this throws a Base object, not a Derived object": "Niebezpieczeństwo: powoduje to wyrzucenie obiektu podstawowego, a nie obiektu pochodnego", "Declare a new variable that's visible only to the lambda.": "Zadeklaruj nową zmienną, która będzie widoczna tylko dla lambda.", "Declare an Advertising struct variable": "Zadeklaruj zmienną struktury reklamowej", "Declare an array with 10 elements": "Zadeklaruj tablicę z 10 elementami", "Declare an char array of size 14": "Zadeklaruj tablicę znaków o rozmiarze 14", "Decrease aceCount by 1 and": "Zmniejsz aceCount o 1 i", "Deduce type and size": "Wydedukuj typ i rozmiar", "Default constructor (color and radius will use default value)": "Domyślny konstruktor (kolor i promień będą używać domyślnych wartość)", "Default the sort to ascending sort": "Domyślnie sortuj rosnąco", "Defaults to private inheritance": "Domyślnie dziedziczenie prywatne", "Define a Storage8 for bool": "Zdefiniuj Storage8 dla bool", "Define a Storage8 for bool  (instantiates Storage8<bool> specialization)": "Zdefiniuj Storage8 dla bool (instancja specjalizacji Storage8<bool>)", "Define a Storage8 for integers": "Zdefiniuj Storage8 dla bool integers", "Define a Storage8 for integers (instantiates Storage8<T>, where T = int)": "Zdefiniuj Storage8 dla liczb całkowitych (instancja Storage8<T>, gdzie T = int)", "Define a bunch of physical/emotional states": "Zdefiniuj kilka stanów fizycznych/emocjonalnych", "Define a few variables of enumerated type Color": "Zdefiniuj kilka zmiennych typu wyliczeniowego Color", "Define a lambda and store it in a variable called \"shoot\".": "Zdefiniuj lambdę i zapisz ją w zmiennej o nazwie \"shoot\".", "Define a new type named Fraction": "Zdefiniuj nowy typ o nazwie Fraction", "Define a new unscoped enumeration named Color": "Zdefiniuj nowe wyliczenie bez zakresu o nazwie Color", "Define a one-dimensional std::array of int (with 3 rows and 4 columns)": "Zdefiniuj jednowymiarową std::array of int (z 3 wierszami i 4 kolumnami)", "Define a program-defined type named Fraction so the compiler understands what a Fraction is": "Zdefiniuj zdefiniowany przez program typ o nazwie Fraction, aby kompilator zrozumiał, co to jest Fraction is", "Define a two-dimensional array of int with 3 rows and 4 columns": "Zdefiniuj dwuwymiarową tablicę int z 3 wierszami i 4 kolumnami", "Define a two-dimensional span into our one-dimensional array": "Zdefiniuj dwuwymiarowy zakres w naszej jednowymiarowej tablicy", "Define a two-dimensional view into our one-dimensional array": "Zdefiniuj dwuwymiarowy widok w naszej jednowymiarowej tablicy", "Define our different monster types as an enum": "Zdefiniuj różne typy potworów jako wyliczenie", "Define the function right where we use it.": "Zdefiniuj funkcję tam, gdzie jej używamy it.", "Define your list of words here": "Zdefiniuj tutaj swoją listę słów", "Define your own namespace to hold constants": "Zdefiniuj własną przestrzeń nazw do przechowywania stałych", "Defines a C-style array named testScore that contains 30 value-initialized int elements (no include required)": "Definiuje tablicę w stylu C o nazwie testScore, która zawiera 30 elementów int inicjowanych wartością (nie jest wymagane uwzględnianie)", "Defines variable bar of type Foo (inconsistent with `Foo { bar }` and `Foo(1)`)": "Definiuje zmienną bar typu Foo (niezgodną z `Foo { bar }` i `Foo(1)`)", "Definition of Array<T>::operator[] moved into Array.cpp below": "Definicja Array<T>::operator[] przeniesiona do Array.cpp poniżej", "Definition of function main()": "Definicja funkcji main()", "Definition of user-defined function doPrint()": "Definicja funkcji zdefiniowanej przez użytkownika doPrint()", "Definition of user-defined function main()": "Definicja funkcji zdefiniowanej przez użytkownika main()", "Delegate printing responsibility for printing to virtual member function print()": "Oddeleguj odpowiedzialność za drukowanie do wirtualnej funkcji składowej print()", "Delete the copy constructor so no copies can be made": "Usuń konstruktor kopiujący, aby nie można było wykonać kopii", "Dereference pointer to int to get int value": "Wyzeruj wskaźnik do int, aby uzyskać wartość int", "Dereference the null pointer": "Usuń wskaźnik zerowy", "Dereferencing a dangling pointer will cause undefined behavior": "Wyłuskanie wskaźnika zerowego zwisający wskaźnik spowoduje niezdefiniowane zachowanie", "Derived now has an Employee member": "Derived ma teraz członka Employee", "Distance is some defined type": "Odległość jest pewnego określonego typu", "Do deep copy of a.m_ptr to m_ptr": "Wykonaj głęboką kopię a.m_ptr do m_ptr", "Do error handling here": "Wykonaj tutaj obsługę błędów", "Do not forget the semicolon at the end, since these are statements.": "Nie zapomnij o średniku na końcu, ponieważ są to instrukcje.", "Do something with first": "Zrób coś z najpierw", "Do this": "Zrób to", "Does not match": "Nie pasuje", "Doesn't work, can't partially specialize functions": "Nie działa, nie można częściowo wyspecjalizować funkcji", "Don't compile anything starting here": "Nie kompiluj niczego zaczynając od tego", "Don't complain if gravity is unused": "Nie narzekaj, jeśli grawitacja nie jest używana", "Don't complain if phi is unused": "Nie narzekaj, jeśli phi jest niewykorzystane", "Don't complain if pi is unused": "Nie narzekaj, jeśli pi jest unused", "Don't forget a virtual destructor if you're going to use virtual function resolution": "Nie zapomnij o wirtualnym destruktorze, jeśli masz zamiar używać wirtualnego rozpoznawania funkcji", "Don't worry about the details of the implementation of these functions": "Nie martw się o szczegóły implementacji tych funkcji", "Don't worry about what & is for now, we're just using it to trick the compiler into thinking variable x is used": "Nie martw się o to, czym jest & na razie, używamy go tylko do oszukania kompilatora, aby pomyślał, że zmienna x jest używana", "Draw the final state of the game": "Narysuj końcowy stan gra", "Dynamically delete the array we allocated earlier": "Dynamicznie usuń tablicę, którą przydzieliliśmy wcześniej", "ERROR: return type doesn't match previous return type": "BŁĄD: typ powrotu nie pasuje do poprzedniego typu zwrotu", "Each enumerator is separated by a comma, not a semicolon": "Każdy moduł wyliczający jest oddzielony przecinkiem, a nie średnikiem", "Each student has an id and a name": "Każdy uczeń ma identyfikator i nazwę", "Each symbol is mapped to a function that determines whether the input is valid for that symbol": "Każdy symbol jest mapowany na funkcję, która określa, czy dane wejściowe są dla niego prawidłowe symbol", "Employee is a struct within the Company struct": "Pracownik to struktura w strukturze Company", "Employee publicly inherits from Person": "Pracownik publicznie dziedziczy po Person", "Employees must have a name and an id": "Pracownicy muszą mieć nazwę i identyfikator", "Ensure the full Array template definition can be seen": "Upewnij się, że może być dostępna pełna definicja szablonu tablicy widziałem", "Ensure the number of legs is the same as the number of animals": "Upewnij się, że liczba nóg jest taka sama jak liczba zwierząt", "Ensure the number of test scores is the same as the number of students": "Upewnij się, że liczba wyników testu jest taka sama jak liczba uczniów", "Error: search not accessible in this scope": "Błąd: wyszukiwanie niedostępne w tym zakresie", "Even though gravity is defined inside this function": "Mimo że w tej funkcji zdefiniowana jest grawitacja", "Everything from here to the end of the line is ignored": "Wszystko od tego miejsca do końca linii jest ignorowane", "Example move constructor definition for std::pair": "Przykładowa definicja konstruktora przenoszenia dla std::pair", "Exception thrown here": "Zgłoszony tutaj wyjątek", "Exceptions from member initializer list or": "Wyjątki z listy inicjatorów składowych lub", "Execution begins here": "Tutaj rozpoczyna się wykonywanie", "Execution continues here after the exception has been handled by any of the above catch blocks": "Wykonywanie jest kontynuowane tutaj po obsłużeniu wyjątku przez którykolwiek z powyższych bloków catch", "Explicit class template specialization for Storage<double>": "Jawna specjalizacja szablonu klasy dla Pamięć <double>", "Explicit function specializations are not implicitly inline, so make this inline if put in header file": "Jawne specjalizacje funkcji nie są domyślnie wbudowane, więc wstaw je, jeśli zostaną umieszczone w pliku nagłówkowym", "Explicit initializers: s2.x, s2.y, and s2.z use explicit values (no default values are used)": "Jawne inicjatory: s2.x, s2.y i s2.z używają jawnych wartości (nie są używane żadne wartości domyślne)", "Explicitly convert int value 5 to a Foo": "Jawnie przekonwertuj wartość int 5 na a Foo", "Explicitly request default copy constructor": "Wyraźnie zażądaj domyślnego konstruktora kopiującego", "Failure to flee gives the monster a free attack on the player": "Brak ucieczki daje potworowi darmowy atak na gracza", "FcnType easier to find": "FcnType łatwiejszy do znalezienia", "FcnType hard to find": "FcnType trudny do znalezienia", "Feeling::blue doesn't collide with Color::blue": "Feeling::blue nie koliduje z Color::blue", "Fetch the number of cols from the Col non-type template parameter": "Pobierz liczbę cols z parametru szablonu typu innego niż Col", "Fetch the number of rows from the Row non-type template parameter": "Pobierz liczbę wierszy z parametru szablonu typu innego niż Row", "Figure out which bit we're getting": "Sprawdź, który bit otrzymujemy", "Figure out which bit we're setting/unsetting": "Dowiedz się, który bit ustawiamy/rozbrajamy", "Fill it up in order, then print it": "Wypełnij w kolejności, a następnie wydrukuj", "Fill it up in order, then print it backwards": "Wypełnij w kolejności, a następnie wydrukuj wstecz", "Fill li with numbers starting at 0.": "Wypełnij li liczbami zaczynającymi się od 0.", "Fill string up with random lower case characters": "Wypełnij ciąg losowymi małymi literami", "Fill the array with numbers 1 through 10": "Wypełnij tablicę liczbami od 1 do 10", "Finally, delete the old array, and use the new array instead": "Na koniec usuń starą tablicę i zamiast tego użyj nowej tablicy", "Find the length of the string": "Znajdź długość sznurka", "Find the null terminator": "Znajdź terminator zerowy", "Find the value 3 in the list": "Znajdź wartość 3 na liście", "Finds the value in @numbers that is closest to @guess.": "Znajduje wartość w @numbers najbliższą @guess.", "First create a new array one element larger than the old array": "Najpierw utwórz nową tablicę o jeden element większą niż stara tablica", "First create a new array one element smaller than the old array": "Najpierw utwórz nową tablicę o jeden element mniejszą niż stara tablica", "First define our non-specialized class template": "Najpierw zdefiniuj nasz niewyspecjalizowany szablon klasy", "First we delete any existing elements": "Najpierw usuwamy istniejące elementy", "First we have to allocate a new array": "Najpierw musimy przydzielić nową tablicę", "First we need to define our Advertising struct": "Najpierw musimy zdefiniować naszą strukturę reklamową", "First, let's compare a (almost 1.0) to 1.0.": "Najpierw porównajmy a (prawie 1,0) z 1,0.", "First, let's prove that arr decays into an int* pointer": "Najpierw udowodnijmy, że arr rozpada się na wskaźnik int*", "First, let's use subscripting to get the address and values of our array elements": "Najpierw użyjmy indeksu dolnego, aby uzyskać adres i wartości elementów naszej tablicy", "First, read in valid input from user": "Najpierw wczytaj prawidłowe dane wejściowe od użytkownika", "Fix it": "Napraw to", "Foo is an aggregate": "Foo jest agregatem", "Foo is defined in the global scope": "Foo jest zdefiniowane w zakresie globalnym", "Foo is not an aggregate (has private members)": "Foo nie jest agregatem (ma prywatnych członków)", "Foo will handle allocation/deallocation": "Foo zajmie się alokacją/delokacją", "For any number 3 or greater, test odd values (this is why we add 2)": "Dla dowolnej liczby 3 lub większej przetestuj wartości nieparzyste (dlatego dodajemy 2)", "For const objects: can only be used for access": "W przypadku obiektów const: można używać tylko w celu uzyskania dostępu", "For each iteration of the outer loop, the code in the body of the loop executes once": "Dla każdej iteracji zewnętrznej pętli kod znajdujący się w treści pętli jest wykonywany raz", "For illustrative purposes only, don't use this": "Nie używaj tego wyłącznie w celach ilustracyjnych", "For non-const objects: can be used for assignment": "W przypadku obiektów innych niż stałe: można użyć do przypisania", "For random potion generation": "Do losowego generowania mikstur", "For simplicity, we'll ignore that 'y' is sometimes counted as a vowel": "Dla uproszczenia zignorujemy fakt, że „y” jest czasami liczone jako samogłoska", "For std::string and std::getline": "Dla std::string i std::getline", "Fraction is returned using copy constructor": "Ułamek jest zwracany przy użyciu konstruktora kopiującego", "Frank is an rvalue, so this calls std::string getName() && (makes a copy)": "Frank jest wartością, więc wywołuje std::string getName() && (tworzy kopię)", "Franz is driving the car with ID 17": "Franz prowadzi samochód z identyfikatorem 17", "Friend functions defined inside a class are non-member functions": "Funkcje zaprzyjaźnione zdefiniowane wewnątrz klasy nie są funkcjami członkowskimi", "FruitType has been moved inside the class, under the public access specifier": "FruitType został przeniesiony wewnątrz klasy, pod specyfikatorem dostępu publicznego", "Full implementation of the getUserInput function": "Pełna implementacja funkcji getUserInput", "Full specializations are not implicitly inline, so make this inline if put in header file": "Pełne specjalizacje nie są domyślnie wbudowane, więc wstaw je, jeśli zostaną umieszczone w pliku nagłówkowym", "Function asks user to enter a value": "Funkcja prosi użytkownika o wprowadzenie wartości", "Function template to calculate the average of the values in a std::vector": "Szablon funkcji do obliczania średniej wartości w std::vector", "Function template to calculate the average value in a std::vector": "Szablon funkcji do obliczania średniej wartości w std::vector", "Function that does not return a value": "Funkcja, która nie zwraca wartości", "Function that returns a value": "Funkcja zwracająca wartość", "Function-like macro that evaluates to true if the type (or object) is equal to or smaller than": "Makro podobne do funkcji, które ma wartość true, jeśli typ (lub obiekt) jest równy lub mniejszy niż", "Function-style cast of literal 1, returns temporary Foo (similar to `Foo { 1 }`)": "Rzutowanie w stylu funkcji literału 1, zwraca tymczasowe Foo (podobnie do `Foo { 1 }`)", "Game session data here": "Dane sesji gry tutaj", "Generate a random int between [min, max] (inclusive)": "Wygeneruj losową wartość int pomiędzy [min, max] (włącznie)", "Generate a random value between [min, max] (inclusive)": "Wygeneruj losową wartość pomiędzy [min, max] (włącznie)", "Generate the next number": "Wygeneruj następny numer", "Generates @count numbers starting at @start*@start and multiplies": "Generuje liczby @count zaczynając od @start*@start i mnoży", "Get element via 2d subscript (using operator(), since operator[] doesn't support multiple dimensions prior to C++23)": "Pobierz element za pomocą indeksu dolnego 2d (używając operatora(), ponieważ operator[] nie obsługuje wielu wymiarów przed C++ 23)", "Get element via single subscript (using operator[])": "Pobierz element za pomocą pojedynczego indeksu dolnego (używając operatora [])", "Get first number from user": "Uzyskaj pierwszy numer od użytkownika", "Get mathematical operation from user": "Uzyskaj operację matematyczną od użytkownika", "Get rest of the line and print it": "Znajdź resztę linii i wydrukuj ją", "Get second number from user": "Uzyskaj drugi numer od użytkownika", "Get that car from the car lot": "Zabierz ten samochód z parkingu", "Get the maximum value seen in m and value": "Uzyskaj maksymalną wartość widoczną w m i wartość", "Get the maximum value seen in m1 and m2": "Uzyskaj maksymalną wartość widzianą w m1 i m2", "Get the minimum value seen in m and value": "Uzyskaj minimalną wartość widoczną w m i wartość", "Get the minimum value seen in m1 and m2": "Uzyskaj minimalną wartość widoczną w m1 i m2", "Get the rest of the line and print it, moving to line 2": "Pobierz resztę linii i wydrukuj ją, przechodząc do linii 2", "Gets tower height from user and returns it": "Pobiera wysokość wieży od użytkownika i zwraca ją", "Global constants have internal linkage by default": "Stałe globalne mają domyślnie wewnętrzne powiązania", "Goo is a namespace inside the Foo namespace": "Goo to przestrzeń nazw wewnątrz przestrzeni nazw Foo", "Goo is a namespace inside the Foo namespace (C++17 style)": "Goo to przestrzeń nazw wewnątrz przestrzeni nazw Foo (styl C++ 17)", "Good: Instead, we can store the lambda in a named variable and pass it to the function.": "Dobrze: Zamiast tego możemy zapisać lambdę w nazwanej zmiennej i przekazać ją do funkcji.", "Handle an exception of type int here": "Obsłuż tutaj wyjątek typu int", "Handle case where the argument's decimal rounds to -100 (need to decrease base by 1)": "Zajmij się przypadkiem, w którym liczba dziesiętna argumentu zaokrągli się do -100 (należy zmniejszyć podstawę o 1)", "Handle case where the argument's decimal rounds to 100 (need to increase base by 1)": "Zajmij się przypadkiem, gdy liczba dziesiętna argumentu zaokrągli się do 100 (należy zwiększyć podstawę o 1)", "Handle case where we haven't seen any numbers yet": "Zajmij się przypadkiem, w którym nie widzieliśmy jeszcze żadnych liczb", "Handle exception of type double here": "Obsługa wyjątku typu double tutaj", "Handle max_type to silence the compiler warning. Don't use default:": "Obsługa max_type, aby wyciszyć ostrzeżenie kompilatora. Nie używaj domyślnych:", "Handles Ball(color, radius), Ball(color), and Ball()": "Obsługuje Ball(kolor, promień), Ball(kolor) i Ball()", "Header file that defines the Point3d class": "Plik nagłówkowy definiujący klasę Point3d", "Header file that defines the Vector3d class": "Plik nagłówkowy definiujący klasę Vector3d", "Helper function to convert `value` into an object of type std::size_t": "Funkcja pomocnicza konwertująca „wartość” na obiekt typu std::size_t", "Here are the enumerators": "Oto moduły wyliczające", "Here are the test values": "Oto wartości testowe", "Here is a comparison function that sorts in ascending order": "Oto funkcja porównawcza sortująca w porządku rosnącym", "Here is a comparison function that sorts in descending order": "Oto funkcja porównawcza sortująca w porządku malejącym", "Here is the friend declaration that makes non-member function void print(const Accumulator& accumulator) a friend of Accumulator": "Oto deklaracja znajomego, która sprawia, że funkcja niebędąca członkiem jest nieważna print(const Akumulator i akumulator) jest przyjacielem akumulatora", "Here's a deduction guide for our Pair (needed in C++17 only)": "Oto przewodnik po dedukcjach dla nasza para (wymagana tylko w C++17)", "Here's a deduction guide for our Pair (required in C++17 or older)": "Oto przewodnik dedukcji dla naszej pary (wymagany w C++17 lub starszym)", "Here's a function template with a static local variable that is modified": "Oto szablon funkcji ze statyczną zmienną lokalną, która jest modyfikowana", "Here's a macro substitution": "Oto podstawienie makra", "Here's a user-defined conversion from X to int": "Oto zdefiniowana przez użytkownika konwersja z X na int", "Here's our alias template": "Oto nasz szablon aliasu", "Here's our global std::mt19937 object.": "Oto nasz globalny obiekt std::mt19937.", "Here's our list assignment statement": "Oto nasza instrukcja przypisania listy", "Here's our overloaded operator<<": "Oto nasz przeciążony operator<", "Here's our override identify() function to handle the Derived case": "Oto nasza funkcja overrideident() do obsługi przypadku pochodnego", "Here's our override print() function to handle the Derived case": "Oto nasza funkcja zastępująca print() do obsługi przypadku Derived", "Here's our primary template (must come first)": "Oto nasz podstawowy szablon (musi być pierwszy)", "Here's some math/physics values that we copy-pasted from elsewhere": "Oto kilka wartości matematycznych/fizycznych, które skopiowaliśmy z innego miejsca", "Here's the declaration for a static function": "Oto deklaracja funkcji statycznej", "Here's the definition of the static function outside of the class.  Note we don't use the static keyword here.": "Oto definicja funkcji statycznej spoza klasy. Zauważ, że nie używamy tutaj słowa kluczowego static.", "Here, we're creating an object of type X (named x)": "Tutaj tworzymy obiekt typu X (o nazwie x)", "Hint: operator<< is a binary operator.": "Wskazówka: operator<< jest operatorem binarnym.", "How do we do this?": "Jak to zrobić?", "How do we ensure that arr has at least three elements?": "Jak zapewnić, że arr ma co najmniej trzy elementy?", "How do we get the value from getValueFromUser() and use it to initialize this variable?": "Jak uzyskać wartość z getValueFromUser() i użyć jej do zainicjowania tej zmiennej?", "However, because Derived is derived from Base, it's okay to return Derived* instead of Base*": "Jednakże, ponieważ Derived wywodzi się z Base, można zwrócić Derived* zamiast Base*", "However, we can point str at something else.  This does not change the value of the argument.": "Możemy jednak wskazać str na coś innego. Nie zmienia to wartości argumentu.", "However, we haven't actually handled this error": "Jednak tak naprawdę nie uporaliśmy się z tym błędem", "I am happy and laughing": "Jestem szczęśliwy i śmieję się", "I can has bomb! (note: type is short)": "Mogę mieć bombę! (uwaga: typ jest krótki)", "I'm happy right now (even though my program doesn't compile)": "Jestem teraz szczęśliwy (mimo że mój program się nie kompiluje)", "If C++20 capable, could use `using enum Animal` here to reduce Animal prefix redundancy": "Jeśli obsługuje C++20, mógłby użyć tutaj `używając enum Animal`, aby zmniejszyć redundancję przedrostka Animal", "If NDEBUG is defined, asserts are compiled out.": "Jeśli zdefiniowano NDEBUG, asercje są kompilowane.", "If a function can be made constexpr, it should be.": "Jeśli funkcję można przekształcić w constexpr, powinno be.", "If an exception isn't explicitly thrown here,": "Jeśli wyjątek nie jest tutaj wyraźnie zgłoszony,", "If b ends in 7, you probably forgot to do a deep copy in your copy assignment": "Jeśli b kończy się na 7, prawdopodobnie zapomniałeś wykonać głęboką kopię w swoim zadaniu kopiowania", "If decimal is out of bounds (in either direction),": "Jeśli liczba dziesiętna jest poza zakresem (w dowolnym kierunku),", "If either (or both) of the non-fractional and fractional part of the number are negative, the number should be treated as negative": "Jeśli którakolwiek (lub obie) części nieułamkowej i ułamkowej liczby są ujemne, liczbę należy traktować jako ujemny", "If it matches our expected value, then great!": "Jeśli odpowiada naszej oczekiwanej wartości, to świetnie!", "If its arguments are constexpr, it can be called at compile-time.": "Jeśli jego argumentami są constexpr, można go wywołać w czasie kompilacji.", "If no match was found, return -1": "Jeśli nie znaleziono dopasowania, zwróć -1", "If our array is going to be empty now, return here": "Jeśli nasza tablica będzie teraz pusta, wróć tutaj", "If our number is already at 0, wrap around to 9": "Jeśli nasza liczba jest już równa 0, zawiń do 9", "If our number is already at 9, wrap around to 0": "Jeśli nasz numer jest już na 9, zawiń do 0", "If ptr isn't already allocated, allocate it": "Jeśli ptr nie jest już przydzielony, przydziel go", "If the array is empty": "Jeśli tablica jest pusta", "If the ball would be under the ground, place it on the ground": "Jeśli piłka byłaby pod ziemią, umieść ją na ziemi", "If the car is not the same make...": "Jeśli samochód nie jest tej samej marki...", "If the character matches ch, return its index": "Jeśli znak pasuje do ch, zwróć jego indeks", "If the current element is larger than our previously found largest": "Jeśli bieżący element jest większy niż nasz poprzednio znaleziony największy", "If the current element is larger than the element after it": "Jeśli bieżący element jest większy niż element po nim", "If the current element is larger than the element after it, swap them": "Jeśli bieżący element jest większy niż element po nim, zamień je", "If the current element is smaller than our previously found smallest": "Jeśli bieżący element jest mniejszy niż poprzednio znaleziony najmniejszy", "If the current element is smaller/larger than our previously found smallest": "Jeśli bieżący element jest mniejszy/większy niż poprzednio znaleziony najmniejszy", "If the file couldn't be opened (e.g. because it was missing) return some error enum": "Jeśli plik nie mógł zostać otwarty (np. z powodu jego braku) zwróć jakiś błąd enum", "If the implicit object is a non-const rvalue, use std::move to try to move m_name": "Jeśli ukryty obiekt nie jest stałą wartością, użyj std::move, aby spróbować przenieść m_name", "If the letter was already guessed, try again": "Jeśli litera została już odgadnięta, spróbuj ponownie", "If the monster is dead, it can't attack the player": "Jeśli potwór jest martwy, nie może zaatakować gracza", "If the monster is now dead, level the player up": "Jeśli potwór jest teraz martwy, awansuj gracza na wyższy poziom", "If the new list is a different size, reallocate it": "Jeśli nowa lista ma inny rozmiar, przenieś to", "If the number is not divisible by 4, keep going": "Jeśli liczba nie jest podzielna przez 4, kontynuuj grę", "If the player is dead, we can't attack the monster": "Jeśli gracz jest martwy, nie możemy zaatakować potwora", "If the player isn't dead and hasn't won yet, the game continues": "Jeśli gracz nie umarł i jeszcze nie wygrał, gra jest kontynuowana", "If the player would bust, see if we can switch aces from 11 points to 1": "Jeśli gracz odpadnie, sprawdź, czy uda nam się zamienić asy z 11 punktów na 1", "If the previous extraction failed": "Jeśli poprzednia ekstrakcja nie powiodło się", "If the product is divisible by 9, jump to the \"end\" label": "Jeśli produkt jest podzielny przez 9, przejdź do etykiety „koniec”", "If the reported version is between two finalized standard codes,": "Jeśli zgłoszona wersja znajduje się pomiędzy dwoma sfinalizowanymi kodami standardowymi,", "If the reported version is one of the finalized standard codes": "Jeśli zgłoszona wersja jest jednym z sfinalizowanych kodów standardowych", "If the stream was closed": "Jeśli strumień został zamknięty", "If the two arguments have the same type, the returned value will have that same type.": "Jeśli oba argumenty mają ten sam typ, zwrócona wartość będzie miała ten sam typ.", "If the user entered a negative number, this is an error condition": "Jeśli użytkownik wprowadził liczbę ujemną, jest to warunek błędu", "If the user entered an EOF": "Jeśli użytkownik wprowadził EOF", "If the user entered an invalid char, try again": "Jeśli użytkownik wprowadził nieprawidłowy znak, spróbuj ponownie", "If the values are not sorted, we need to swap them so they are": "Jeśli wartości nie są posortowane, musimy je zamienić miejscami, aby były", "If there is extraneous input, treat as failure case": "Jeśli istnieją dodatkowe dane wejściowe, traktuj je jako przypadek niepowodzenia", "If there were no divisors": "Jeśli tak było brak dzielników", "If this array already exists, delete it so we don't leak memory": "Jeśli ta tablica już istnieje, usuń ją, aby nie wyciekać pamięci", "If this is the last remaining element in the array, set the array to empty and bail out": "Jeśli jest to ostatni pozostały element w tablicy, ustaw tablicę na pustą i wyjdź", "If this parameter is our sentinel value, stop looping": "Jeśli ten parametr jest naszą wartością wskaźnikową, przestań zapętlać", "If user did something bad, try again": "Jeśli użytkownik zrobił coś złego, spróbuj ponownie", "If users input didn't match": "Jeśli dane wprowadzone przez użytkowników nie dopasowanie", "If using C++17, we need to provide a deduction guide (not required in C++20)": "Jeśli używamy C++17, musimy podać przewodnik dedukcji (nie jest wymagany w C++20)", "If we actually extracted a value": "Jeśli rzeczywiście wyodrębniliśmy wartość", "If we are able to successfully move a tile, count this": "Jeśli udało nam się pomyślnie przenieść kafelek, policz to", "If we are resizing to an empty array, do that and return": "Jeśli zmieniamy rozmiar na pustą tablicę, zrób to i wróć", "If we couldn't open iofile, print an error": "Jeśli nie mogliśmy otworzyć pliku io, wydrukuj błąd", "If we couldn't open the input file stream for reading": "Jeśli nie mogliśmy otworzyć strumienia pliku wejściowego do odczytu", "If we couldn't open the output file stream for reading": "Jeśli nie mogliśmy otworzyć strumienia pliku wyjściowego do odczytu", "If we couldn't open the output file stream for writing": "Jeśli nie mogliśmy otworzyć strumienia pliku wyjściowego do zapisu", "If we didn't extract anything or the extracted guess is out of bounds, try again": "Jeśli niczego nie wyodrębniliśmy lub wyodrębniona wartość domysłu jest poza zakresem, spróbuj ponownie", "If we failed, clean up and try again": "Jeśli się nie udało, oczyść i spróbuj ponownie", "If we failed, try again": "Jeśli się nie udało, spróbuj ponownie", "If we find a vowel": "Jeśli znajdziemy samogłoskę", "If we found a matching name, we can get the enumerator value based on its index": "Jeśli znaleźliśmy pasującą nazwę, możemy uzyskać wartość modułu wyliczającego na podstawie jej indeksu", "If we got an error of some kind...": "Jeśli wystąpił jakiś błąd...", "If we got here, this must be a valid guess": "Jeśli tu dotarliśmy, musi to być prawidłowe przypuszczenie", "If we have our own distribution, we can access Random::mt directly": "Jeśli mamy własną dystrybucję, możemy uzyskać dostęp Random::mt bezpośrednio", "If we haven't swapped any elements this iteration, we're done early": "Jeśli w tej iteracji nie zamieniliśmy żadnych elementów, kończymy wcześniej", "If we reach the line below, \"ch\" will ALWAYS be a correct command!": "Jeśli dotrzemy do poniższej linii, „ch” ZAWSZE będzie poprawnym poleceniem!", "If we reached here, all tests must have passed": "Jeśli dotarliśmy tutaj, wszystkie testy musiały przejść pomyślnie", "If we wrote our own swap instead, we could do so like this:": "Gdybyśmy zamiast tego napisali własną zamianę, moglibyśmy to zrobić w ten sposób:", "If we're done, break out of loop": "Jeśli jesteśmy gotowe, wyjdź z pętli", "If we're done, get out here": "Jeśli skończyliśmy, wyjdź tutaj", "If we're setting a bit": "Jeśli trochę ustawiamy", "If we're using an older version of Visual Studio, bail out": "Jeśli używamy starszej wersji Visual Studio, wyjdź", "If we've already seen this count, then use the cache'd result": "Jeśli już widzieliśmy tę liczbę, użyj wyniku pamięci podręcznej", "If we've found an element that is smaller than our previously found smallest": "Jeśli znaleźliśmy element mniejszy niż poprzednio znaleziony najmniejszy", "If we've printed 10 numbers, start a new row": "Jeśli wydrukowaliśmy 10 liczb, rozpocznij nowy wiersz", "If we've printed 5 numbers, start a new row": "Jeśli wydrukowaliśmy 5 liczb, rozpocznij nowy wiersz", "If you get an error compiling this example, see the warning below": "Jeśli podczas kompilacji tego przykładu wystąpił błąd, zobacz ostrzeżenie poniżej", "If you're getting crazy values here you probably forgot to do a deep copy in your copy constructor": "Jeśli otrzymujesz tutaj szalone wartości, prawdopodobnie zapomniałeś wykonać głęboką kopię w konstruktorze kopiującym", "If you're getting crazy values here you probably forgot to do self-assignment check": "Jeśli otrzymujesz tutaj szalone wartości, prawdopodobnie zapomniałeś sprawdzić samodzielne przypisanie", "If your compiler isn't C++20-capable": "Jeśli twój kompilator nie obsługuje C++ 20", "Ignore any additional input on this line": "Zignoruj wszelkie dodatkowe dane wejściowe w tej linii", "Ignore any additional input on this line (regardless)": "Zignoruj wszelkie dodatkowe dane wejściowe w tej linii (niezależnie)", "Illegal, ammo cannot be modified.": "Nielegalne, amunicji nie można modyfikować.", "Illegal, the default capture has to be the first element in the capture group.": "Nielegalne, domyślnym przechwytywaniem musi być pierwszy element w grupie przechwytywania.", "Illegal, we already said we want to capture everything by reference.": "Nielegalne, już powiedzieliśmy, że chcemy przechwytywać wszystko przez odniesienie.", "Illegal, we already said we want to capture everything by value.": "Nielegalne, już powiedzieliśmy, że chcemy przechwytywać wszystko według wartości.", "Illegal: this function is nested inside function main()": "Nielegalne: ta funkcja jest zagnieżdżona w funkcji main()", "Implement printArray() here": "Zaimplementuj tutaj printArray()", "Implicitly convert int value 5 into a Foo": "Niejawnie przekonwertuj wartość int 5 na Foo", "In C++17, the type of variable arr is deduced to std::array<int, 7>": "W C++17 typ zmiennej arr jest dedukowany na std::array<int, 7>", "In C++20, could use std::ssize(arr) to avoid the cast": "W C++20 można użyć std::ssize(arr), aby uniknąć cast", "In C++20, we can use alias template deduction to deduce the template arguments in cases where CTAD works": "W C++20 możemy użyć dedukcji szablonu aliasów, aby wydedukować argumenty szablonu w przypadkach, gdy CTAD działa", "In C++23, use std::abs": "W C++23 użyj std::abs", "In C++23, you can #include <utility> and return std::to_underlying(a) instead": "W C++23 możesz #include <utility> i zamiast tego zwróć std::to_underlying(a)", "In Visual Studio 2015 or newer we can use _MSVC_LANG instead": "W Visual Studio 2015 lub nowszego, możemy zamiast tego użyć _MSVC_LANG", "In cases where we have two arguments with different types": "W przypadkach, gdy mamy dwa argumenty różnych typów", "In this case, it's called at runtime because the argument for towerHeight isn't constexpr.": "W tym przypadku jest on wywoływany w czasie wykonywania, ponieważ argument towerHeight nie jest constexpr.", "In this case, the access specifiers of base.": "W tym przypadku specyfikatory dostępu base.", "In this example, we're making our members public for simplicity": "W tym przykładzie upubliczniamy nasze elementy członkowskie dla prostota", "Increase amount of new lines if your board isn't": "Zwiększ liczbę nowych linii, jeśli twoja tablica nie jest", "Increment our total by the new number": "Zwiększ naszą sumę o nową liczbę", "Increments and prints its local copy of @i.": "Zwiększa i drukuje lokalną kopię @i.", "Indirection to get value of current element": "Pośredniość do pobrania wartości bieżącego elementu", "Indirection to get value of current element.": "Pośrednia do pobrania wartości bieżącego elementu.", "Inherit from Base privately": "Dziedzicz z bazy prywatnie", "Inherit from Base protectedly": "Dziedzicz z bazy w sposób chroniony", "Inherit from Base publicly": "Dziedzicz z bazy publicznie", "Initialize all elements to 0": "Zainicjuj wszystkie elementy na 0", "Initialize all elements to 0.0": "Zainicjuj wszystkie elementy na 0.0", "Initialize all elements to an empty string": "Zainicjuj wszystkie elementy pustym ciągiem znaków", "Initialize fcnPtr with function foo": "Zainicjuj fcnPtr funkcją foo", "Initialize our members using the corresponding member of the parameter": "Zainicjuj nasze elementy za pomocą odpowiedniego elementu parametru", "Initializing an int with fractional value 4.5 requires the compiler to convert 4.5 to a value an int can hold.": "Inicjowanie int o wartości ułamkowej 4.5 wymaga od kompilatora konwersji 4.5 na wartość, którą może przechowywać int.", "Insert 8 right before 3.": "Wstaw 8 tuż przed 3.", "Insert contents of add.h at this point.  Note use of double quotes here.": "Wstaw zawartość add.h w tym miejscu. Zwróć uwagę na użycie tutaj podwójnych cudzysłowów.", "Insert our new element into the new array": "Wstaw nasz nowy element do nowej tablicy", "Insert the number 20 before element with index 5": "Wstaw liczbę 20 przed elementem o indeksie 5", "Inside members of Fruit, we no longer need to prefix enumerators with FruitType::": "Wewnątrz elementów Fruit nie musimy już poprzedzać modułów wyliczających FruitType::", "Instantiates a variable named fraction of type Fraction": "Tworzy instancję zmiennej o nazwie ułamek typu Fraction", "Instead of this:": "Zamiast to:", "Instead, we have to pass in an Employee object to use": "Zamiast tego musimy przekazać obiekt Employee do użycia", "Instead, we'll create a std::mt19937, seed it, and then return the std::mt19937 (which can be copied).": "Zamiast tego utworzymy std::mt19937, zaszczepimy go, a następnie zwrócimy std::mt19937 (który można skopiować).", "IntArray& operator=(const IntArray& list) = delete; // to avoid shallow copies": "IntArray& operator=(const IntArray& list) = usuń; // aby uniknąć płytkich kopii", "IntArray(const IntArray&) = delete; // to avoid shallow copies": "IntArray(const IntArray&) = usuń; // aby uniknąć płytkich kopii", "Internal function definitions:": "Wewnętrzne definicje funkcji:", "Interrupt main() by making a function call to doPrint().  main() is the caller.": "Przerwij funkcję main() wykonując wywołanie funkcji doPrint(). main() jest obiektem wywołującym.", "Invalid: c can't have type incomplete type void": "Nieprawidłowy: c nie może mieć typu niekompletnego typu void", "Inventory items should have integral quantities, so we don't need a function template here": "Elementy zapasów powinny mieć ilości całkowite, więc nie potrzebujemy tutaj szablonu funkcji", "It can be #included into as many code files as needed (The inline keyword avoids ODR violations)": "Można #włączyć do dowolnej liczby plików z kodem (słowo kluczowe inline pozwala uniknąć naruszeń ODR)", "It depends on what order your compiler evaluates the function arguments in": "Zależy to od kolejności, w jakiej kompilator ocenia argumenty funkcji in", "It does not rely on the caller for anything": "Nie jest w niczym zależny od wywołującego", "It doesn't make sense to overload operator[] to print something": "Nie ma sensu przeciążać operatora[], aby coś wydrukować", "It wasn't a valid potion selection": "To nie był prawidłowy wybór mikstury", "Iterate through any remaining elements looking for a larger value": "Przejdź przez pozostałe elementy w poszukiwaniu większej wartości", "Iterate through every number between 1 and 50": "Przejdź przez każdą liczbę od 1 do 50", "Iterate through the list of names to see if we can find a matching name": "Przejrzyj listę nazw, aby zobaczyć, czy możemy znaleźć pasującą nazwę.", "Iterators, we don't know them. Skip.": "Iteratory, nie znamy ich. Pomiń.", "Joe had a birthday and got a raise": "Joe miał urodziny i dostał podwyżkę", "Joe is an lvalue, so this calls std::string& getName() & (returns a reference)": "Joe jest wartością l, więc wywołuje to std::string& getName() & (zwraca referencję)", "Keep asking the user if they want to play again until they pick y or n.": "Pytaj użytkownika, czy chce zagrać ponownie, dopóki nie wybierze y lub n.", "Keep track of whether any elements were swapped this iteration": "Śledź, czy jakiekolwiek elementy zostały zamienione iteracja", "Let's also output bool values as `true` or `false`": "Wypiszmy także wartości bool jako `true` lub `false`", "Let's create a reusable random number generator that generates uniform numbers between 1 and 6": "Utwórzmy generator liczb losowych wielokrotnego użytku, który generuje liczby jednolite od 1 do 6", "Let's handle the failure": "Zajmijmy się niepowodzeniem", "Literals can be used in constant expressions": "Literałów można używać w wyrażeniach stałych", "Look for exceptions that occur within try block and route to attached catch block(s)": "Poszukaj wyjątków występujących w bloku try i trasie do dołączone bloki catch", "Look for smallest element remaining in the array (starting at startIndex+1)": "Poszukaj najmniejszego elementu pozostałego w tablicy (zaczynając od startIndex+1)", "Look for smallest/largest element remaining in the array (starting at startIndex+1)": "Poszukaj najmniejszego/największego elementu pozostałego w tablicy (zaczynając od startIndex+1)", "Look ma, no exception handler!": "Spójrz, mamo, nie ma obsługi wyjątków!", "Look through all the students": "Przejrzyj wszystkich uczniów", "Look through the remaining elements to see if we can find a smaller or larger element": "Przejrzyj pozostałe elementy, aby zobaczyć, czy możemy znajdź mniejszy lub większy element", "Loop between 5 and 1": "Pętla między 5 a 1", "Loop indefinitely": "Pętla w nieskończoność", "Loop through all of the guesses": "Przejrzyj wszystkie domysły", "Loop through all of the test values": "Przejdź przez wszystkie wartości testowe", "Loop through all the ellipsis values": "Przejdź przez wszystkie wartości wielokropka", "Loop through all the shapes in the vector": "Przejdź przez wszystkie kształty w wektor", "Loop through each argument and print its number and value": "Przejdź przez każdy argument i wydrukuj jego liczbę i wartość", "Loop through each number between 1 and count (inclusive)": "Przejdź przez każdą liczbę od 1 do liczby (włącznie)", "Loop until user enters a valid input": "Pętla aż użytkownik wprowadzi prawidłowe dane wejściowe", "Make \"Lucy\" point to \"Ricky\" and vice-versa": "Ustaw „Lucy” na „Ricky” i odwrotnie", "Make sure T isn't a pointer or a std::nullptr_t": "Upewnij się, że T nie jest wskaźnikiem ani a std::nullptr_t", "Make sure base is negative": "Upewnij się, że podstawa jest ujemna", "Make sure decimal is negative": "Upewnij się, że liczba dziesiętna jest ujemna", "Make sure file is closed": "Upewnij się, że plik jest zamknięty", "Make sure that assert triggers even if we compile in release mode": "Upewnij się, że asercja wyzwala nawet jeśli kompilujemy w trybie wydania", "Make sure that two months were found.": "Upewnij się, że znaleziono dwa miesiące.", "Make sure the element was found": "Upewnij się, że element został znaleziony", "Make sure we don't try to divide by 0": "Upewnij się, że nie próbujemy dzielić przez 0", "Make sure we have the same number of test values and expected results": "Upewnij się, że mamy tę samą liczbę wartości testowych i oczekiwanych wyników", "Make sure we terminate the string in the buffer": "Upewnij się, że zakończyliśmy ciąg w buforze", "Make sure we've defined strings for all our colors": "Upewnij się, że zdefiniowaliśmy ciągi dla wszystkich naszych kolorów", "Make the Display class a friend of Storage": "Uczyń klasę Display przyjacielem Storage", "Make the Display::displayStorage member function a friend of the Storage class": "Uczyń Display::displayStorage Funkcja składowa zaprzyjaźniona z klasą Storage", "Make the function parameter a null pointer": "Ustaw parametr funkcji jako wskaźnik zerowy", "Maximum score before losing.": "Maksymalny wynik przed utratą.", "Member function of partially specialized class": "Funkcja składowa częściowo wyspecjalizowanej klasy", "Member function version": "Wersja funkcji składowej", "Member functions of the Point3d class defined here": "Funkcje składowe klasy Point3d zdefiniowane tutaj", "Member functions of the Vector3d class defined here": "Funkcje składowe Vector3d klasa zdefiniowana tutaj", "Members default initialized (int elements are left uninitialized)": "Domyślnie inicjowane elementy składowe (elementy int pozostają niezainicjowane)", "Members default initialized int elements are left uninitialized)": "Domyślnie inicjowane elementy składowe pozostają niezainicjowane)", "Members value initialized (int elements are zero initialized) (for comparison)": "Wartość elementów inicjowanych (elementy int są inicjowane zerem) (dla porównania)", "Members value initialized (int elements are zero initialized) (preferred)": "Wartość elementów inicjowanych jest inicjowana (elementy int są inicjowane zerem) (preferowane)", "Members value initialized (int elements are zero uninitialized) (preferred)": "Zainicjalizowana wartość elementów (elementy int są niezainicjowane zerem) (preferowane)", "Minium score that the dealer has to have.": "Minimalny wynik, jaki musi posiadać krupier.", "Missing initializers: s3.x is value initialized, s3.y and s3.z use defaults": "Brakujące inicjatory: s3.x to inicjowana wartość, s3.y i s3.z używają wartości domyślnych", "Mixin<T> can use template type parameter T to access members of Derived": "Mixin<T> może użyć parametru typu szablonu T, aby uzyskać dostęp do elementów członkowskich of Derived", "Most operators that have constant expression operands can be used in constant expressions": "Większość operatorów, które mają stałe operandy wyrażeń, może być używana w wyrażeniach stałych", "Move empty tile randomly 1000 times": "Przesuń losowo pustą płytkę 1000 razy", "N deduced as char `c`": "N wydedukowana jako znak `c`", "N deduced as int `5`": "N wydedukowana jako int `5`", "N is a non-type template parameter": "N jest szablonem innym niż typ parametr", "NOTE: YOU SHOULD CHECK FOR A FAILED EXTRACTION HERE (see section below)": "UWAGA: NALEŻY SPRAWDZIĆ TUTAJ, CZY EKSTRAKCJA NIE BUDOWAŁA SIĘ (patrz sekcja poniżej)", "Need to explicitly provide prototype for operator+ so uses of operator+ in other files know this overload exists": "Należy jawnie podać prototyp operatora+, aby użycie operator+ w innych plikach wiedziało, że istnieje przeciążenie", "Needed to prevent compiler from doing tail-call optimization": "Konieczne, aby uniemożliwić kompilatorowi optymalizację wywołań końcowych", "Nested initialization list to initialize Employee": "Zagnieżdżona lista inicjująca do inicjalizacji Pracownik", "No CTAD, must use double braces": "Brak CTAD, należy używać podwójnych nawiasów klamrowych", "No initialization values, calls Foo's default constructor": "Brak wartości inicjujących, wywołuje domyślny konstruktor Foo", "No initializer list: s1.x is uninitialized, s1.y and s1.z use defaults": "Brak listy inicjatorów: s1.x jest niezainicjowany, s1.y i s1.z używają wartości domyślnych", "No parameter means this is prefix operator++": "Brak parametru oznacza, że jest to operator przedrostka++", "No parameter means this is prefix operator--": "Brak parametru oznacza, że jest to operator przedrostka--", "Normally override functions have to return objects of the same type as the base function": "Normalnie funkcje przesłaniające muszą zwracać obiekty tego samego typu jako funkcja bazowa", "Not allowed!": "Niedozwolone!", "Not called from anywhere right now": "W tej chwili nie wywoływane znikąd", "Not great but works: First dereference ptr, then use member selection": "Nie świetne, ale działa: Najpierw wyłuskaj ptr, a następnie użyj wyboru elementu", "Note how redundant this is": "Zauważ, jak bardzo jest to zbędne", "Note our user-defined comparison is the third parameter": "Pamiętaj, że naszym porównaniem zdefiniowanym przez użytkownika jest trzeci parametr", "Note that str points to a const char, so we can not change the values it points to.": "Zauważ, że str wskazuje na stały znak, więc nie możemy zmienić wartości na to wskazuje.", "Note that this is a full definition, not a forward declaration": "Zauważ, że jest to pełna definicja, a nie deklaracja forward", "Note the allocation of memory here": "Zauważ tutaj alokację pamięci", "Note we have to specify both in and out because we're using fstream": "Uwaga: musimy określić zarówno wejście, jak i wyjście, ponieważ używamy fstream", "Note we've included code here to test the return value!": "Zauważ, że zamieściliśmy tutaj kod, aby przetestować wartość zwracaną!", "Note: Functions in B, C, and D are non-const.": "Uwaga: Funkcje w B, C i D to non-const.", "Note: Outside the class, we access the enumerators via the Fruit:: prefix now": "Uwaga: Poza klasą dostęp do modułów wyliczających uzyskujemy teraz poprzez przedrostek Fruit::", "Note: The following cin doesn't ask the user for input, it grabs queued input!": "Uwaga: Poniższy cin nie pyta użytkownika o dane wejściowe, pobiera dane wejściowe z kolejki!", "Note: array can't be const in this case, because returning a non-const reference to a const element would be a const violation.": "Uwaga: w tym przypadku tablica nie może być stałą, ponieważ zwrócenie odwołania innego niż stała do elementu const byłoby stałą naruszenie.", "Note: no getName() function here": "Uwaga: nie ma tutaj funkcji getName()", "Note: save your main() from the prior step, as you'll need it again in the next step": "Uwaga: zapisz funkcję main() z poprzedniego kroku, ponieważ będzie ona potrzebna ponownie w następnym kroku", "Note: we use < instead of > because std::max uses <": "Uwaga: używamy < zamiast >, ponieważ std::max używa <", "Note: we'd prefer to return a std::seed_seq (to initialize a std::mt19937), but std::seed can't be copied, so it can't be returned by value.": "Uwaga: wolelibyśmy zwrócić std::seed_seq (aby zainicjować std::mt19937), ale std::seed nie może zostać skopiowane, więc nie może zostać zwrócone przez wartość.", "Now add a new character": "Teraz dodaj nowy znak", "Now arr is [1, 4, 6, 8]. The first element wasn't doubled.": "Teraz arr wynosi [1, 4, 6, 8]. Pierwszy element nie został podwojony.", "Now calling our swap, not std::swap": "Teraz wywołujemy naszą zamianę, a nie std::swap", "Now declare an char array of size 12": "Teraz zadeklaruj tablicę znaków o rozmiarze 12", "Now define our specialized class template": "Teraz zdefiniuj nasz szablon klasy specjalistycznej", "Now initialize our array from the list": "Teraz zainicjuj naszą tablicę z listy", "Now let's do the equivalent using pointer arithmetic": "Teraz zróbmy to samo za pomocą wskaźnika arytmetyka", "Now let's prove that the pointer holds the address of the first element of the array": "Teraz udowodnijmy, że wskaźnik zawiera adres pierwszego elementu tablicy", "Now print our sorted array as proof it works": "Teraz wydrukuj naszą posortowaną tablicę jako dowód, że działa", "Now read a bunch of values from a file": "Teraz przeczytaj kilka wartości z pliku", "Now set ptr to point at element 3": "Teraz ustaw ptr na element 3", "Now that Vector3d has been defined, we can define the function Point3d::moveByVector()": "Teraz, gdy Vector3d został zdefiniowany, możemy zdefiniować funkcję Point3d::moveByVector()", "Now that the whole array is sorted, print our sorted array as proof it works": "Teraz, gdy cała tablica jest posortowana, wypisz naszą posortowaną tablicę jako dowód, że działa", "Now walk backwards and print characters until ptr reaches str again": "Teraz chodź wstecz i drukuj znaki, aż ptr ponownie osiągnie str", "Now we can assume newLength is at least 1 element.  This algorithm": "Teraz możemy założyć, że newLength ma co najmniej 1 element. Ten algorytm", "Now we can define Display::displayStorage": "Teraz możemy zdefiniować Display::displayStorage", "Now we can delete the old array because we don't need it any more": "Teraz możemy usunąć starą tablicę, ponieważ już jej nie potrzebujemy", "Now we can make use of our Fraction type": "Teraz możemy skorzystać z naszego typu frakcji", "Now we want to go back to read mode so the next call": "Teraz chcemy wrócić do trybu odczytu, więc następne wywołanie", "On an extraction failure, operator>> zero-initializes fundamental types": "W przypadku niepowodzenia ekstrakcji operator>> zero inicjuje wartość podstawową typy", "On some operating systems, argv[0] can end up as an empty string instead of the program's name.": "W niektórych systemach operacyjnych argv[0] może zakończyć się jako pusty ciąg znaków zamiast nazwy programu.", "Once that is done, we can destroy the old array, and make m_data": "Gdy to zrobimy, możemy zniszczyć starą tablicę i utworzyć m_data", "Only 1:1 character mapping can be performed by this function": "Za pomocą tej funkcji można wykonać tylko mapowanie znaków 1:1", "Only a health potion's size affects its power. All other": "Tylko rozmiar mikstury zdrowia wpływa na jej moc. Wszystkie inne", "Oops, we forgot something": "Ups, o czymś zapomnieliśmy", "Operators without constant expression operands can only be used in runtime expressions": "Operandy bez operandów wyrażeń stałych mogą być używane tylko w wyrażeniach wykonawczych", "Or use an if-else statement": "Lub użyj instrukcji if-else", "Or we can upcast Derived to a Base reference and getValue() will resolve to Base::getValue()": "Możemy też przenieść Derived do referencji Base, a funkcja getValue() przekształci się w Base::getValue()", "Order @a before @b if @a is greater than @b.": "Zamów @a wcześniej @b, jeśli @a jest większe niż @b.", "Other variables cannot be used in constant expressions (even when they have a constant expression initializer):": "Innych zmiennych nie można używać w wyrażeniach stałych (nawet jeśli mają inicjator wyrażeń stałych):", "Others can be added here later": "Inne można dodać tutaj później", "Otherwise calculate the new result and add it": "W przeciwnym razie oblicz nowy wynik i dodaj go", "Otherwise fall back to Knuth's algorithm": "W przeciwnym razie wróć do algorytmu Knutha", "Otherwise tell the user what went wrong": "W przeciwnym razie powiedz użytkownikowi, co poszło nie tak", "Otherwise, print the answer": "W przeciwnym razie wydrukuj odpowiedź", "Our CarLot is essentially just a static array of Cars and a lookup function to retrieve them.": "Nasz CarLot to po prostu statyczna tablica samochodów i funkcja wyszukiwania umożliwiająca ich odzyskanie.", "Our array of 3 students (single braced since we mention Student with each initializer)": "Nasza tablica 3 studentów (pojedyncze nawiasy klamrowe, ponieważ wspominamy o Studentach przy każdym inicjatorze)", "Our average is the sum of the numbers we've seen divided by the count of the numbers we've seen": "Nasza średnia to suma liczb, które widzieliśmy, podzielona przez liczbę liczb, które widzieliśmy", "Our doctor will add this patient": "Nasz lekarz doda tego pacjenta", "Our function now optionally returns an int value": "Nasza funkcja teraz opcjonalnie zwraca wartość int", "Our function will return true if the element matches": "Nasza funkcja zwróci wartość true, jeśli element będzie pasował", "Our monster struct represents a single monster": "Nasza struktura potworów reprezentuje pojedynczego potwora", "Our own constexpr implementation of std::abs (for use in C++14/17/20)": "Nasza własna implementacja constexpr std::abs (do użytku w C++ 14/17/20)", "Our print function template needs to know that Coord's template parameter T is a type template parameter": "Nasz szablon funkcji drukowania musi wiedzieć, że parametr szablonu Coorda T jest parametrem szablonu typu", "Outside access uses the access specifiers of the class being accessed.": "Dostęp zewnętrzny wykorzystuje specyfikatory dostępu klasy, do której uzyskuje się dostęp.", "Overload -Cents as a member function": "Przeciążenie — Centy jako funkcja członkowska", "Overload dereference and operator-> so we can use Auto_ptr1 like m_ptr.": "Przeciąż dereferencję i operator->, abyśmy mogli używać Auto_ptr1 jak m_ptr.", "Overload operator[] to take a signed index": "Przeciąż operator [], aby pobrać podpisany indeks", "Overload the unary + operator to convert StudentNames to the underlying type": "Przeciąż operator unary +, aby przekonwertować StudentNames na typ podstawowy", "Overload the unary + operator to convert an enum to the underlying type": "Przeciąż operator jednoargumentowy +, aby przekonwertować wyliczenie na typ podstawowy", "Override print() for fully specialized StaticArray<char, 14>": "Zastąp funkcję print() dla w pełni wyspecjalizowanej tablicy StaticArray<char, 14>", "Override the found element.": "Zastąp znaleziony element.", "PLOGD is defined by the plog library": "PLOGD jest zdefiniowany przez bibliotekę plog", "Pair is an aggregate": "Para jest agregatem", "Pair is no longer an aggregate": "Para nie jest już agregatem", "Pair objects initialized with arguments of type T and T should deduce to Pair<T>": "Obiekty par zainicjowane argumentami typu T i T powinny wydedukować Pair<T>", "Pair objects initialized with arguments of type T and U should deduce to Pair<T, U>": "Obiekty par zainicjowane argumentami typu T i U powinny wydedukować Pair<T, U>", "Partially specialized class": "Zajęcia częściowo specjalistyczne", "Pass by regular reference. The user of the Department class shouldn't care": "Przejdź przez regularne odniesienia. Użytkownika klasy Department nie powinno to obchodzić", "Pass greater to std::sort": "Przekaż większe do std::sort", "Pass in a pointer to \"own\" via the constructor": "Przekaż wskaźnik do „posiadania” za pośrednictwem konstruktora", "Pass std::greater to std::sort": "Przekaż std::większy do std::sort", "Pass to `std::string_view` parameter": "Przejdź do parametru `std::string_view`", "Passing in low and high allows the compiler to infer the type of the input we want": "Przekazywanie wartości low i high pozwala kompilatorowi wywnioskować, jakiego typu danych wejściowych chcemy", "Place all lines of code for the following quiz here": "Umieść tutaj wszystkie linie kodu poniższego quizu", "Player attacks first, monster attacks second": "Gracz atakuje pierwszy, potwór atakuje jako drugi", "Plus one character for a terminator": "Plus jeden znak dla terminatora", "Point has a dependency on std::ostream here": "Punkt jest tutaj zależny od std::ostream", "Point2d third{ 4.0 }; // should error if uncommented": "Point2d trzeci{ 4.0 }; // powinien wystąpić błąd, jeśli nie zostanie skomentowany", "Point3d class defined here": "Zdefiniowano tutaj klasę Point3d", "Point3d is now a friend of class Vector3d": "Point3d jest teraz przyjacielem klasy Vector3d", "Point3d::moveByVector() is now a friend of class Vector3d": "Point3d::moveByVector() jest teraz przyjacielem klasy Vector3d", "Possible implementation of implicit assignment operator": "Możliwa implementacja ukrytego operatora przypisania", "Possible implementation of implicit copy constructor": "Możliwa implementacja ukrytego konstruktora kopiującego", "PoweredDevice is constructed here": "Tutaj budowane jest PoweredDevice", "Pre C++-20: We must explicitly specify all type template argument": "Przed C++-20: Musimy jawnie określić wszystkie argumenty szablonu typów", "Print 10 random numbers": "Wydrukuj 10 losowych liczb", "Print 100 random numbers": "Wydrukuj 100 losowych liczb", "Print Frank's information": "Wydrukuj informacje o Franku", "Print Joe's information": "Wydrukuj informacje o Joe", "Print a bunch of random numbers": "Wydrukuj kilka losowych liczb", "Print a value and count how many times @print has been called.": "Wydrukuj wartość i policz, ile razy wywołano @print.", "Print all cards": "Wydrukuj wszystkie karty", "Print all numbers from 9 to 0": "Wydrukuj wszystkie liczby od 9 do 0", "Print an error and exit": "Wydrukuj błąd i wyjdź", "Print one card": "Wydrukuj jedną kartę", "Print our monster's stats": "Wydrukuj statystyki naszego potwora", "Print out all of the elements in our vector": "Wydrukuj wszystkie elementy naszego wektora", "Print out all the numbers": "Wydrukuj wszystkie liczby", "Print out some values": "Wydrukuj niektóre wartości", "Print out the name": "Wydrukuj nazwę", "Print out the remainders (in reverse order)": "Wydrukuj resztę (w odwrotnej kolejności)", "Print result": "Wydrukuj wynik", "Print the Employee member using the stream object": "Wydrukuj członka pracownika za pomocą obiektu strumienia", "Print the array": "Wydrukuj tablicę", "Print the number": "Wydrukuj numer", "Printer can't access Employee's `this` pointer": "Drukarka nie może uzyskać dostępu do wskaźnika „this” pracownika", "Prints ball height above ground": "Drukuje wysokość piłki nad ziemią", "Prints the sorted names": "Drukuje posortowane nazwy", "Prints true if the type of ptr is int*": "Wypisuje wartość true, jeśli typ ptr to int*", "Private inherited members stay inaccessible": "Prywatni odziedziczeni członkowie pozostają niedostępni", "Private inherited members stay inaccessible (so m_private is inaccessible)": "Prywatni odziedziczeni członkowie pozostają niedostępni (więc m_private jest niedostępny)", "Probably not obvious we should update this too": "Prawdopodobnie nie jest to oczywiste, że powinniśmy to również zaktualizować", "Program will halt on any failed test case": "Program zatrzyma się w przypadku nieudanego przypadku testowego", "Programmer still expects g_mode to be 1": "Programista nadal oczekuje, że g_mode będzie miał wartość 1", "Protected inherited members become private": "Ochroneni dziedziczeni członkowie staną się prywatnymi", "Protected inherited members become private (so m_protected is treated as private)": "Chronieni dziedziczeni członkowie staną się prywatnymi (więc m_protected jest traktowany jako prywatny)", "Protected inherited members stay protected": "Ochroneni dziedziczeni członkowie pozostają chronieni", "Protected inherited members stay protected (so m_protected is treated as protected)": "Chronieni dziedziczeni członkowie pozostają chronieni (więc m_protected jest traktowane jako prywatne) chroniony)", "Prove that ptr[-1] is element 2!": "Udowodnij, że ptr[-1] jest elementem 2!", "Prove that ptr[1] is element 1": "Udowodnij, że ptr[1] jest elementem 1", "Prove that ptr[1] is element 4!": "Udowodnij, że ptr[1] jest elementem 4!", "Prove that we're pointing at element 0": "Udowodnij, że wskazujemy na element 0", "Prove that we're pointing at element 3": "Udowodnij, że wskazujemy na element 3", "Provide the definition for IntPair and the member functions here": "Podaj definicja IntPair i funkcji członkowskich tutaj", "Provide the definition for IntPair and the print() member function here": "Podaj tutaj definicję IntPair i funkcji członkowskiej print()", "Public inherited members become private": "Odziedziczone publicznie elementy członkowskie stają się prywatne", "Public inherited members become private (so m_public is treated as private)": "Odziedziczone publicznie elementy członkowskie stają się prywatne (więc m_public jest traktowane jako prywatne)", "Public inherited members stay public": "Odziedziczone publicznie elementy członkowskie pozostają publiczne", "Public inherited members stay public (so m_public is treated as public)": "Publiczne odziedziczeni członkowie pozostają publiczni (więc m_public jest traktowane jako publiczne)", "Put this line in your shuffle function to shuffle m_cards using the Random::mt Mersenne Twister": "Umieść tę linię w swojej funkcji losowania, aby przetasować m_karty za pomocą Random::mt Mersenne Twister", "Put us back in 'normal' operation mode": "Wprowadź nas z powrotem do „normalnego” trybu działania", "Put us back in 'normal' operation mode (in case we failed)": "Włącz nas z powrotem do „normalnego” trybu działania (w przypadku niepowodzenia)", "Query a few states (we use the any() function to see if any bits remain set)": "Zapytanie o kilka stanów (używamy any(), aby sprawdzić, czy jakieś bity pozostały ustawione)", "Read up to 10 characters": "Odczytaj do 10 znaków", "Read up to 10 more characters": "Odczytaj do 10 dodatkowych znaków", "Recurse to the next bit": "Przejdź do następnego bitu", "Reduce the monster's health by the player's damage": "Zmniejsz zdrowie potwora o obrażenia gracza", "Reduce the player's health by the monster's damage": "Zmniejsz zdrowie gracza o obrażenia potwora uszkodzenia", "Release any resource we're holding": "Zwolnij wszystkie posiadane zasoby", "Remember whether we had a successful extraction": "Pamiętaj, czy ekstrakcja przebiegła pomyślnie", "Remember: function parameters are not constexpr, even in a constexpr function": "Pamiętaj: parametry funkcji nie są constexpr, nawet w funkcji constexpr", "Reminder: A constexpr function can be evaluated at compile-time or runtime.": "Przypomnienie: Funkcję constexpr można ocenić w czasie kompilacji lub w czasie wykonywania.", "Remove 1 character from the left side of the view": "Usuń 1 znak z lewej strony widok", "Remove 2 characters from the right side of the view": "Usuń 2 znaki z prawej strony widoku", "Remove explicit from constructor": "Usuń jawnie z konstruktora", "Remove the element with index 3": "Usuń element o indeksie 3", "Replace this line with the snippet(s) of code you'd like to compile": "Zastąp tę linię fragmentem kodu, który chcesz skompilować", "Requires C++17 or newer.": "Wymaga C++17 lub nowszy.", "Requires seeing the full definition of class Display (as displayStorage is a member)": "Wymaga zobaczenia pełnej definicji klasy Display (ponieważ displayStorage jest członkiem)", "Requires seeing the full definition of class Storage (as we access Storage members)": "Wymaga zobaczenia pełnej definicji klasy Storage (gdy uzyskujemy dostęp do członków Storage)", "Resize the array to 8 elements": "Zmień rozmiar tablicy do 8 elementów", "Resize vector back to 5 elements": "Zmień rozmiar wektora z powrotem do 5 elementów", "Resize vector to 3 elements": "Zmień rozmiar wektora do 3 elementy", "Resource created here": "Zasób utworzony tutaj", "Resource destroyed here when res2 goes out of scope": "Zasób zniszczony tutaj, gdy res2 wykracza poza zakres", "Resource is a struct or class": "Zasób to struktura lub klasa", "Return a copy of arr with all of the values doubled": "Zwróć kopię arr z podwojonymi wszystkimi wartościami", "Return enum value indicating value couldn't be read": "Zwróć wartość wyliczeniową wskazującą, że nie można odczytać wartości", "Return it (otherwise, we go back to top of loop)": "Zwróć ją (w przeciwnym razie wracamy na początek pętla)", "Return student with matching id": "Zwróć ucznia z pasującym identyfikatorem", "Return the entered char to the caller": "Zwróć wprowadzony znak dzwoniącemu", "Return the name of the monster's type as a string": "Zwróć nazwę typu potwora jako ciąg znaków", "Return the value we extracted": "Zwróć wartość, którą wyodrębniliśmy", "Return true if the difference between a and b is less than or equal to absEpsilon, or within relEpsilon percent of the larger of a and b": "Zwróć wartość true, jeśli różnica między a i b jest mniejsza lub równa absEpsilon lub w granicach relEpsilon procent większej z a i b", "Return true if the difference between a and b is within epsilon percent of the larger of a and b": "Zwraca wartość prawda, jeśli różnica między a i b mieści się w granicach epsilon procent większej z wartości a i b", "Return true if the point is set at the origin": "Zwraca wartość prawda, jeśli punkt jest ustawiony na początku", "Return true if the point is set at the origin, false otherwise": "Zwraca wartość prawda, jeśli punkt jest ustawiony na początku, w przeciwnym razie fałsz", "Return value is the integer entered by the user from the keyboard": "Zwracana wartość to liczba całkowita wprowadzona przez użytkownika z klawiatury", "Returns a dumb pointer to an invalid object": "Zwraca głupią wskaźnik do nieprawidłowego obiektu", "Returns a std::weak_ptr to an invalid object": "Zwraca std::weak_ptr do nieprawidłowego obiektu", "Returns ball height from ground after \"seconds\" seconds": "Zwraca wysokość piłki od ziemi po „sekundach” sekundach", "Returns height from ground after \"seconds\" seconds": "Zwraca wysokość od ziemi po „sekundach” sekund", "Returns std::numeric_limits<std::int64_t>::max() if overflow occurs": "Zwraca std::numeric_limits<std::int64_t>::max() w przypadku przepełnienia występuje", "Returns the current ball height after \"seconds\" seconds": "Zwraca aktualną wysokość piłki po „sekundach” sekund", "Returns the user's guess": "Zwraca wartość szacunkową użytkownika", "Returns true if the dealer went bust. False otherwise.": "Zwraca wartość true, jeśli krupier zbankrutował. W przeciwnym razie fałsz.", "Returns true if the player went bust. False otherwise.": "Zwraca wartość true, jeśli gracz upadł. W przeciwnym razie fałsz.", "Returns true if the user won, false if they lost": "Zwraca wartość true, jeśli użytkownik wygrał, false, jeśli przegrał", "Returns true if the value was found. False otherwise.": "Zwraca wartość true, jeśli wartość została znaleziona. W przeciwnym razie fałszywie.", "Reveal the potion type and size": "Pokaż typ i rozmiar mikstury", "Reward the player": "Nagradzaj gracza", "Row elements appear in descending order, so start from 5 and loop through to 1": "Elementy rzędu pojawiają się w kolejności malejącej, więc zacznij od 5 i kieruj się do 1", "SQUARE_H gets defined here": "Tutaj zdefiniowano KWADRAT_H", "Same as above": "Tak samo jak powyżej", "Same example as before": "Ten sam przykład co poprzednio", "Sample call: Random::get(1L, 6L);             // returns long": "Przykładowe wywołanie: Losowo::get(1L, 6L); // zwraca long", "Sample call: Random::get(1u, 6u);             // returns unsigned int": "Przykładowe wywołanie: Random::get(1u, 6u); // zwraca unsigned int", "Sample call: Random::get<std::int>(0, 6u);    // returns int": "Przykładowe wywołanie: Random::get<std::int>(0, 6u); // zwraca int", "Sample call: Random::get<std::size_t>(0, 6);  // returns std::size_t": "Przykładowe wywołanie: Random::get<std::size_t>(0, 6); // zwraca std::size_t", "Sample call: Random::get<std::size_t>(0, 6u); // returns std::size_t": "Przykładowe wywołanie: Random::get<std::size_t>(0, 6u); // zwraca std::size_t", "Sample loop using index": "Przykładowa pętla przy użyciu indeksu", "Sanity check our index value": "Sprawdź poprawność naszego indeksu", "Say your name, Alex": "Powiedz swoje imię, Alex", "Say your name, employee": "Powiedz swoje imię, pracowniku", "Scan our array to see if any elements contain the \"nut\" substring": "Przeskanuj naszą tablicę, aby zobaczyć, czy jakieś elementy zawierają podciąg „nut”", "Search for @search rather than \"nut\".": "Wyszukaj @search zamiast \"nut\".", "Search for two consecutive months that start with the same letter.": "Wyszukaj dwa kolejne miesiące zaczynające się na tę samą literę.", "Search through all elements up to the end of the array - 1": "Przeszukaj wszystkie elementy aż do końca tablicy - 1", "Search through every element starting at startIndex + 1": "Przeszukaj każdy element zaczynając od startIndex + 1", "Searches for the value @guess in @numbers and removes it.": "Wyszukuje wartość @guess w @liczbach i usuwa ją.", "Second, let's compare a-1.0 (almost 0.0) to 0.0": "Po drugie, porównajmy a-1.0 (prawie 0,0) do 0,0", "See 'related content' box below for more info (you don't need to know how these work to use this function)": "Więcej informacji znajdziesz w polu „powiązane treści” poniżej (nie musisz wiedzieć, jak one działają, aby skorzystać z tej funkcji)", "See if our test value is in the array": "Sprawdź, czy nasza wartość testowa znajduje się w tablicy", "See if we can find a match": "Sprawdź, czy możemy znaleźć dopasowanie", "Seed our Mersenne Twister using steady_clock": "Zasiej nasz Mersenne Twister za pomocą stable_clock", "Separator comma used to separate arguments in function call": "Przecinek oddzielający używany do oddzielania argumentów w wywołaniu funkcji", "Separator comma used to separate multiple variables being defined on the same line (don't do this)": "Przecinek oddzielający używany do oddzielania wielu zmiennych zdefiniowanych w tej samej linii (nie rób tego)", "Separator comma used to separate parameters in function definition": "Przecinek oddzielający używany do oddzielania parametrów w definicji funkcji", "Set fcn to point to the function the user chose": "Ustaw fcn, aby wskazywał funkcję wybraną przez użytkownika", "Set ptr to point at element 3": "Ustaw ptr na element 3", "Set sight range to 0": "Ustaw zasięg widzenia na 0", "Set the max seen to the first element": "Ustaw maksimum widzianego pierwszego elementu", "Set the size of the new array appropriately": "Ustaw odpowiednio rozmiar nowej tablicy", "Set up an array of pointers to animals, and set those pointers to our Cat and Dog objects": "Ustaw tablicę wskaźników na zwierzęta i ustaw te wskaźniki na nasze obiekty Kot i Pies", "Showing how a function for a class with a non-type parameter is defined outside of the class": "Pokazanie, jak funkcja dla klasy z parametrem innym niż typ jest zdefiniowana poza class", "Shut down the program now": "Zamknij program teraz", "SignedArrayView provides a view into a container that supports indexing": "SignedArrayView udostępnia widok na kontener obsługujący indeksowanie", "Silent failure if y=0": "Cichy błąd, jeśli y=0", "Since C++20, we don't have to use begin() and end().": "Od C++20 nie musimy używać funkcji Begin() i end().", "Since Doctor and Patient have a circular dependency, we're going to forward declare Patient": "Ponieważ Lekarz i Pacjent mają zależność cykliczną, zamierzamy to zrobić forward deklaruj Patient", "Since all of the overloaded operators create new Fractions, we can guarantee this will get called here": "Ponieważ wszyscy przeciążeni operatorzy tworzą nowe Ułamki, możemy zagwarantować, że zostanie to wywołane tutaj", "Since operator<< is a friend of the Point class, we can access Point's members directly.": "Ponieważ operator<< jest przyjacielem klasy Point, możemy uzyskać bezpośredni dostęp do elementów Point.", "Since test >= 0 and x >=0, we can optimize test < std::sqrt(x) to test * text < x": "Ponieważ test >= 0 i x >=0, możemy zoptymalizować test < std::sqrt(x) w celu przetestowania * tekst < x", "Since the actual variables are inside a namespace, the forward declarations need to be inside a namespace as well": "Ponieważ rzeczywiste zmienne znajdują się w przestrzeni nazw, deklaracje forward również muszą znajdować się w przestrzeni nazw", "Since this could be used elsewhere, it's better to make this its own function": "Ponieważ można tego użyć gdzie indziej, lepiej zrobić z tej własnej funkcji", "Since this function requires asserts to not be compiled out, we'll terminate the program if this function is called when NDEBUG is defined.": "Ponieważ ta funkcja wymaga, aby asercje nie były kompilowane, zakończymy program, jeśli ta funkcja zostanie wywołana po uruchomieniu NDEBUG zdefiniowany.", "Since this function template is deleted, calls to it will halt compilation": "Ponieważ ten szablon funkcji zostanie usunięty, wywołania go zatrzymają kompilację", "Since we can't iterate over an enumerated type using a ranged-for, we'll need to use a traditional for-loop here": "Ponieważ nie możemy iterować po typie wyliczeniowym przy użyciu funkcji Ranged-for, będziemy musieli użyć tutaj tradycyjnej pętli for", "Since we now need to count aces": "Ponieważ musimy teraz policzyć asy", "So here's our temporary tests to validate it works": "A więc oto nasze tymczasowe testy, aby to sprawdzić działa", "So number should be printed only if it is <= the row number, space otherwise": "Więc liczba powinna być wypisana tylko wtedy, gdy jest to <= numer wiersza, w przeciwnym razie spacja", "So we'll define a new pointer with the same address as str": "Zdefiniujemy więc nowy wskaźnik z tym samym adresem co str", "So what do we do here?": "Co więc tutaj zrobimy?", "So will this one.": "Ten też.", "Some class or struct with an overloaded operator<<": "Jakaś klasa lub struktura z przeciążonym operatorem<<", "Some member function that sets private member m_name to the value of the name parameter": "Jakaś funkcja składowa, która ustawia prywatny element m_name na wartość parametru name", "Sort the array": "Sortuj tablicę", "Sort the array in ascending order using the ascending() function": "Sortuj tablicę w porządku rosnącym za pomocą funkcji ascending()", "Sort the array in descending order using the descending() function": "Sortuj tablicę w porządku malejącym za pomocą funkcji malejącej()", "Sort the cars by their make.": "Sortuj samochody według ich marki.", "Specify type and size": "Określ typ i rozmiar", "Specify type only, deduce size": "Określ tylko typ, wydedukuj rozmiar", "Square.h included from main.cpp": "Square.h zawarty w main.cpp", "Start as nullptr": "Rozpocznij jako nullptr", "Start by assuming the smallest element is the first element of this iteration": "Zacznij od założenia, że najmniejszy element jest pierwszym elementem tej iteracji", "Statements that may throw exceptions you want to handle go here": "Instrukcje, które mogą zgłaszać wyjątki, które chcesz obsłużyć, idź tutaj", "Step 1: include the logger headers": "Krok 1: dołącz nagłówki rejestratora", "Step 2: initialize the logger": "Krok 2: zainicjuj rejestrator", "Step 3: Output to the log as if you were writing to the console": "Krok 3: Wyprowadź dane do dziennika tak, jakbyś pisał do konsoli", "Step through each character in string": "Przejdź przez każdy znak w ciągu", "Step through each element of the array": "Przejdź przez każdy element tablicy", "Step through each element of the array (except the last, which will already be sorted by the time we get to it)": "Przejdź przez każdy znak element tablicy (z wyjątkiem ostatniego, który będzie już posortowany, zanim do niego dotrzemy)", "Step through each element of the array except the last": "Przejdź przez każdy element tablicy z wyjątkiem ostatniego", "StudentGrade is an aggregate and emplace_back only works with aggregates as of C++20": "StudentGrade jest agregatem, a emplace_back działa tylko z agregatami od C++ 20", "Such a conversion is a narrowing conversion, since the fractional part of the value will be lost.": "Taka konwersja jest konwersją zawężającą, ponieważ część ułamkowa wartości będzie utracone.", "Swap our start element with our largest element": "Zamień nasz element początkowy z naszym największym elementem", "Swap our start element with our smallest element": "Zamień nasz element początkowy z naszym najmniejszym elementem", "Swap our start element with our smallest/largest element": "Zamień nasz element początkowy z naszym najmniejszym/największym elementem", "T is a type template parameter": "T jest parametrem szablonu typu", "T& is an lvalue reference, so this overload will be preferred for lvalues": "T& jest odniesieniem do lwartości, więc to przeciążenie będzie preferowane dla lwartości", "T&& is an rvalue reference, so this overload will be preferred for rvalues": "T&& jest odniesieniem do rwartości, więc to przeciążenie będzie preferowane w przypadku rwartości", "Take in an 'old' pair, and then move construct the new pair's 'first' and 'second' subobjects from the 'old' ones": "Weź „starą” parę, a następnie przenieś konstrukcję podobiektów „pierwszy” i „drugi” nowej pary ze „starych”", "Takes two std::string objects, returns the one that comes first alphabetically": "Pobiera dwa obiekty std::string, zwraca alfabetycznie ten, który jest pierwszy", "Teach operator<< how to print a Color": "Ucz operatora<< jak aby wydrukować kolor", "Teach operator>> how to input a Color by name": "Naucz operatora>> jak wprowadzić kolor według nazwy", "Teach operator>> how to input an Animal by name": "Naucz operatora>> jak wprowadzić zwierzę według nazwy", "Teacher publicly inherits Person and Employee": "Nauczyciel publicznie dziedziczy osobę i pracownika", "Tell C++ to interpret function foo as a void pointer (implementation-defined behavior)": "Powiedz C++, aby interpretował funkcję foo jako wskaźnik pustki (zachowanie zdefiniowane w implementacji)", "Test additional cases -- h/t to reader Sharjeel Safdar for these test cases": "Przetestuj dodatkowe przypadki -- h/t do czytelnika Sharjeel Safdar za te przypadki testowe", "Test equality true": "Test równości", "Thanks to Shiva for this solution": "Dzięki Shivie za to rozwiązanie", "That way if `names` is ever changed to an expensive to copy type": "W ten sposób, jeśli `names` zostanie kiedykolwiek zmienione na kosztowny do skopiowania typ", "That way we don't have to worry about what kind of smart pointer (if any) the caller may be using": "W ten sposób nie musimy się martwić, jakiego rodzaju inteligentnego wskaźnika (jeśli w ogóle) używa osoba wywołująca", "The = 0 means this function is pure virtual": "= 0 oznacza tę funkcję jest czysto wirtualny", "The Active alias ends here": "Tutaj kończy się aktywny alias", "The C++26 stdCode is a placeholder since the exact code won't be determined until the standard is finalized": "Kod stdCode C++26 jest symbolem zastępczym, ponieważ dokładny kod nie zostanie określony do czasu sfinalizowania standardu", "The Curiously Recurring Template Pattern (CRTP)": "Ciekawie powtarzający się wzorzec szablonu (CRTP)", "The Player struct is still under development.  More members will be added.": "Struktura odtwarzacza jest wciąż w fazie rozwoju. Zostanie dodanych więcej elementów.", "The Resource is destroyed here": "Zasób zostanie tutaj zniszczony", "The above can be condensed to the following single line:": "Powyższe można streścić w następującej pojedynczej linii:", "The above comment ends at the first */, not the second */": "Powyższy komentarz kończy się na pierwszym */, a nie na drugim */", "The above line does NOT change ref into a reference to variable y!": "Powyższa linia NIE zmienia ref na odniesienie do zmiennej y!", "The assert above will probably be compiled out in non-debug builds": "Powyższe potwierdzenie prawdopodobnie zostanie skompilowane w trybie innym niż debugowanie builds", "The caller will supply the value of both x and y": "Wywołujący dostarczy wartość zarówno x, jak i y", "The caller will supply the value of x": "Wywołujący dostarczy wartość x", "The compiler is unable to deduce the type of a": "Kompilator nie jest w stanie wydedukować typu a", "The compiler is unable to deduce the type of b": "Kompilator nie jest w stanie wydedukować typu b", "The compiler knows that each element of houses is a House": "Kompilator wie, że każdy element domu jest domem", "The compiler will compare color and fruit as integers": "The kompilator porówna kolor i owoc jako liczby całkowite", "The compiler will likely complain about gravity being defined but unused": "Kompilator prawdopodobnie będzie narzekał, że grawitacja jest zdefiniowana, ale nieużywana", "The compiler will no longer warn about gravity not being used": "Kompilator nie będzie już ostrzegać o nieużywaniu grawitacji", "The contents of iostream are inserted here": "Tutaj wstawiana jest zawartość iostream", "The continue statement jumps to here": "Instrukcjacontinue przeskakuje do tego miejsca", "The data_handle() member gives us a pointer to the sequence of elements": "Członek data_handle() daje nam wskaźnik do sekwencji elementów", "The destructor will make sure it gets deallocated": "Destruktor upewni się, że zostanie on zwolniony", "The ellipsis must be the last parameter": "Wielokropek musi być ostatnim parametrem", "The equivalent of m_value = 5": "Odpowiednik m_value = 5", "The expression 2 + 3 produces the value 5": "Wyrażenie 2 + 3 daje wartość 5", "The expression parameter controls the size of the array": "Parametr wyrażenia steruje rozmiarem tablicy", "The first argument is the va_list we're using": "Pierwszym argumentem jest va_list, której używamy", "The first number in any row is the same as the row number": "Pierwsza liczba w dowolnym wierszu jest taka sama jak numer wiersza", "The following aliases are identical": "Następujące aliasy są identyczne", "The following are compile-time constants:": "Poniższe są w czasie kompilacji stałe:", "The following are non-constants:": "Poniższe są niestałe:", "The following are runtime constants:": "Poniższe są stałymi wykonawczymi:", "The following color values should be used for a Color": "Następujące wartości kolorów powinny być użyte dla Koloru", "The following function templates can be used to generate random numbers in other cases": "Następujące szablony funkcji mogą być użyte do generowania liczb losowych w innych przypadkach", "The following is also okay.  If we rely on template argument deduction instead, the compiler": "Poniższe również są w porządku. Jeśli zamiast tego polegamy na dedukcji argumentów szablonu, kompilator", "The following is syntactically valid (but semantically meaningless)": "Poniższy wiersz jest poprawny składniowo (ale semantycznie bez znaczenia)", "The following line is split up to reduce the length": "Następujący wiersz jest podzielony w celu zmniejszenia długości", "The following line will throw an exception": "Następujący wiersz zgłosi wyjątek", "The following lines generate a random item based on rarity, level, and a weight factor.": "Następujące wiersze generują losowy przedmiot na podstawie rzadkości, poziomu i współczynnika wagi.", "The following only needs to execute if we're going to iterate again": "Wymagane są tylko poniższe wiersze do wykonania, jeśli mamy zamiar powtórzyć iterację", "The following statements never execute": "Poniższe instrukcje nigdy nie zostaną wykonane", "The following won't work because getValue() has been deleted!": "Poniższe instrukcje nie zadziałają, ponieważ funkcja getValue() została usunięta!", "The function only uses the resource, so we'll accept a pointer to the resource, not a reference to the whole std::unique_ptr<Resource>": "Funkcja używa tylko zasobu, więc akceptujemy wskaźnik do zasobu, a nie odniesienie do całego std::unique_ptr<Resource>", "The function parameter is a copy of str": "Parametr funkcji jest kopią str", "The function parameter is a copy of the argument": "Parametr funkcji to kopia argumentu", "The function parameter is a pointer that holds the address of str": "Parametr funkcji to wskaźnik przechowujący adres str", "The function parameter is a pointer that holds the address of the argument": "Parametr funkcji to wskaźnik przechowujący adres argumentu", "The function parameter is a reference that binds to str": "Parametr funkcji to referencja, która wiąże się z str", "The function parameter is a reference that binds to the argument": "Parametr funkcji to referencja, która wiąże się z argumentem", "The inline keyword means we only have one global instance for our whole program.": "Wbudowane słowo kluczowe oznacza, że mamy tylko jedną globalną instancję dla całego programu.", "The last element has no pair to compare against": "Ostatni element nie ma pary do porównania", "The max value seen so far": "Maksymalna wartość zaobserwowana do tej pory", "The min value seen so far": "Minimalna wartość zaobserwowana do tej pory", "The name of this enum could be omitted since it isn't used anywhere": "Nazwę tego wyliczenia można pominąć, ponieważ nie jest ona nigdzie używana", "The names Color, red, blue, and green are defined inside namespace Color": "Nazwy Kolor, czerwony, niebieski i zielony są zdefiniowane w przestrzeni nazw Kolor", "The names of potions are compile-time literals, we can": "Nazwy mikstur są literałami czasu kompilacji, możemy", "The non-const multiplication operator looks like this": "Operator mnożenia inny niż stały wygląda tak", "The non-type parameter controls the size of the array": "Parametr non-type kontroluje rozmiar tablicy", "The object at the address held by ptr (x) assigned value 6 (note that ptr is dereferenced here)": "Obiekt pod adresem trzymanym przez ptr (x) ma przypisaną wartość 6 (zwróć uwagę, że ptr jest tutaj wyłuskiwany)", "The object is already on the ground. Or buried.": "Obiekt jest już na ziemi. Lub zakopany.", "The object won't reach the ground unless there is positive gravity.": "Obiekt nie dotrze do ziemi, jeśli nie będzie dodatniej grawitacji.", "The pattern's current element was found in the validators. Call the": "W walidatorach znaleziono bieżący element wzoru. Wywołaj", "The pattern's current element was not found in the validators. The": "Bieżący element wzorca nie został znaleziony w walidatorach.", "The player just drank a potion of blindness and can not see anything": "Gracz właśnie wypił miksturę ślepoty i nic nie widzi", "The previous constructor we used for Apple had a fixed name (\"apple\").": "Poprzedni konstruktor, którego używaliśmy dla Apple, miał stałą nazwę („jabłko”).", "The reciprocal of x is 1/x": "Odwrotność x wynosi 1/x", "The reciprocal of x is 1/x, returns 0.0 if x=0": "Odwrotność x wynosi 1/x, zwraca 0,0, jeśli x=0", "The result of this is indeterminate": "Wynik x jest to nieokreślone", "The return type and parameter type are references (to prevent copies from being made)": "Typ zwracany i typ parametru są referencjami (aby zapobiec tworzeniu kopii)", "The return type and parameter type are references (to prevent copies from being made)!": "Typ zwracany i typ parametru są referencjami (aby zapobiec tworzeniu kopii)!", "The return value of a non-constexpr function is a runtime expression": "Wartość zwracana przez funkcję inną niż constexpr jest wyrażeniem wykonawczym", "The return value of a non-constexpr function is not constexpr": "Wartość zwracana przez funkcję inną niż constexpr nie jest constexpr", "The return value of getName() is destroyed just after initialization": "Wartość zwracana przez getName() jest niszczona zaraz po inicjalizacji", "The return values of non-constexpr functions can only be used in runtime expressions": "Wartości zwracane przez funkcje inne niż constexpr mogą być używane tylko w wyrażeniach środowiska wykonawczego", "The second argument is the type of the value": "Drugi argument to typ wartości", "The temporary object holding value 5 has its lifetime extended to match ref": "Typ obiektu tymczasowego przechowującego wartość 5 został przedłużony tak, aby pasował do ref", "The type is deduced to std::array<double, 2>": "Typ jest ustalany na std::array<double, 2>", "The type is deduced to std::array<int, 5>": "Typ jest ustalany na std::array<int, 5>", "The type of userArea is automatically deduced to int.": "Typ userArea jest automatycznie ustalany na podstawie int.", "The user entered a valid element, so let's push it on the vector": "Użytkownik wprowadził poprawny element, więc wepchnijmy go na wektor", "The user lost": "Użytkownik stracił", "The values of x and y are determined by the function that calls add()": "Wartości x i y są określane przez funkcję wywołującą add()", "The values of x and y are passed in by the caller": "Wartości x i y są przekazywane przez obiekt wywołujący", "The versions of `operator<<` and `operator>>` that do output and input don't support constexpr.": "Wersje `operator<<` i `operator>>`, które wykonują dane wyjściowe i wejściowe nie obsługują constexpr.", "Then implicit cast to boolean": "Następnie niejawne rzutowanie na wartość logiczną", "Then look for a smaller element in the rest of the array": "Następnie poszukaj mniejszego elementu w pozostałej części tablicy", "Then we have to allocate new elements": "Następnie musimy przydzielić nowe elementy", "Then we have to figure out how many elements to copy from the existing": "Następnie musimy dowiedzieć się, ile elementów skopiować z istniejącego", "There are 5 rows, we can loop from 1 to 5": "Jest 5 wierszy, możemy wykonać pętlę od 1 do 5", "There is no way to use the return value of generate() here": "Nie ma tutaj możliwości użycia wartości zwracanej przez generate()", "Therefore, we can safely use it here": "Dlatego możemy bezpiecznie użyć jej tutaj", "These are both legal!": "Obydwa są legalne!", "These are the forward declarations for the functions in io.cpp": "To są deklaracje forward dla funkcji w io.cpp", "These need to be static so they are only created once per program, not once per Card": "Muszą być statyczne, więc są tworzone tylko raz na program, a nie raz na Karta", "These symbolic constants define all the possible values this type can hold": "Te stałe symboliczne definiują wszystkie możliwe wartości, jakie ten typ może przechowywać", "These variables can't be constexpr since their initializers aren't constant expressions": "Te zmienne nie mogą być constexpr, ponieważ ich inicjatory nie są wyrażeniami stałymi", "They can optionally be a manager": "Mogą opcjonalnie być menedżerem", "They should use Doctor::addPatient() instead, which is publicly exposed": "Powinni zamiast tego użyć Doctor::addPatient(), która jest publicznie widoczna", "This Animal is an abstract base class": "To zwierzę jest abstrakcyjną bazą klasa", "This FOO does not get replaced with 9 because it’s part of another preprocessor directive": "Ten inspektor obsługi nie jest zastępowany przez 9, ponieważ jest to część innej dyrektywy preprocesora", "This FOO gets replaced with 9 because it's part of the normal code": "Ten inspektor obsługi zostaje zastąpiony przez 9, ponieważ jest częścią normalnego kodu", "This Supervisor can oversee a max of 5 employees": "Ten przełożony może nadzorować maksymalnie 5 pracowników", "This dept holds only one teacher for simplicity, but it could hold many teachers": "W tym dziale pracuje tylko jeden nauczyciel dla uproszczenia, ale może pracować wielu nauczycieli", "This doSomething() adds the value of its parameters": "To doSomething() dodaje wartość swoich parametrów", "This doSomething() belongs to namespace Foo": "Ta doSomething() należy do przestrzeni nazw Foo", "This doSomething() belongs to namespace Goo": "Ta doSomething() należy do przestrzeni nazw Goo", "This doSomething() subtracts the value of its parameters": "Ta doSomething() odejmuje wartość swoich parametrów", "This does exactly the same as the loop we used before.": "Działa dokładnie tak samo jak pętla, której używaliśmy wcześniej.", "This doesn't require access to the internals of the class, so it can be defined outside the class": "Nie wymaga to dostępu do wewnętrznych elementów class, więc można go zdefiniować poza klasą", "This doesn't work anymore": "To już nie działa", "This even works in default member initializers (see warning below)": "Działa to nawet w domyślnych inicjatorach składowych (patrz ostrzeżenie poniżej)", "This example won't compile because it is (intentionally) incomplete": "Ten przykład nie zostanie skompilowany, ponieważ jest (celowo) niekompletny", "This expression statement has the side-effect of incrementing x": "Ta instrukcja wyrażenia ma skutek uboczny w postaci zwiększania x", "This function added": "Ta funkcja dodano", "This function call has two arguments, 6 and 7": "To wywołanie funkcji ma dwa argumenty, 6 i 7", "This function can be evaluated at runtime": "Ta funkcja może być obliczona w czasie wykonywania", "This function can calculate the instant velocity for any gravity value (more useful)": "Ta funkcja może obliczyć prędkość chwilową dla dowolnej wartości grawitacji (bardziej przydatne)", "This function could also return by value if the type is cheap to copy": "Ta funkcja może również zwracać wartość, jeśli typ jest tani do skopiowania", "This function does not return a value so no return statement is needed": "Ta funkcja nie zwraca wartości, więc nie ma instrukcji return potrzebne", "This function handles the entire fight between a player and a randomly generated monster": "Ta funkcja obsługuje całą walkę pomiędzy graczem a losowo wygenerowanym potworem", "This function handles the monster attacking the player": "Ta funkcja obsługuje potwora atakującego gracza", "This function handles the player attacking the monster": "Ta funkcja obsługuje gracza atakującego potwora", "This function has two integer parameters, one named x, and one named y": "Ta funkcja ma dwa parametry całkowite, jeden o nazwie x i jeden o nazwie y", "This function is constexpr": "Ta funkcja to constexpr", "This function is declared as static, and can now be used only within this file": "Ta funkcja jest zadeklarowany jako statyczny i można go teraz używać tylko w tym pliku", "This function is in Foo only": "Ta funkcja jest dostępna tylko w Foo", "This function is made constepxr because it just calculates a value from its inputs and return it.": "Ta funkcja jest consstepxr, ponieważ po prostu oblicza wartość ze swoich danych wejściowych i zwraca ją.", "This function is non-value returning": "Ta funkcja nie zwraca wartości", "This function is not considered a member of the class, even though the definition is inside the class": "Ta funkcja nie jest uważana za element członkowski klasy, nawet jeśli definicja znajduje się wewnątrz klasy", "This function is only useful for calculating your instant velocity based on the global gravity": "Ta funkcja jest przydatne tylko do obliczenia prędkości chwilowej na podstawie globalnej grawitacji", "This function now has an integer parameter": "Ta funkcja ma teraz parametr całkowity", "This function only needs to consider how to print a bool, so it can specialize how it handles": "Ta funkcja musi jedynie rozważyć, jak wydrukować wartość bool, aby mogła specjalizować się w obsłudze", "This function prints numbers between 1 and outer": "Ta funkcja wypisuje liczby od 1 do zewnętrznej", "This function prints out the values in the array": "Ta funkcja wypisuje wartości z tablicy", "This function returns a std::string that is the lower-case version of the std::string_view passed in.": "Ta funkcja zwraca std::string, który jest małą wersją przekazanego std::string_view.", "This function returns the greater of the two numbers if executing in a constant context": "Ta funkcja zwraca większą z dwie liczby, jeśli są wykonywane w stałym kontekście", "This function should not be made constexpr because output and input can only be done at runtime.": "Ta funkcja nie powinna być przekształcana w constexpr, ponieważ dane wyjściowe i wejściowe można wykonać tylko w czasie wykonywania.", "This function takes no parameters": "Ta funkcja nie przyjmuje parametrów", "This function takes one integer parameter named x": "Ta funkcja przyjmuje jeden parametr całkowity o nazwie x", "This function takes ownership of the Resource, which isn't what we want": "Ta funkcja przejmuje na własność zasobu, a nie tego chcemy", "This function template can handle many types, so its implementation is generic": "Ten szablon funkcji może obsługiwać wiele typów, więc jego implementacja jest rodzajowy", "This function template will take precedence for arguments of other types": "Ten szablon funkcji będzie miał pierwszeństwo w przypadku argumentów innych typów", "This function used to do something with count but it is not used any longer": "Ta funkcja służyła do wykonywania operacji zliczania, ale nie jest już używana", "This function uses Newton's method to approximate the root of a given equation.": "Ta funkcja wykorzystuje metodę Newtona do aproksymacji pierwiastka danego równania.", "This function uses a Fraction object, so we just pass the Fraction itself": "Ta funkcja wykorzystuje obiekt Fraction, więc po prostu przekazujemy sam ułamek", "This function will take precedence for arguments of type int": "Ta funkcja będzie miała pierwszeństwo w przypadku argumentów typu int", "This function won't compile": "Ta funkcja nie zostanie skompilowana", "This handler will catch std::exception (and any exception derived from it) that fall": "Ta procedura obsługi przechwyci std::exception (i każdy wyjątek z niego wywodzący się z niego)", "This handler will catch std::exception and all the derived exceptions too": "Ta funkcja obsługi przechwyci std::exception i wszystkie pochodne wyjątki", "This handler will catch std::length_error (and any exceptions derived from it) here": "Ta procedura obsługi przechwyci std::length_error (i wszelkie wyjątki z niego wywodzące się) tutaj", "This header-only Random namespace implements a self-seeding Mersenne Twister.": "To tylko nagłówek Losowa przestrzeń nazw implementuje samozasysający Mersenne Twister.", "This is a helper function to make it easier to do this": "To jest funkcja pomocnicza ułatwiająca wykonanie tej operacji", "This is a multi-line /* comment": "To jest komentarz wieloliniowy /*", "This is a multi-line comment.": "To jest komentarz wielowierszowy.", "This is a non-specialized function of partially specialized class Storage<T*>": "To jest niewyspecjalizowana funkcja częściowo wyspecjalizowanej klasy Storage<T*>", "This is a normal (non-specialized) member function definition (for member function print of specialized class Storage<double>)": "To jest normalna (niespecjalizowana) definicja funkcji składowej (dla wydruku funkcji składowej wyspecjalizowanej klasy Storage<double>)", "This is a specialized member function definition": "To jest wyspecjalizowana definicja funkcji składowej", "This is a view, so the ArrayFlat2d being viewed must stay in scope": "To jest widok, więc oglądana ArrayFlat2d musi pozostać w zakresie", "This is also executed": "To jest również wykonywane", "This is because we've defined m_ptr to have type T* (not T)": "Dzieje się tak, ponieważ zdefiniowaliśmy m_ptr jako typ T* (nie T)", "This is case-sensitive, so True or TRUE will not work": "Ważna jest wielkość liter, więc True lub TRUE nie będzie działać", "This is our primary template class (same as previous)": "To jest nasza główna klasa szablonów (taka sama jak poprzednia)", "This is part of the comment and": "To jest część komentarza i", "This is partially specialized for T*": "To jest częściowo wyspecjalizowane dla T*", "This is really Foo::Goo::add()": "To jest naprawdę Foo::Goo::add()", "This is the content of the .h file, which is where the declarations go": "To jest zawartość pliku .h, w którym znajdują się deklaracje", "This is the function body (tells the compiler what the function does)": "To jest treść funkcji (informuje kompilator, co robi funkcja)", "This is the function header (tells the compiler about the existence of the function)": "To jest nagłówek funkcji (informuje kompilator o istnieniu funkcji)", "This is the new largest number for this iteration": "To jest nowy największy numer tej funkcji iteracja", "This is the new smallest/largest number for this iteration": "To jest nowa najmniejsza/największa liczba w tej iteracji", "This is the same as int count(T x), except we're not giving the parameter a name since we don't use the parameter": "To jest to samo, co int count(T x), z tą różnicą, że nie nadajemy parametrowi nazwy, ponieważ nie używamy parametr", "This line will be ignored.": "Ta linia zostanie zignorowana.", "This object will be destroyed during stack unwinding (if it occurs)": "Ten obiekt zostanie zniszczony podczas rozwijania stosu (jeśli tak się stanie)", "This only defines what a Fraction looks like, it doesn't create one": "To tylko definiuje, jak wygląda ułamek, a nie tworzy go", "This only defines what a Fraction type looks like, it doesn't create one": "To tylko definiuje, jak wygląda typ ułamka, nie tworzy go", "This program calculates the student's final grade based on their test and homework scores.": "Ten program oblicza końcową ocenę ucznia na podstawie jego testu i wyniki pracy domowej.", "This program doesn't work": "Ten program nie działa", "This program prints the C++ language standard your compiler is currently using": "Ten program drukuje standard języka C++, którego aktualnie używa twój kompilator", "This statement is executed after doPrint() ends": "Ta instrukcja jest wykonywana po zakończeniu funkcji doPrint()", "This table defines all special symbols that can match a range of user input": "Ta tabela definiuje wszystkie symbole specjalne, które mogą pasować do zakresu wprowadzonego przez użytkownika", "This temporary std::string will be destroyed at the end of the full expression": "To tymczasowe std::string zostanie zniszczone na końcu pełnego wyrażenie", "This version of getThis() returns a pointer to a Base class": "Ta wersja getThis() zwraca wskaźnik do klasy Base", "This version of the Fraction class auto-reduces fractions": "Ta wersja klasy Fraction automatycznie redukuje ułamki", "This version subject to partial extraction issues (see below)": "Ta wersja podlega problemom z częściową ekstrakcją (patrz poniżej)", "This will put a 1 in the bit we're interested in turning on/off": "To wstawi 1 w bit, który chcemy włączyć/wyłączyć", "This will rearrange all the Cards in the deck randomly": "To spowoduje zmianę układu wszystkich kart w talii losowo", "This works as expected": "Działa zgodnie z oczekiwaniami", "Throw an object of class MyException": "Rzuć obiekt klasy MyException", "Throw char exception 'q' up the stack to be handled by caller": "Wrzuć wyjątek char „q” w górę stosu, który ma zostać obsłużony przez obiekt wywołujący", "To access member y of Point c of the Triangle pointed to by ptr, the following are equivalent:": "Aby uzyskać dostęp do elementu y punktu c Trójkąta wskazanego przez ptr, poniższe są równoważne:", "To calculate the final grade, we sum all the weighted midterm and homework scores": "Aby obliczyć końcową ocenę, sumujemy wszystkie ważone prace semestralne i prace domowe wyniki", "To generate a random item, we're going to do the following:": "Aby wygenerować losowy element, wykonamy następujące czynności:", "To make the range checks easier, we'll ensure base is positive": "Aby ułatwić sprawdzanie zakresu, upewnimy się, że podstawa jest dodatnia", "To prevent slicing (covered later)": "Aby zapobiec krojeniu (omówione później)", "To prevent writing the type twice, we can use auto. This is often done for types with long names.": "Aby zapobiec dwukrotnemu zapisywaniu typu, możemy użyć funkcji auto. Często robi się to w przypadku typów o długich nazwach.", "To trigger copy constructor exception": "Aby wywołać wyjątek konstruktora kopiującego", "Today is Joe's birthday": "Dzisiaj są urodziny Joego", "Transfer ownership of a.m_ptr to m_ptr": "Przenieś własność a.m_ptr na m_ptr", "Try to extract the age": "Spróbuj wyodrębnić wiek", "Try to get a line of input": "Spróbuj uzyskać wiersz wejściowy", "Try to parse an int from age": "Spróbuj przeanalizować liczbę int z age", "Try to use the variables without explicitly capturing them.": "Spróbuj użyć zmiennych bez ich jawnego przechwytywania.", "Turn on std::ios::hex as the only std::ios::basefield flag": "Włącz std::ios::hex jako jedyną flagę std::ios::basefield", "Type aliases to make accessing nested type easier": "Aliasy typów, aby ułatwić dostęp do typu zagnieżdżonego", "UZ is the suffix for literals of type std::size_t.": "UZ to przyrostek literałów typu std::size_t.", "Uncomment the following line to make this operator do the same thing": "Odkomentuj następujący wiersz, aby ten operator zrobił to samo", "Use a for loop to iterate through all our colors": "Użyj pętli for, aby iterować po wszystkich naszych kolorach", "Use an 8-bit integer as the enum underlying type": "Użyj 8-bitowej liczby całkowitej jako podstawowego typu wyliczeniowego", "Use an explicit object parameter (self) and auto&& to differentiate const vs non-const": "Użyj jawnego parametru obiektu (self) i auto&&, aby rozróżnić const od non-const", "Use function template specialization to tell the compiler that addOne(const char*) should emit a compilation error": "Użyj specjalizacji szablonu funkcji, aby poinformować kompilator, że addOne(const char*) powinien wyemitować błąd kompilacji", "Use member selection operator (.) to select a member from struct object": "Użyj operatora wyboru elementu członkowskiego (.), aby wybrać element z obiektu struktury", "Use member selection operator (.) to select member from reference to struct": "Użyj operatora wyboru elementu członkowskiego (.), aby wybrać element z odniesienia do struktury", "Use of uninitialized variable leads to undefined result": "Użycie niezainicjowanej zmiennej prowadzi do niezdefiniowanego wynik", "Use prefix operator to decrement this digit": "Użyj operatora przedrostka, aby zmniejszyć tę cyfrę", "Use prefix operator to increment this digit": "Użyj operatora przedrostka, aby zwiększyć tę cyfrę", "Use std::begin and std::end to get the begin and end points.": "Użyj std::begin i std::end, aby uzyskać punkty początkowe i końcowe.", "Use std::sort here": "Użyj std::sort tutaj", "Use the get() member function to get the referenced string.": "Użyj funkcji członkowskiej get(), aby uzyskać odwołanie string.", "Used to eat (remove) the slash between the numerator and denominator": "Służy do zjadania (usuwania) ukośnika między licznikiem a mianownikiem", "Uses abbreviated function template (C++20) and `auto` return type to make this function work with any type of value": "Używa skróconego szablonu funkcji (C++20) i typu powrotu `auto`, aby ta funkcja działała z dowolnym typem wartości", "Uses the above DynamicArray class": "Używa powyższej klasy DynamicArray", "Using a constexpr variable": "Używanie constexpr zmienna", "Using a literal constant": "Użycie stałej literału", "Using a macro (don't do this, use a constexpr variable instead)": "Użycie makra (nie rób tego, zamiast tego użyj zmiennej constexpr)", "Using an enumerator": "Użycie modułu wyliczającego", "Using auto. Stores the lambda with its real type.": "Użycie auto. Przechowuje lambdę w jej rzeczywistym typie.", "Using const pointers, `dest` being a pointer-to-non-const may go unnoticed amongst the sea of spurious consts.": "Używając wskaźników const, `dest` będący wskaźnikiem do nie-const może pozostać niezauważony w morzu fałszywych stałych.", "Using formula: [ s = u * t + (a * t^2) / 2 ], here u(initial velocity) = 0": "Używając wzoru: [ s = u * t + (a * t^2) / 2 ], tutaj u(prędkość początkowa) = 0", "Using formula: s = (u * t) + (a * t^2) / 2": "Używając wzoru: s = (u * t) + (a * t^2) / 2", "Using non-const pointers, all consts are significant.": "Używając wskaźników innych niż stałe, wszystkie stałe są znaczące.", "Using std::function. The lambda could have a non-empty capture clause (discussed next lesson).": "Używając std::function. Lambda może mieć niepustą klauzulę przechwytującą (omówiono to w następnej lekcji).", "Using std::reference_wrapper gives us reference semantics and copy assignability.": "Użycie std::reference_wrapper daje nam semantykę referencji i możliwość przypisania kopii.", "Using the IntArray overloaded operator[] above": "Użycie przeciążonego operatora IntArray[] powyżej", "Value initialization (uses default constructor)": "Inicjalizacja wartości (używa konstruktora domyślnego)", "Variables declared outside of a function are global variables": "Zmienne zadeklarowane poza funkcją są zmiennymi globalnymi", "Vector of const references to std::string": "Wektor stałych odwołań do std::string", "Vector3d class defined in this file": "Klasa Vector3d zdefiniowana w tym pliku", "Visual Studio is non-conforming in support for __cplusplus (unless you set a specific compiler flag, which you probably haven't)": "Visual Studio nie jest zgodne w obsłudze __cplusplus (chyba że ustawiłeś konkretną flagę kompilatora, czego prawdopodobnie nie zrobiłeś)", "We access the ellipsis through a va_list, so let's declare one": "Dostęp do elipsy poprzez va_list, więc zadeklarujmy ją", "We allocated pSimple dynamically, so we have to delete it.": "Dynamicznie przydzieliliśmy pSimple, więc musimy go usunąć.", "We already proved b is pointing to a Derived object, so this should always succeed": "Udowodniliśmy już, że b wskazuje na obiekt Derived, więc to zawsze powinno się udać", "We already specified the type at the function declaration": "Podaliśmy już typ w deklaracji funkcji", "We avoid recursive calls by invoking std::swap on the std::string member,": "Unikamy wywołań rekurencyjnych poprzez wywoływanie std::swap na elemencie std::string,", "We can access data members before they are defined": "Możemy uzyskać dostęp do elementów danych przed ich zdefiniowaniem", "We can access it by using the end() member function.": "Możemy uzyskać do nich dostęp za pomocą funkcji członka end().", "We can access member functions before they are defined": "Możemy uzyskać dostęp do funkcji składowych przed ich zdefiniowaniem", "We can also use automatic type deduction to good effect here": "Możemy tu również z dobrym skutkiem zastosować automatyczne dedukowanie typów", "We can avoid literals with suffixes": "Możemy unikać literałów za pomocą sufiksy", "We can avoid static_casts": "Możemy uniknąć static_casts", "We can call Random::get() to generate random integral values": "Możemy wywołać Random::get() w celu wygenerowania losowych wartości całkowitych", "We can call the Base::getValue() function directly": "Możemy wywołać funkcję Base::getValue() bezpośrednio", "We can compare averageTemperature of the two arguments to": "Możemy porównać średnią temperaturę obu argumentów z", "We can continue to use arr1": "Możemy nadal używać arr1", "We can create a variable and return the variable (we'll improve this below)": "Możemy utworzyć zmienną i zwrócić zmienną (ulepszymy to poniżej)", "We can explicitly convert the types to match": "Możemy jawnie przekonwertować typy, aby dopasować", "We can extract the string from an std::stringstream by using the str()": "Możemy wyodrębnić ciąg znaków z std::stringstream za pomocą str()", "We can index the array using the enumerator to get the name of the enumerator": "Możemy zaindeksować tablicę za pomocą modułu wyliczającego, aby uzyskać nazwę modułu wyliczającego", "We can make a std::pair without any problems:": "Możemy utworzyć std::pair bez żadnych problemów:", "We can now access the enumerators of Color without using a Color:: prefix": "Możemy teraz uzyskać dostęp do modułów wyliczających Color bez użycia przedrostka Color::", "We can only switch on an integral value (or enum), not a string": "Możemy włączyć tylko wartość całkowitą (lub wyliczenie), a nie ciąg znaków", "We can remove these operators, and the program continues to work": "Możemy usunąć te operatory, a program będzie nadal działać", "We can use empty curly braces to value-initialize all members": "Możemy użyć pustych nawiasów klamrowych do inicjalizacji wartości wszystkich elementów", "We can use operator< on std::string to determine which comes first alphabetically": "Możemy użyj operatora< na std::string, aby określić, co jest pierwsze w kolejności alfabetycznej", "We can use the fact that access controls work on a per-class basis here": "Możemy wykorzystać fakt, że kontrola dostępu działa tutaj dla poszczególnych klas", "We can't and shouldn't pass by non-const reference, because then": "Nie możemy i nie powinniśmy przekazywać referencji innych niż stałe, ponieważ wtedy", "We can't forward declare variables as constexpr, but we can forward declare them as (runtime) const": "Nie możemy dalej deklarować zmiennych jako constexpr, ale możemy dalej deklarować je jako const (runtime)", "We can't instantiate an abstract base class, but for the sake of example, pretend this was allowed": "Nie możemy utwórz instancję abstrakcyjnej klasy bazowej, ale dla przykładu udawaj, że jest to dozwolone", "We can't modify str this time (we need it later)": "Tym razem nie możemy zmodyfikować str (potrzebujemy tego później)", "We captured comparisons by reference. We can modify it without \"mutable\".": "Porównania przechwyciliśmy przez odniesienie. Możemy go zmodyfikować bez „mutable”.", "We could add logic here if needed later": "Możemy dodać tutaj logikę, jeśli zajdzie taka potrzeba później", "We could put these in a struct, but since we only have two attributes we'll keep them separate for now": "Moglibyśmy umieścić je w strukturze, ale ponieważ mamy tylko dwa atrybuty, na razie zachowamy je oddzielnie", "We decided to use a linked list instead of an array because": "Zdecydowaliśmy się użyć połączonej listy zamiast tablicy, ponieważ", "We didn't find a match, so input must have been invalid": "Nie znaleźliśmy dopasowania, więc dane wejściowe musiały być nieprawidłowe", "We don't have to change this": "Nie musimy to zmienić", "We don't need mutable anymore": "Nie potrzebujemy już funkcji mutable", "We don't need to #include <iostream> since main.cpp doesn't use any input/output functionality": "Nie musimy #include <iostream> ponieważ main.cpp nie używa żadnej funkcjonalności wejścia/wyjścia", "We don't need to calc row and col 0 since mult by 0 always is 0": "Nie musimy obliczać wierszy i kolumn 0, ponieważ mnożenie przez 0 zawsze wynosi 0", "We don't need to call print() here since it will be called by": "Nie musimy tutaj wywoływać funkcji print(), ponieważ zostanie ona wywołana by", "We don't need to delete m_ptr here.  This constructor is only called when we're creating a new object, and m_ptr can't be set prior to this.": "Nie musimy tutaj usuwać m_ptr. Ten konstruktor jest wywoływany tylko wtedy, gdy tworzymy nowy obiekt i nie można wcześniej ustawić m_ptr.", "We don't need to provide names for these parameters since they aren't used": "Nie musimy podawać nazw tych parametrów, ponieważ nie są one używane", "We don't use the return value in this program, but it doesn't add complexity to have it, and may be useful in a future update": "Nie używamy wartości zwracanej w tym programie, ale nie zwiększa to złożoności i może być przydatne w przyszłej aktualizacji", "We don't want to allow copies of IntArray to be created.": "Nie chcemy zezwalać na kopie IntArray który ma zostać utworzony.", "We don't want to pass by value, because copying is slow.": "Nie chcemy przekazywać wartości, ponieważ kopiowanie jest powolne.", "We first used std::stringstream in lesson 7.13.": "Po raz pierwszy użyliśmy std::stringstream w lekcji 7.13.", "We forgot to redefine speak": "Zapomnieliśmy przedefiniować mówić", "We have to deal with the first number specially": "Musimy zająć się specjalnie pierwszą liczbą", "We have to update any member functions to reflect the new implementation": "Musimy zaktualizować wszystkie funkcje składowe, aby odzwierciedlić nową implementacja", "We haven't covered classes yet, so don't worry if this doesn't make sense": "Nie omówiliśmy jeszcze klas, więc nie martw się, jeśli nie ma to sensu", "We initialize the va_list using va_start.  The first argument is": "Inicjujemy listę va_list za pomocą va_start. Pierwszy argument to", "We modify the state using large constants and intentional overflow to make it hard": "Modyfikujemy stan za pomocą dużych stałych i celowego przepełnienia, aby było to trudne", "We moved this out of attackMonster() to keep the function shorter.": "Przenieśliśmy tę funkcję z atakuMonster(), aby funkcja była krótsza.", "We must pass std::mdspan a pointer to the sequence of elements": "Musimy przekazać std::mdspan wskaźnik do sekwencji elementów", "We must specify the return type using a template type argument (between the angled brackets)": "Musimy określić typ zwracany za pomocą argumentu typu szablonu (między nawiasami ostrymi)", "We need a new constructor for GrannySmith to use to set the name of the fruit": "Potrzebujemy nowego konstruktora, którego GrannySmith będzie mógł użyć do ustawienia nazwy funkcji owoce", "We need to calculate the area before we can search for it.": "Musimy obliczyć obszar, zanim będziemy mogli go wyszukać.", "We need to deallocate our string": "Musimy zwolnić nasz ciąg znaków", "We need to divide ad.clickThroughRatePercentage by 100 because it's a percent of 100, not a multiplier": "Musimy podzielić ad.clickThroughRatePercentage przez 100, ponieważ jest to procent 100, a nie mnożnik", "We need to make sure we set m_data to 0 here, otherwise it will": "Musimy się upewnić, że ustawiliśmy tutaj m_data na 0, w przeciwnym razie", "We need to make sure we set m_data to nullptr here, otherwise it will": "Będziemy musimy się upewnić, że ustawiliśmy tutaj m_data na nullptr, w przeciwnym razie", "We need to multiply quantity by 2 here because they are bought in pairs": "Musimy tutaj pomnożyć ilość przez 2, ponieważ kupuje się je parami", "We need to remember to do a floating point division here, not an integer division": "Musimy pamiętać, aby tutaj wykonać dzielenie zmiennoprzecinkowe, a nie dzielenie przez liczby całkowite", "We normally pass string_view by value, so we'll use auto here": "Zwykle przekazujemy string_view przez wartość, więc użyjemy tutaj auto", "We now know that y != 0": "Teraz wiemy, że y != 0", "We pass animal by non-const reference so we can have the function modify its value": "Przekazujemy zwierzę przez odniesienie inne niż stałe, dzięki czemu funkcja może modyfikować jej wartość", "We pass color by non-const reference so we can have the function modify its value": "Przekazujemy kolor przez odniesienie inne niż stałe, dzięki czemu funkcja może modyfikować jego wartość", "We put reduce() in the constructor to ensure any fractions we make get reduced!": "Wstawiamy funkcję redukcji() do konstruktora, aby mieć pewność, że wszystkie ułamki, które wykonamy, zostaną zmniejszone!", "We put reduce() in the constructor to ensure any new fractions we make get reduced!": "Umieszczamy redukcję() w konstruktorze, aby zapewnić, że wszystkie nowe ułamki zostaną otrzymane zmniejszona!", "We really should have a header guard here, but will omit it for simplicity (we'll cover header guards in the next lesson)": "Naprawdę powinniśmy mieć tutaj osłonę nagłówka, ale pominiemy ją dla uproszczenia (zabezpieczenia nagłówka omówimy w następnej lekcji)", "We store areas, but the user entered width and height.": "Przechowujemy obszary, ale użytkownik wprowadził szerokość i wysokość.", "We use [[maybe_unused]] to avoid warnings about unused variables": "Używamy [[maybe_unused]], aby uniknąć ostrzeżeń o nieużywanych zmiennych", "We use a conditional here to avoid compiler warnings about infinite recursion": "Używamy tutaj warunku, aby uniknąć ostrzeżeń kompilatora o nieskończona rekurencja", "We use a std::stringstream, but this could also be solved using": "Używamy std::stringstream, ale można to również rozwiązać za pomocą", "We use extern to ensure these have external linkage": "Używamy extern, aby zapewnić zewnętrzne powiązanie", "We use multidimensional [] to access elements": "Używamy wielowymiarowego [], aby uzyskać dostęp do elementów", "We use std::string because it is movable (std::string_view is not)": "Używamy std::string, ponieważ jest ruchomy (std::string_view nie jest)", "We use va_arg to get values out of our ellipsis": "Używamy va_arg, aby uzyskać wartości z naszego wielokropka", "We want the user to enter a 'y' or 'n' character": "Chcemy, aby użytkownik wprowadził znak „y” lub „n”", "We want to do floating point division, so one of the operands needs to be a floating point type": "Chcemy wykonać dzielenie zmiennoprzecinkowe, więc jeden z operandów musi być typu zmiennoprzecinkowego", "We want to print sv using the printString() function": "Chcemy wydrukować sv za pomocą funkcji printString()", "We want to test the following function": "Chcemy przetestować następujące elementy funkcja", "We will be explicit about expecting `name` to be a std::string_view here": "Będziemy wyraźnie mówić, że `name` będzie std::string_view tutaj", "We will explicitly define the element type so we don't have to use the sv suffix": "Wyraźnie zdefiniujemy typ elementu, więc nie będziemy musieli używać sufiksu sv", "We will follow their lead and take a const std::string&": "Pójdziemy za ich przykładem i przyjmiemy const std::string&", "We'll also prefix these for consistency": "Będziemy je również poprzedzać spójność", "We'll call calculate first so an invalid operator prints an error message on its own line": "Najpierw wywołamy funkcję obliczenia, aby nieprawidłowy operator wypisał komunikat o błędzie we własnej linii", "We'll comment out this line later": "Komentujemy tę linię później", "We'll conditionalize our response on whether argv[0] is empty or not.": "Uwarunkowamy naszą odpowiedź od tego, czy argv[0] jest pusty, czy nie.", "We'll convert name.length() to a signed value": "Przekonwertujemy name.length() na wartość ze znakiem", "We'll define a symbolic constant with a nice name": "Zdefiniujemy stałą symboliczną za pomocą nice name", "We'll delegate to the prior constructor so we don't have to duplicate the negative number and overflow handling logic": "Przedelegujemy do poprzedniego konstruktora, abyśmy nie musieli duplikować liczby ujemnej i logiki obsługi przepełnienia", "We'll flip the result at the end if needed": "W razie potrzeby odwrócimy wynik na końcu", "We'll friend Doctor::addPatient() so it can access the private function Patient::addDoctor()": "Zaprzyjaźnimy się z Doctor::addPatient(), aby mógł uzyskać dostęp do prywatnej funkcji Patient::addDoctor()", "We'll implement this function below Patient since we need Patient to be defined at that point": "Zaimplementujemy tę funkcję poniżej Patient, ponieważ potrzebujemy Pacjent do zdefiniowania w tym momencie", "We'll implement this function below to parallel operator<<(std::ostream&, const Doctor&)": "Zaimplementujemy tę funkcję poniżej do operatora równoległego<<(std::ostream&, const Doctor&)", "We'll make a file called Sample.txt": "Utworzymy plik o nazwie Sample.txt", "We'll make these static so we only have to do initialization once": "Uczynimy je statycznymi, więc inicjalizację będziemy musieli wykonać tylko raz", "We'll pass the ios:app flag to tell the ofstream to append": "Przekażemy flagę ios:app, aby poinformować ofstream append", "We'll read from a file called Sample.txt": "Będziemy czytać z pliku o nazwie Sample.txt", "We'll rely on member function identify() to return the string to be printed": "Będziemy polegać na funkcji członkowskiejident(), aby zwrócić ciąg do wydrukowania", "We'll rely on member function print() to do the actual printing": "Będziemy polegać na funkcji składowej print(), aby wykonać faktyczne drukowanie", "We'll trigger one of these exceptions intentionally for the sake of the example": "Na potrzeby przykładu celowo uruchomimy jeden z tych wyjątków", "We'll use a function to add the card to the player's score": "Użyjemy funkcji, aby dodać kartę do wyniku gracza", "We'll use a static std::vector to cache calculated results": "Użyjemy statycznego std::vector do buforowania obliczonych wyników", "We'll write two lines into this file": "Zapiszemy dwie linie w tym pliku", "We're allowed to modify ammo now": "Możemy modyfikować amunicję teraz", "We're going to define this outside the class for reasons that will become obvious shortly": "Zdefiniujemy to poza klasą z powodów, które wkrótce staną się oczywiste", "We're going to make addDoctor private because we don't want the public to use it.": "Uczynimy addDoctor prywatnym, ponieważ nie chcemy, aby inni z niego korzystali.", "We're going to test a bunch of values to see if the algorithm returns the result we expect": "Przetestujemy kilka wartości, aby sprawdzić, czy algorytm zwróci oczekiwany wynik", "We're going to use Newton's method to find the root of a number because": "Będziemy używać metody Newtona do znalezienia pierwiastka liczby ponieważ", "We're intentionally using a named object here so mandatory copy elision doesn't apply": "Celowo używamy tutaj nazwanego obiektu, więc nie ma zastosowania obowiązkowe usuwanie kopii", "We're making this constructor protected because": "Chronimy ten konstruktor, ponieważ", "We're using two template type parameters named T and U": "Używamy dwóch parametrów typu szablonu o nazwach T i U", "We've added a list constructor": "Dodaliśmy konstruktor listy", "We've also renamed it Type and made it an enum rather than an enum class": "Zmieniliśmy także jego nazwę Type i uczyniliśmy z niej wyliczenie, a nie wyliczenie klasa", "We've opted to use an uppercase name here for consistency with the prior example, but it also makes it easier to see the call": "Zdecydowaliśmy się użyć tutaj nazwy wielkiej litery, aby zachować spójność z poprzednim przykładem, ale ułatwia to także zobaczenie wywołania", "What are we catching here?": "Co tu wyłapujemy?", "What constructor is used here?": "Jakiego konstruktora tu użyto?", "What follows is just standard class implementation details": "Poniżej znajdują się tylko szczegóły implementacji standardowej klasy", "What happens if creation of A fails and we want to handle it here?": "Co się stanie, jeśli utworzenie A nie powiedzie się, a my chcemy się tym zająć tutaj?", "What happens if we try to use an initializer list with this container class?": "Co się stanie, jeśli spróbujemy użyć listy inicjatorów z tą klasą kontenera?", "When calling a function by itself, no value is required": "Podczas samodzielnego wywoływania funkcji nie jest wymagana żadna wartość", "When calling a function in a context that requires a value (like std::cout)": "Podczas wywoływania funkcji w kontekście wymagającym wartości (np. std::cout)", "When evaluated at compile-time, the function will produce a compilation error": "Gdy funkcja jest oceniana w czasie kompilacji, funkcja zgłosi błąd kompilacji", "When inf goes out of scope, the ifstream": "Gdy inf wykracza poza zakres, funkcja ifstream", "When outf goes out of scope, the ofstream": "Kiedy outf wykracza poza zakres, ofstream", "When using Array2d as a function parameter, we need to respecify the template parameters": "Gdy używamy Array2d jako parametru funkcji, musimy ponownie określić parametry szablonu", "When we already have an object, push_back and emplace_back are similar in efficiency": "Gdy mamy już obiekt, push_back i emplace_back są podobne pod względem wydajności", "When we define a member function inside the class definition,": "Kiedy definiujemy funkcję składową w definicji klasy,", "When we define a member function outside the class definition,": "Kiedy definiujemy funkcję składową poza klasą definicja,", "When we need to create a temporary object to push, emplace_back is more efficient": "Kiedy musimy utworzyć tymczasowy obiekt do wypchnięcia, bardziej wydajna jest metoda emplace_back", "Which getID() do we call?": "Którą metodę getID() wywołujemy?", "While the monster isn't dead and the player isn't dead, the fight continues": "Dopóki potwór nie jest martwy i gracz nie jest martwy, walka trwa", "While there's still data to process": "Dopóki są jeszcze dane do przetworzenia", "While there's still stuff left to read": "Dopóki jest jeszcze coś do przetworzenia czytaj", "While we haven't encountered a null terminator": "Chociaż nie napotkaliśmy terminatora zerowego", "Will always execute.  Should be inside compound statement.": "Będzie zawsze wykonywany. Powinno znajdować się wewnątrz instrukcji złożonej.", "Worst: member function print() uses direct access to m_flavor when getter exists": "Najgorsze: funkcja członkowska print() używa bezpośredniego dostępu do m_flavor, gdy istnieje getter", "Write an error to some global logfile": "Zapisz błąd w jakimś globalnym pliku dziennika", "Write the function getApplesPluralized() here": "Napisz tutaj funkcję getApplesPluralized()", "Write the function getQuantityPhrase() here": "Napisz tutaj funkcję getQuantityPhrase()", "Write your printElement function here": "Napisz swoją funkcję printElement tutaj", "You can has bomb too (note: type is int&)": "Możesz też mieć bombę (uwaga: typ to int&)", "You can ignore these if you don't understand them": "Możesz je zignorować, jeśli ich nie rozumiesz", "You could also output the monster instead": "Możesz też zamiast tego wyprowadzić potwora", "You might be tempted to make m_arr a reference to an ArrayFlat2d,": "Możesz ulec pokusie, aby m_arr stał się odniesieniem do ArrayFlat2d,", "You still has?": "Nadal tak jest?", "You will need to make testDecimal a friend of FixedPoint2": "Będziesz musiał to zrobić testDecimal znajomy FixPoint2", "You're probably expecting this to print 65": "Prawdopodobnie spodziewasz się, że wydrukuje 65", "Your code goes here": "Twój kod będzie tutaj", "Your code here": "Twój kod tutaj", "Your code using standard library goes here": "Twój kod korzystający ze standardowej biblioteki będzie tutaj", "Your other stuff here": "Twoje inne rzeczy tutaj", "Zapisz user's game here": "Gra użytkownika Zapisz tutaj", "[10], what's that? Skip.": "[10], co to jest? Pomiń.", "[[maybe_unused]] gets rid of compiler warnings about ptr2 being set but not used": "[[maybe_unused]] eliminuje ostrzeżenia kompilatora o ustawieniu ptr2, ale nieużywanym", "\\n can be embedded in double quotes": "\\n można umieścić w podwójnym cudzysłowie", "\\t is a tab character, to help align the text": "\\t jest znakiem tabulacji, aby pomóc wyrównać tekst", "__cplusplus is the intended way to query the language standard code (as defined by the language standards)": "__cplusplus to zamierzony sposób sprawdzania standardowego kodu języka (zgodnie z definicją języka standardy)", "`1` would not really benefit from being named `player1` instead": "„1” tak naprawdę nie zyskałby na nazwie „gracz1” zamiast tego", "a 10x5 array flattened into a single array": "tablica 10x5 spłaszczona w pojedynczą tablicę", "a 2-element array (valid indexes 0 and 1)": "tablica 2-elementowa (ważne indeksy 0 i 1)", "a 3-element array of 5-element arrays of int": "3-elementowa tablica z 5-elementowymi tablicami int", "a 4x4x4 array (an array of 4 arrays of 4 arrays of 4 ints)": "tablica 4x4x4 (tablica 4 tablic po 4 tablice po 4 ints)", "a C-style array of ints (value 0 = empty, 1 = player 1, 2 = player 2)": "tablica int w stylu C (wartość 0 = pusta, 1 = gracz 1, 2 = gracz 2)", "a C-style array with N elements of type T": "tablica w stylu C z N elementami typu T", "a C-style string literal can't be converted to an int, so the following is an invalid conversion": "literał ciągu w stylu C nie może zostać przekonwertowany na liczbę typu int, więc poniżej znajduje się niepoprawna konwersja", "a CopyClass object where its m_throw is 'true'": "obiekt CopyClass, w którym znajduje się jego m_throw 'true'", "a XOR b XOR c, assuming a, b, and c are bool": "a XOR b XOR c, zakładając, że a, b i c są bool", "a XOR b XOR c, for any type that can be converted to bool": "a XOR b XOR c, dla dowolnego typu, który można przekonwertować na bool", "a XOR b, assuming a and b are bool": "a XOR b, zakładając, że a i b są bool", "a and b are usable only within main()": "a i b można używać tylko w main()", "a const pointer to a const value": "a const wskaźnik do const wartość", "a count of the number of chars in a piece of text, including whitespace and punctuation": "liczba znaków w fragmencie tekstu, łącznie ze spacjami i znakami interpunkcyjnymi", "a declaration for our function template (we don't need the definition any more)": "deklaracja naszego szablonu funkcji (nie potrzebujemy już definicji)", "a defined as char a { 'q' };": "a zdefiniowana jako char a { 'q' };", "a dummy class that can't be instantiated": "fikcyjna klasa, której nie można utworzyć instancji", "a has type const double (constexpr not part of type, const is implicit)": "a ma typ const double (constexpr nie jest częścią typu, const jest niejawna)", "a is an int": "a jest int", "a is created, initialized, and enters scope here": "a jest tworzone, inicjowane i wchodzi tutaj w zakres", "a is non-const": "a nie jest stałą", "a is really close to 1.0, but has rounding errors": "a jest naprawdę bliskie 1,0, ale zawiera błędy zaokrągleń", "a is usable in constant expressions": "a można używać w wyrażeniach stałych", "a lambda with an omitted return type, no captures, and omitted parameters.": "a lambda z pominiętym typem zwracanym, bez przechwyceń i pominiętymi parametrami.", "a normal int type (not an reference)": "normalny typ int (nie referencja)", "a normal non-virtual function": "normalna funkcja niewirtualna", "a normal pointer holding the address of element 0": "normalny wskaźnik przechowujący adres elementu 0", "a normal virtual function": "normalna funkcja wirtualna", "a null pointer (we'll discuss these in the next lesson)": "wskaźnik zerowy (omówimy to w następnym lekcja)", "a pair holding a double and an int": "para zawierająca double i int", "a pair holding an int and a double": "para zawierająca int i double", "a pointer initialized with the address of variable x": "wskaźnik zainicjowany adresem zmiennej x", "a pointer to an int value (holds the address of an integer value)": "wskaźnik na wartość int (przechowuje adres wartości całkowitej)", "a pointer to an integer": "wskaźnik na liczbę całkowitą", "a pure virtual function": "czysty wirtualny funkcja", "a reference to an integer (bound to x)": "odniesienie do liczby całkowitej (powiązanej z x)", "a single function template for max": "szablon pojedynczej funkcji dla max", "a static const int can be defined and initialized directly": "stała statyczna int może zostać zdefiniowana i zainicjowana bezpośrednio", "a static inline variable can be defined and initialized directly": "statyczna zmienna inline może zostać zdefiniowana i zainicjowana bezpośrednio", "a std::string_view won't implicitly convert to a std::string, we must be explicit": "std::string_view nie zostanie domyślnie przekonwertowana na std::string, musimy określ wyraźnie", "a std::vector of 5 ints (for comparison)": "std::vector o długości 5 int (dla porównania)", "a third-party library we installed outside our project directory, thus angled brackets used": "bibliotekę innej firmy, którą zainstalowaliśmy poza naszym katalogiem projektu, dlatego użyliśmy nawiasów kątowych", "a vector of reassignable references to Base": "wektor przypisywalnych odwołań do Base", "a[row][col], where row = 2 and col = 3": "a[row][col], gdzie wiersz = 2 i col = 3", "abbreviated function template": "skrócona funkcja szablon", "about how it's implemented.": "o tym, jak to jest zaimplementowane.", "absEpsilon is an absolute value": "absEpsilon to wartość bezwzględna", "access the s suffix": "dostęp do sufiksu s", "access the sv suffix": "dostęp do sufiksu sv", "accidental null statement here": "tutaj przypadkowe polecenie zerowe", "active now refers to Foo::Goo": "aktywne teraz odnosi się do Foo::Goo", "active now refers to V2": "aktywne teraz odnosi się do V2", "actual definition for getSquareSides": "aktualna definicja getSquareSides", "actual output done here": "rzeczywiste wyjście wykonane tutaj", "actually initializes the members": "faktycznie inicjuje elementy", "add 4 to existing value of x": "dodaj 4 do istniejącej wartości x", "add 5 to the accumulator": "dodaj 5 do akumulatora", "add Cents + Cents using a friend function": "dodaj centy + centy za pomocą przyjaciela funkcja", "add Cents + int using a friend function": "dodaj Centy + int za pomocą funkcji zaprzyjaźnionej", "add a Base object to our vector": "dodaj obiekt Base do naszego wektora", "add a Derived object to our vector": "dodaj obiekt Derived do naszego wektora", "add future enumerators here": "dodaj tutaj przyszłe moduły wyliczające", "add int + Cents using a friend function": "dodaj int + Centy za pomocą funkcji znajomego", "add the value of element with index `index`": "dodaj wartość elementu z indeksem `indeks`", "add's x and y are created and enter scope here": "zostaną utworzone x i y dodatku i wprowadź tutaj zakres", "add's x and y are visible/usable within this function only": "x i y dodatku są widoczne/używane tylko w tej funkcji", "add's y and x go out of scope and are destroyed here": "y i x dodatku dodają poza zakresem i są tutaj niszczone", "add() returns an int, so sum's type will be deduced as an int": "add() zwraca wartość int, więc typ sumy zostanie wydedukowany jako int", "add() takes two integers as parameters, and returns the result of their sum": "add() przyjmuje dwie liczby całkowite jako parametry i zwraca wynik ich sumy", "added parenthesis here": "dodano tutaj nawias", "added this additional line of debugging": "dodano tę dodatkową linię debugowania", "added this reasonable access function": "dodano tę rozsądną funkcję dostępu", "adjust the decimal so it's in bounds,": "dostosuj przecinek tak, aby mieścił się w granicach,", "age is signed, and name.length() is unsigned -- we shouldn't mix these": "wiek jest podpisany, a name.length() jest bez znaku -- nie powinniśmy ich mieszać", "age needs to be an integer, not a string, so we can do math with it": "wiek musi być liczbą całkowitą, a nie łańcuchem, abyśmy mogli z nim wykonywać obliczenia", "alias ugly function pointer type": "alias brzydki typ wskaźnika funkcji", "all flags/options turned off to start": "wszystkie flagi/opcje wyłączone na początek", "all names from std namespace now accessible without qualification": "wszystkie nazwy ze standardowej przestrzeni nazw są teraz dostępne bez kwalifikacja", "allocate 30 integer variables (each with a different name)": "przydziel 30 zmiennych całkowitych (każda z inną nazwą)", "allocate 5 integer variables (each with a different name)": "przydziel 5 zmiennych całkowitych (każda z inną nazwą)", "allocate a Resource object and have it owned by std::shared_ptr": "przydziel obiekt zasobu i przekaż go std::shared_ptr", "allocate a Resource object and have it owned by std::unique_ptr": "przydziel obiekt zasobu i przekaż go w posiadaniu std::unique_ptr", "allocate a new array of the appropriate length": "przydziel nową tablicę o odpowiedniej długości", "allocate an array of 10 int pointers": "przydziel tablicę 10 wskaźników int", "allocate an array of 10 int pointers — these are our rows": "przydziel tablicę 10 wskaźników int — to są nasze wiersze", "allocate memory for our copy": "przydziel pamięć dla naszej kopii", "allocate room for 1000 elements": "przydziel miejsce na 1000 elementy", "allocated an array of objects of type T": "przydzielono tablicę obiektów typu T", "allow IntArray to be initialized via list initialization": "pozwalają na inicjalizację IntArray poprzez inicjalizację listy", "allowed: can access protected base members from derived class": "dozwolony: może uzyskać dostęp do chronionych elementów podstawowych z klasy pochodnej", "allowed: can access public base members from derived class": "dozwolony: może uzyskać dostęp do publicznych elementów bazy z klasy pochodnej", "allowed: can access public members from outside class": "dozwolony: może uzyskać dostęp do elementów publicznych z zewnątrz klasy", "allowed: the value is still non-const when accessed through non-const identifier x": "dozwolony: wartość jest nadal non-const przy dostępie poprzez niestały identyfikator x", "allowing us to work with these types using signed indices": "pozwala nam pracować z tymi typami przy użyciu indeksów ze znakiem", "allows use of std::string": "pozwala na użycie std::string", "almost identical function to calculate the greater of two double values": "prawie identycznej funkcji do obliczenia większej z dwóch wartości double", "also okay, accessing enumerator from scope of Color": "również w porządku, dostęp do modułu wyliczającego z zakresu Color", "always calls print(int) because 0 is an integer literal (hopefully this is what we expected)": "zawsze wywołuje print(int), ponieważ 0 jest literał całkowity (miejmy nadzieję, że tego się spodziewaliśmy)", "always calls print(int*)": "zawsze wywołuje print(int*)", "always calls print(int*) because ptr has type int* (good)": "zawsze wywołuje print(int*), ponieważ ptr ma typ int* (dobrze)", "always true, so the following code will be compiled": "zawsze prawdziwy, więc poniższy kod zostanie skompilowany", "ambiguous function call": "niejednoznaczne wywołanie funkcji", "ambiguous match with foo(int) and foo(const int&)": "niejednoznaczne dopasowanie z foo(int) i foo(const int&)", "ambiguous match with int N = 5 and char N = 5": "niejednoznaczne dopasowanie z int N = 5 i char N = 5", "ambiguous match with int N = 99 and char N = 'c'": "niejednoznaczne dopasowanie z int N = 99 i char N = 'c'", "an array of 30 ints, indices 0 through 29": "tablica 30 intów, indeksy od 0 do 29", "an array of 5 int values, length of 5 is known at compile-time": "tablica 5 wartości int, długość 5 jest znana pod adresem czas kompilacji", "an array of 6 const char, indices 0 through 5": "tablica 6 znaków const, indeksy od 0 do 5", "an array of 7 char, indices 0 through 6": "tablica 7 znaków, indeksy od 0 do 6", "an array of 8 char, indices 0 through 7": "tablica 8 znaków, indeksy od 0 do 7", "an array of const int": "tablica const int", "an array of constexpr int": "tablica constexpr int", "an array of int values": "tablica wartości typu int", "an lvalue reference bound to var": "odniesienie do wartości powiązanej z var", "an lvalue reference to a const int object": "odniesienie do wartości stałej do obiektu int", "an lvalue reference to a double object": "odniesienie do wartości typu int", "an lvalue reference to an int object": "odniesienie do wartości typu int", "an lvalue reference to an int value": "odniesienie do wartości typu int", "an uninitialized pointer (holds a garbage address)": "an niezainicjowany wskaźnik (zawiera adres śmieciowy)", "and added \"m_\" prefixes to each of the member names": "i dodałem przedrostki „m_” do każdej nazwy elementu", "and added this line, which is called an access specifier": "i dodałem tę linię, która nazywa się specyfikatorem dostępu", "and adjust base to account for the number of units removed from the decimal": "i dostosowuję bazę tak, aby uwzględnić liczbę jednostek usuniętych z ułamka dziesiętnego", "and all this content gets included": "a cała zawartość zostanie uwzględniona", "and assigned": "oraz przypisany", "and call the function with the std::string": "i wywołaj funkcję za pomocą std::string", "and check it before we use the result": "i sprawdź to zanim użyjemy wyniku", "and find they are equal!": "i stwierdzimy, że są równe!", "and got a raise": "i dostałem podbicie", "and here": "i tutaj", "and it's always shown at the bottom of the window": "i jest to zawsze wyświetlane na dole okna", "and iterate to the next element": "i iteruj do następnego element", "and only then can we use that value": "i dopiero wtedy możemy użyć tej wartości", "and remove the bad input": "i usunąć błędne wejście", "and return a reference to it": "i zwrócić do niego odniesienie", "and so on": "i tak dalej", "and the lesser of the two numbers otherwise": "i mniejszą z dwóch liczb w przeciwnym razie", "and the patient will also add this doctor": "a pacjent również doda tego lekarza", "and then divide by the number of scores to assign a percentage, which is": "a następnie podzieli przez liczbę punktów, aby przypisać procent, czyli", "and then modify their values": "a następnie zmodyfikuj ich wartości", "and then we return to the caller": "a następnie wracamy do wywołującego", "and this line always gets executed!": "a ta linia zawsze zostanie wykonana!", "and this too": "i to też", "and try again": "i spróbuj ponownie", "and uncomment this line": "i odkomentuj tę linię", "and use pointer arithmetic to move str to the next character": "i użyj arytmetyki wskaźników, aby przenieść str do następnej znak", "and used here": "i użyty tutaj", "and we can continue to use arr2": "i możemy nadal używać arr2", "and we can use it here": "i możemy go tutaj wykorzystać", "and we need to modify this": "i musimy to zmodyfikować", "and we need y to exist here": "i potrzebujemy, żebyś tu istniał", "and/or if we want the return type to be different than the argument types": "i/lub jeśli chcemy, aby typ zwracany był inny niż typy argumentów", "animal is not a reference, because we're looping over pointers": "zwierzę nie jest referencją, ponieważ zapętlamy wskaźniki", "any other even number is not prime": "każda inna liczba parzysta nie jest liczbą pierwszą", "append substring of sTemp starting at index 3 of length 5": "dołącz podciąg sTemp zaczynając od indeksu 3 o długości 5", "apples and x are int, so this is integer division": "jabłka i x to int, więc jest to dzielenie liczb całkowitych", "apples now refers to the nested block apples": "jabłka odnosi się teraz do zagnieżdżonych jabłek blokowych", "apples refers to outer block apples here": "jabłka odnosi się tutaj do jabłek z zewnętrznego bloku", "ar is destroyed here, so the ~IntArray() destructor function is called here": "ar jest tutaj niszczony, więc wywoływana jest tutaj funkcja destruktora ~IntArray().", "are going to copy elements from the existing array to the new array.": "zamierzamy skopiować elementy z istniejącej tablicy do nowej tablicy.", "arr + std::size(arr) is our end-expr": "arr + std::size(arr) to nasze wyrażenie końcowe", "arr can be a reference or non-reference type": "arr może być typem referencyjnym lub niereferencyjnym", "arr decays into a pointer": "arr rozpada się na wskaźnik", "arr decays into a pointer to element 0": "arr rozpada się na wskaźnik do elementu 0", "arr is our begin-expr": "arr jest naszym wyrażeniem początkowym", "arr is some non-reference type": "arr jest typem niereferencyjnym", "arr[2] and arr[3] are value initialized": "arr[2] i arr[3] są inicjowanymi wartościami", "array is the array to search over.": "array to tablica, którą należy przeszukać.", "array to the new array.  We want to copy as many elements as there are": "array do nowej tablicy. Chcemy skopiować tyle elementów, ile jest", "arrays do insertion too slowly.": "tablice wstawiają się zbyt wolno.", "ask compiler can figure out what the relevant return type is": "Ask kompilator może dowiedzieć się, jaki jest odpowiedni typ zwrotu", "ask for an integer's worth of memory": "zapytaj o wartość pamięci w postaci liczby całkowitej", "ask user for a number": "poproś użytkownika o numer", "ask user to enter a bunch of names": "poproś użytkownika o wprowadzenie kilku nazw", "assign a substring of source from index 2 of length 4": "przypisz podciąg źródła z indeksu 2 o długości 4", "assign binary 0000 0000 0000 0001 to the variable": "przypisz do zmiennej wartość binarną 0000 0000 0000 0001", "assign binary 0000 0000 0000 0010 to the variable": "przypisz do zmiennej wartość binarną 0000 0000 0000 0010", "assign binary 0000 0000 0000 0011 to the variable": "przypisz do zmiennej wartość binarną 0000 0000 0000 0011", "assign binary 0000 0000 0000 0100 to the variable": "przypisz do zmiennej wartość binarną 0000 0000 0000 0100", "assign binary 0000 0000 0000 1000 to the variable": "przypisz wartość binarną 0000 0000 0000 1000 do zmiennej", "assign binary 0000 0000 0000 1010 to the variable": "przypisz wartość binarną 0000 0000 0000 1010 do zmiennej", "assign binary 0000 0000 0001 0000 to the variable": "przypisz do zmiennej wartość binarną 0000 0000 0001 0000", "assign binary 0000 0000 0010 0000 to the variable": "przypisz do zmiennej wartość binarną 0000 0000 0010 0000", "assign binary 0000 0000 0100 0000 to the variable": "przypisz do zmiennej wartość binarną 0000 0000 0100 0000", "assign binary 0000 0000 1000 0000 to the variable": "przypisz do zmiennej wartość binarną 0000 0000 1000 0000", "assign binary 0000 0000 1011 0011 to the variable": "przypisz do zmiennej wartość binarną 0000 0000 1011 0011", "assign binary 0000 0000 1111 0000 to the variable": "przypisz do zmiennej wartość binarną 0000 0000 1111 0000", "assign binary 0000 0000 1111 1111 to the variable": "przypisz do zmiennej wartość binarną 0000 0000 1111 1111", "assign binary 1111 0111 0111 0000 to the variable": "przypisz do zmiennej wartość binarną 1111 0111 0111 0000", "assign foo the value 5 (probably uses 32 bits of storage)": "przypisz foo wartość 5 (prawdopodobnie używa 32 bitów pamięci)", "assign it to the start of the list": "przypisz go na początek listy", "assign it to the start of the set": "przypisz go do początku zestawu", "assign it to the start of the vector": "przypisz go do początku wektora", "assign ptr to address of v2": "przypisz ptr do adresu v2", "assign the greater of x or y to max": "przypisz większe z x lub y do max", "assign the pointer to an object that will be destroyed (not possible with a reference)": "przypisz wskaźnik do obiektu, który zostanie zniszczony (nie jest to możliwe w przypadku referencji)", "assign value of 7 to allocated memory": "przypisz wartość 7 do przydzielonej pamięci", "assignment of value 5 into variable width": "przypisanie wartości 5 do zmiennej szerokości", "assignment to individual elements is fine": "przypisanie do poszczególnych elementów jest w porządku", "assigns 6 (the value of y) to x (the object being referenced by ref)": "przypisuje 6 (wartość y) do x (obiekt, do którego odwołuje się ref)", "assume array is length 3 for simplicity": "dla uproszczenia załóżmy, że tablica ma długość 3", "assume int is 4 bytes": "załóżmy, że int ma 4 bajty", "assume iofile is an object of type fstream": "załóżmy, że iofile jest obiektem typu fstream", "assume ptr has previously been allocated with operator new": "załóżmy, że ptr został wcześniej przydzielony z operatorem new", "assume the user enters \"a b\" (without quotes)": "załóżmy, że użytkownik wpisze „a b” (bez cudzysłowów)", "assume the user enters \"abcd\" (without quotes)": "załóżmy, że użytkownik wpisze „abcd” (bez cudzysłowów)", "assume this is assigned memory address 140": "załóżmy, że przypisano mu adres pamięci 140", "assume this throws an int exception on failure": "załóżmy, że zgłasza to wyjątek int w przypadku niepowodzenia", "assumes m_data is initialized": "zakłada, że ​​zainicjowano m_data", "assumes radiuses are >= 0": "zakłada, że ​​promienie wynoszą >= 0", "at the very bottom of the console": "na samym dole konsoli", "attached to inner if statement": "dołączony do wewnętrznej instrukcji if", "attached to outer if statement": "dołączony do zewnętrznej instrukcji if", "auto allowed for static members": "auto dozwolone dla statycznych członków", "auto not allowed for non-static members": "auto niedozwolone dla członków niestatycznych", "b and a go out of scope and are destroyed here": "b i a wychodzą poza zakres i zostają tutaj zniszczone", "b and d can't be anonymous objects": "b i d nie mogą być obiektami anonimowymi", "b deduced as an int": "b wywnioskowane jako int", "b has type const int (const dropped but reapplied)": "b ma typ const int (const został usunięty, ale zastosowany ponownie)", "b is a compile-time constant": "b jest stałą czasową kompilacji", "b is a const int": "b jest stałą int", "b is created, initialized, and enters scope here": "b jest tworzony, inicjowany i wchodzi tutaj w zakres", "b is false, which evaluates to 0": "b ma wartość false, co daje wartość 0", "b is not a constant expression within foo()": "b nie jest wyrażeniem stałym w foo()", "b is not constexpr, and cannot be used in constant expressions": "b nie jest constexpr i nie można go używać w wyrażeniach stałych", "b is usable in constant expressions (a is a constant expression per the prior statement)": "b można używać w wyrażeniach stałych (a jest wyrażeniem stałym zgodnie z poprzednią instrukcją)", "b1 will be initialized with the value false": "b1 zostanie zainicjowane wartością false", "b2 will be initialized with the value true": "b2 będzie zainicjowane wartością true", "b4 is 0100": "b4 wynosi 0100", "b8 is 0000 0100": "b8 wynosi 0000 0100", "b[2] and b[3] are value initialized": "b[2] i b[3] są wartościami zainicjowanymi", "back to decimal": "z powrotem do wartości dziesiętnych", "back() returns the last element": "back() zwraca ostatni element", "bad: app name may be used in other places or change in the future": "zły: nazwa aplikacji może zostać użyta w innym miejscu lub zmienić future", "bad: expensive conversion from std::string_view to std::string (assuming you didn't want this)": "bad: kosztowna konwersja ze std::string_view na std::string (zakładając, że tego nie chciałeś)", "bad: expensive creation of std::string temporary": "zły: drogie utworzenie tymczasowego std::string", "bad: implicit narrowing conversion will generate compiler warning": "bad: niejawna konwersja zawężająca wygeneruje ostrzeżenie kompilatora", "bad: will result in large integer outside range of signed int": "bad: spowoduje wygenerowanie dużej liczby całkowitej poza zakresem podpisanego int", "banana is considered part of Fruit's scope region": "banana jest uważany za część obszaru zasięgu Fruit", "base case (termination condition) when user passed in an unexpected argument (0 or negative)": "przypadek bazowy (warunek zakończenia), gdy użytkownik przekazał nieoczekiwany argument (0 lub ujemny)", "be left pointing at deallocated memory!": "pozostaje wskazując na zwolnioną pamięć!", "because console window scrolls automatically when there is no": "ponieważ okno konsoli przewija się automatycznie, gdy nie ma", "because m_length is not a pointer, we can shallow copy it": "ponieważ m_length nie jest wskaźnikiem, możemy go płytkie skopiować", "because ofstream defaults to std::ios::out": "ponieważ domyślnie ofstream to std::ios::out", "because the call to getValue(x) cannot be resolved at compile-time": "ponieważ wywołanie getValue(x) nie może zostać rozwiązane w czasie kompilacji", "because they're mentioned here": "ponieważ są tutaj wspomniane", "because this function has a body, it is an implementation of function add()": "ponieważ ta funkcja ma treść, jest to implementacja funkcji add()", "because we want the compiler to warn us if we add a new potion but": "ponieważ chcemy, aby kompilator ostrzegał nas, jeśli dodamy nową miksturę, ale", "because we're initializing an r-value reference with a literal, a temporary with value 5 is created here": "ponieważ inicjujemy odwołanie do wartości r za pomocą literału, tworzony jest tutaj element tymczasowy o wartości 5", "before the currently \"smallest\" element.": "przed obecnie „najmniejszym” elementem.", "begin points to start element": "punkty początkowe do elementu początkowego", "bestIndex is the index of the smallest/largest element we've encountered so far.": "bestIndex to indeks najmniejszego/największego elementu, jaki napotkaliśmy do tej pory.", "between 3 and sqrt(x) to see if they are a divisor": "między 3 a sqrt(x), aby sprawdzić, czy są one dzielnik", "between double quotes in existing text (conventional)": "pomiędzy podwójnymi cudzysłowami w istniejącym tekście (konwencjonalny)", "between our sort function and std::sort.)": "pomiędzy naszą funkcją sortującą a std::sort.)", "binarySearch() should return the index of the target element if the target is found, -1 otherwise": "binarySearch() powinna zwrócić indeks elementu docelowego, jeśli cel zostanie znaleziony, -1 w przeciwnym razie", "binds to dangling reference": "wiąże się z wiszącą referencją", "bits << 1 does the left shift": "bity << 1 robi w lewo shift", "bits >> 3 handle the rotation of the leftmost bit": "bity >> 3 obsługują obrót skrajnego lewego bitu", "bitwise-and the inverse mask to turn that bit off": "bitowo-oraz maska odwrotna do wyłączenia tego bitu", "bitwise-and to get the value of the bit we're interested in": "bitowo-i aby uzyskać wartość interesującego nas bitu", "block needed here so both statements execute if num is < 0": "potrzebny tutaj blok, aby obie instrukcje zostały wykonane, jeśli liczba wynosi <0", "blue is put into the global namespace": "niebieski jest umieszczany w globalnym przestrzeń nazw", "bob still exists here, but the department doesn't": "bob nadal tu istnieje, ale dział nie", "bool found{ isValueInArray(names, static_cast<std::string_view>(username)) };": "znalazł wartości boolowej{ isValueInArray(names, static_cast<std::string_view>(username)) };", "both negative, no decimal overflow": "obie wartości ujemne, brak przepełnienia dziesiętnego", "both negative, with decimal overflow": "oba ujemne, z przepełnieniem dziesiętnym", "both positive, no decimal overflow": "oba dodatni, bez przepełnienia dziesiętnego", "both positive, with decimal overflow": "oba dodatnie, z przekroczeniem dziesiętnym", "bounce the user back to the caller": "odbijanie użytkownika z powrotem do osoby wywołującej", "brace-initialization disallows conversions that result in data loss": "inicjowanie nawiasów klamrowych uniemożliwia konwersje skutkujące utratą danych", "braces used to delineate nested scope region for function foo()": "nawiasy klamrowe używane do wyznaczania zagnieżdżonego obszaru zasięgu dla funkcji foo()", "braces used to delineate nested scope region for function main()": "nawiasy klamrowe używane do wyznaczania zagnieżdżonego obszaru zasięgu dla funkcji main()", "breaking the loop causes execution to resume here": "przerwanie pętli powoduje wznowienie wykonywania w tym miejscu", "but it doesn't due to the wrong operator being used": "ale tak nie jest z powodu użycia niewłaściwego operatora", "but it is the easiest way to show that the function parameter can be a non-integer": "ale jest to najłatwiejszy sposób pokazania, że parametr funkcji może być liczbą niecałkowitą", "but not mentioning it here": "ale nie wspominając o tym tutaj", "but not used anywhere": "ale nie jest nigdzie używany", "but this makes the view non-copy-assignable since references can't be reseated.": "ale to sprawia, że widok nie można przypisać do kopiowania, ponieważ nie można ponownie umieścić referencji.", "but we still want derived classes to be able to use it.": "ale nadal chcemy, aby klasy pochodne mogły z niego korzystać.", "c defined as const double c { 5.0 };": "c zdefiniowane jako const double c { 5.0 };", "c has type const double (const dropped but reapplied)": "c ma typ const double (const usunięty, ale zastosowany ponownie)", "c is a constexpr int": "c jest constexpr int", "c is not constexpr, and cannot be used in constant expressions": "c jest nie constexpr i nie można go używać w wyrażeniach stałych", "c is usable in constant expressions (operator+ has constant expression operands)": "c można używać w wyrażeniach stałych (operator+ ma stałe operandy wyrażeń)", "calculate the average": "obliczyć średnią", "call Person(std::string_view, int) to initialize these fields": "wywołaj Person(std::string_view, int), aby zainicjować te pola", "call function foo(5) through fcnPtr.": "wywołaj funkcję foo(5) poprzez fcnPtr.", "call has_value() to check if o1 has a value": "wywołaj funkcję has_value(), aby sprawdzić, czy o1 ma wartość", "call our custom greater function": "wywołaj naszą niestandardową większą funkcję", "call print() in Foo namespace": "wywołaj funkcję print() w przestrzeni nazw Foo", "call print() in global namespace (same as just calling print() in this case)": "wywołaj print() w globalnej przestrzeni nazw (w tym przypadku to samo, co wywołanie print())", "call print(int) (Visual Studio does this)": "wywołaj print(int) (Visual Studio to robi)", "call print(int*)": "wywołaj print(int*)", "call the function just like normal": "wywołaj funkcję tak jak zwykle", "call the print() non-member function": "wywołaj funkcję niebędącą członkiem print().", "call the print(int) function through the function pointer": "wywołaj funkcję print(int) poprzez wskaźnik funkcji", "call the target function directly using early binding": "wywołaj funkcję docelową bezpośrednio, korzystając z wczesnego wiązania", "call to function defined in another file, linker will connect this call to the function definition": "wywołanie funkcji zdefiniowanej w innym pliku, linker połączy to wywołanie z definicją funkcji", "call to max<double> using template argument deduction (prefer this)": "wywołaj max<double> używając odliczenia argumentów szablonu (preferuj to)", "call to non-constexpr function here": "wywołaj tutaj funkcję inną niż constexpr", "call value() to get value stored in o2 (throws std::bad_optional_access exception if o2 does not have a value)": "wywołaj wartość(), aby uzyskać wartość zapisaną w o2 (zgłasza wyjątek std::bad_opcjonalny_access, jeśli o2 nie ma wartości)", "call value_or() to get value stored in o3 (or value `42` if o3 doesn't have a value)": "wywołaj wartość_lub(), aby uzyskać wartość zapisaną w o3 (lub wartość „42”, jeśli o3 nie ma wartości)", "call void(int) version of print with argument 1": "wywołaj void(int) wersję print z argumentem 1", "call with C-style string literal": "wywołaj z literałem ciągu w stylu C", "call with std::string": "wywołaj za pomocą std::string", "call with std::string_view": "zadzwoń za pomocą std::string_view", "callable with both lvalue and rvalue implicit objects": "wywoływalne zarówno z ukrytymi obiektami lvalue, jak i rvalue", "called by A()": "wywołany przez A()", "called by B()": "wywołany przez B()", "called by C()": "wywoływane przez C()", "called by main()": "wywoływane przez main()", "calls ::get(long)": "połączenia ::get(long)", "calls ::print()": "dzwoni ::print()", "calls Base::print(int)": "wywołuje Base::print(int)", "calls Base::print(int), which is the best matching function visible in Derived": "wywołuje Base::print(int), która jest najlepiej pasującą funkcją widoczną w Derived", "calls Date::print()": "dzwoni Data::print()", "calls Date::print(std::string_view)": "wywołania Data::print(std::string_view)", "calls Derived::print(double), not Base::print(int)": "wywołuje Derived::print(double), a nie Base::print(int)", "calls Derived::print(int), which calls Base::print(int)": "wywołuje Derived::print(int), który wywołuje Base::print(int)", "calls Foo(int, int) constructor using default arguments": "wywołuje konstruktor Foo(int, int) przy użyciu domyślnych argumentów", "calls Something() and copy constructor": "wywołuje Something() i konstruktor kopiujący", "calls Storage<double*>::print()": "wywołuje Storage<double**>::print()", "calls Storage<double>::print (called from explicit specialization of Storage<double>)": "wywołuje Storage<double>::print (wywoływany z jawnej specjalizacji Storage<double>)", "calls Storage<double>::print (called from explicit specialization of Storage<double>::print())": "wywołuje Storage<double>::print (wywoływany z jawnej specjalizacji Storage<double>::print())", "calls Storage<int>::print (instantiated from Storage<T>)": "wywołuje Storage<int>::print (utworzone z Storage<T>)", "calls add(5, 6), where x=5 and y=6": "wywołuje add(5, 6), gdzie x=5 i y=6", "calls already instantiated function max<int>(int, int)": "wywołuje już utworzoną funkcję max<int>(int, int)", "calls copy constructor": "wywołuje konstruktor kopiujący", "calls derived::print(), which is public": "wywołania pochodne::print(), które są publiczne", "calls function add() with x=5 and y=6": "wywołuje funkcję add() z x=5 i y=6", "calls l-value version of push_back, which copies str into the array element": "wywołuje wersję push_back o wartości l, która kopiuje str do elementu tablicy", "calls print()": "wywołuje drukowanie()", "calls print() const": "wywołuje print() const", "calls print() in Foo namespace": "wywołuje print() w przestrzeni nazw Foo", "calls print() in global namespace": "wywołuje print() w globalnej przestrzeni nazw", "calls print(bool) -- prints true": "wywołuje print(bool) -- wypisuje wartość true", "calls print(int*)": "wywołuje print(int*)", "calls print(int*) (since ptr has type int*)": "wywołuje print(int*) (ponieważ ptr ma typ int*)", "calls print(std::nullptr_t)": "wywołuje print(std::nullptr_t)", "calls print<'c'>": "wywołuje print<'c'>", "calls print<5>": "wywołuje drukowanie<5>", "calls print<bool>(bool) -- prints 1": "wywołuje print<bool>(bool) -- drukuje 1", "calls r-value version of push_back, which moves str into the array element": "wywołuje wersję push_back z wartością r, która przenosi str do elementu tablicy", "calls the V1 version of doSomething()": "wywołuje wersję V1 metody doSomething()", "calls the V2 version of doSomething()": "wywołuje wersję V2 metody doSomething()", "calls the inline version of doSomething() (which is V1)": "wywołuje wbudowaną wersję doSomething() (czyli V1)", "calls the inline version of doSomething() (which is V2)": "wywołuje wbudowaną wersję doSomething() (która jest wersją 2)", "calls the inline version of doSomething() (which is the anonymous one)": "wywołuje wbudowaną wersję doSomething() (która jest anonimowa)", "calls to Foo:: stuff here": "dzwoni do Foo:: rzeczy tutaj", "calls to Goo:: stuff here": "dzwoni do Goo:: rzeczy tutaj", "calls to this function will halt compilation": "wywołania tej funkcji zatrzymają kompilację", "can also use CTAD to infer template arguments": "można również użyć CTAD do wywnioskowania argumentów szablonu", "can be accessed by Base members, friends, and derived classes": "Dostęp do nich mogą uzyskać członkowie Base, przyjaciele i klasy pochodne", "can be accessed by anybody": "może uzyskać dostęp każdy", "can evaluate at either compile-time or runtime": "można ocenić w czasie kompilacji lub w czasie wykonywania", "can handle self-assignment": "potrafi poradzić sobie z samodzielnym przydziałem", "can make this easier to read": "może ułatwić czytanie", "can modify i": "mogę modyfikować I", "can modify i (not obvious)": "można modyfikować i (nie oczywiste)", "can only be accessed by Base members and friends (but not derived classes)": "dostępne są tylko dla członków Bazy i przyjaciół (ale nie klas pochodnych)", "can only be accessed by Base members and friends (not derived classes)": "dostępne są tylko dla członków Bazy i przyjaciół (nie klas pochodnych)", "can only be accessed in this file": "dostępne są tylko w tym pliku", "can only execute at runtime": "można wykonać tylko w czasie wykonywania", "can pass entire struct to function": "można przekazać całą strukturę do funkcji", "can this function throw an exception or not?": "czy to funkcja zgłasza wyjątek czy nie?", "can use nullptr to initialize a pointer to be a null pointer": "może użyć nullptr do zainicjowania wskaźnika jako wskaźnik zerowy", "can use temporary return value in expression": "może użyć tymczasowej wartości zwracanej w wyrażeniu", "can use to initialize object": "może użyć do inicjalizacji obiektu", "can use unqualified name within class": "może użyć niekwalifikowanej nazwy w klasie", "can't modify i": "nie może modyfikować i", "can't static_assert on length": "nie może static_assert on długość", "carr will decay to type char*": "carr przejdzie do typu char*", "case 1: always evaluated at compile-time": "przypadek 1: zawsze oceniany w czasie kompilacji", "case 1: call addAndPrint with int parameters": "przypadek 1: wywołanie addAndPrint z parametrami int", "case 1: const C-style string initialized with C-style string literal": "przypadek 1: const Łańcuch w stylu C zainicjowany literałem ciągu w stylu C", "case 2: call addAndPrint with double parameters": "przypadek 2: wywołanie addAndPrint z double parametry", "case 2: const pointer to C-style string literal": "przypadek 2: stały wskaźnik na literał łańcuchowy w stylu C", "case 2: may be evaluated at either runtime or compile-time": "przypadek 2: może być oceniany w czasie wykonywania lub kompilacji", "case 3: likely evaluated at runtime": "przypadek 3: prawdopodobnie oceniany w czasie wykonywania", "case 4: always evaluated at runtime": "przypadek 4: zawsze oceniany w czasie wykonywania", "cast to char pointer (no indirection)": "rzut na wskaźnik char (bez pośredniości)", "cast to float pointer and perform indirection": "rzut na float wskaźnik i wykonaj pośredniość", "cast to int pointer and perform indirection": "rzutuj na int wskaźnik i wykonaj pośrednictwo", "catch classes by const reference": "złap klasy przez odwołanie do const", "catch exceptions of type const char*": "złap wyjątki typu const char*", "cause divide by zero error": "powoduj błąd dzielenia przez zero", "cents will be implicitly cast to an int here": "centy zostaną tutaj niejawnie rzutowane na int", "ch = 'a', \"bcd\" is left queued.": "ch = 'a', \"bcd\" pozostaje w kolejce.", "ch = 'b', \"cd\" is left queued.": "ch = 'b', \"cd\" pozostaje w kolejce.", "change employee's name to \"Mark\"": "zmień nazwisko pracownika na \"Mark\"", "change name to \"John\"": "zmień nazwisko na \"John\"", "change name to a longer string": "zmień imię na dłuższe", "change name to a shorter string": "zmień imię na krótsze", "change the value to 6": "zmień wartość na 6", "change value in a, b should not change": "zmień wartość w a, b nie powinna zmieniać", "change value of x to 5 using assignment operator": "zmienić wartość x na 5 za pomocą operatora przypisania", "change value stored in variable width to 7": "zmienić wartość przechowywaną w zmiennej szerokość na 7", "change variable to type double so it matches the literal type double": "zmienić zmienną na typ double tak, aby odpowiadała typowi dosłownemu double", "changed type to T": "zmieniono typ na T", "char does not match int or double, so what happens?": "char nie pasuje do int ani double, więc co się dzieje?", "char non-type template parameter": "char nietyp parametr szablonu", "characters have to be an exact match.": "znaki muszą być dokładnie zgodne.", "charge on a proton is 1.6 x 10^-19": "ładunek protonu wynosi 1,6 x 10^-19", "chars are 1 byte": "znaki mają 1 bajt", "chars have range -128 to 127": "znaki mają zakres od -128 do 127", "chars use 1 byte of memory": "znaki zajmują 1 bajt pamięci", "check for self-assignment": "sprawdź samodzielne przypisanie", "checks that index 3 is valid at compile-time": "sprawdza, czy indeks 3 jest ważny w czasie kompilacji", "class invariant: should never be 0": "niezmiennik klasy: nigdy nie powinien wynosić 0", "class members are private by default, can only be accessed by other members": "elementy klasy są domyślnie prywatne, dostęp do nich mogą uzyskać tylko inni członkowie", "clear out any additional input from the stream": "usuń wszelkie dodatkowe dane wejściowe ze strumienia", "clear out any extraneous input": "usuń wszelkie niepotrzebne dane wejściowe", "clear out the bad input from the stream": "usuń nieprawidłowe dane wejściowe ze strumienia", "clear the color and the depth buffer": "wyczyść bufor koloru i głębi", "clear this is a global variable (since namespaces are global)": "wyczyść to zmienna globalna (ponieważ przestrzenie nazw są globalne)", "clear up to 100 characters out of the buffer, or until a '\\n' character is removed": "wyczyść maksymalnie 100 znaków z bufora lub do momentu usunięcia znaku '\\n'", "clearly a constant expression (since initializer is a constant expression)": "wyraźnie wyrażenie stałe (ponieważ inicjator jest wyrażeniem stałym)", "clearly not a constant expression (since initializer is non-const)": "wyraźnie nie wyrażenie stałe (ponieważ inicjator nie jest stały)", "clearly part of the NS library": "wyraźnie część biblioteki NS", "clist[2] = 3; // compile error: clist[2] returns const reference, which we can't assign to": "clist[2] = 3; // błąd kompilacji: clist[2] zwraca odwołanie do stałej, której nie możemy przypisać", "code for foo starts at memory address 0x002717f0": "kod dla foo zaczyna się od adresu pamięci 0x002717f0", "code here to do any kind of cleanup required": "kod tutaj, aby wykonać wymagane czyszczenie", "code point for 'b' (not preferred)": "punkt kodowy dla „b” (niepreferowany)", "code starts at memory address 0x002717f0": "kod zaczyna się od adresu pamięci 0x002717f0", "code using standard library goes here": "tutaj znajduje się kod korzystający ze standardowej biblioteki", "comment here": "skomentuj tutaj", "comment out to disable debugging": "skomentuj, aby wyłączyć debugowanie", "compare \"almost 0.0\" to 0.0": "porównaj „prawie 0,0” z 0,0", "compare \"almost 1.0\" to 1.0": "porównaj „prawie 1,0” z 1,0", "compilation error because Dollars(int) is explicit": "błąd kompilacji, ponieważ Dollars(int) jest jawne", "compilation failure due to name collision with function parameter": "błąd kompilacji z powodu kolizji nazwy z parametrem funkcji", "compile error in C++17 (okay in C++20)": "błąd kompilacji w C++17 (w porządku w C++20)", "compile error, CTAD can't be used here": "błąd kompilacji, nie można tu użyć CTAD", "compile error, CTAD can't be used in this context": "błąd kompilacji, CTAD nie można użyć w tym kontekście", "compile error, function is not an override": "błąd kompilacji, funkcja nie jest przesłonięciem", "compile error, operator= has been deleted": "błąd kompilacji, operator= został usunięty", "compile error: CTAD can't be used to infer function parameters": "błąd kompilacji: nie można użyć CTAD do wnioskowania o parametrach funkcji", "compile error: Derived copy constructor was deleted": "błąd kompilacji: pochodny konstruktor kopiujący został usunięty", "compile error: Foo(int) is explicit": "błąd kompilacji: Foo(int) jest jawny", "compile error: age is not a constant expression": "błąd kompilacji: wiek nie jest wyrażeniem stałym", "compile error: ambiguous constructor function call": "błąd kompilacji: niejednoznaczne wywołanie funkcji konstruktora", "compile error: array assignment not valid": "błąd kompilacji: nieprawidłowe przypisanie tablicy", "compile error: black is not an enumerator of Pet": "błąd kompilacji: czarny nie jest modułem wyliczającym Pet", "compile error: can no longer use aggregate initialization": "błąd kompilacji: nie można już używać inicjalizacji agregowanej", "compile error: can not use aggregate initialization": "błąd kompilacji: nie można użyć inicjalizacji agregacji", "compile error: can't bind to non-static object": "kompiluj błąd: nie można powiązać z obiektem niestatycznym", "compile error: can't call member function that modifies member of const object": "błąd kompilacji: nie można wywołać funkcji członkowskiej, która modyfikuje element składowy obiektu const", "compile error: can't call non-const member function": "błąd kompilacji: nie można wywołać funkcji składowej innej niż stała", "compile error: can't change const int": "błąd kompilacji: nie można zmienić stałego int", "compile error: can't modify member of const object": "błąd kompilacji: nie można zmodyfikować elementu stałego obiekt", "compile error: can't traverse enumeration": "błąd kompilacji: nie można przejść przez wyliczenie", "compile error: can't use type deduction on C-style arrays": "błąd kompilacji: nie można użyć dedukcji typu w tablicach w stylu C", "compile error: cannot assign with integer": "błąd kompilacji: nie można przypisać liczby całkowitej", "compile error: cannot convert from const int* to int*": "błąd kompilacji: nie można przekonwertować ze const int* na int*", "compile error: cannot copy initialize with integer": "błąd kompilacji: nie można skopiować inicjacji za pomocą liczba całkowita", "compile error: cannot define array of references": "błąd kompilacji: nie można zdefiniować tablicy odniesień", "compile error: cannot direct initialize with integer": "błąd kompilacji: nie można bezpośrednio zainicjować liczbą całkowitą", "compile error: cannot implicit convert std::string_view to std::string": "błąd kompilacji: nie można niejawnie przekonwertować std::string_view na std::string", "compile error: cannot inherit from final class": "błąd kompilacji: nie można dziedziczyć z klasy końcowej", "compile error: compiler can't find common type for constexpr int and C-style string literal": "błąd kompilacji: kompilator nie może znajdź wspólny typ dla constexpr int i literał ciągów w stylu C", "compile error: compiler doesn't know what a Storage is": "błąd kompilacji: kompilator nie wie, czym jest pamięć", "compile error: const function can't modify member": "błąd kompilacji: funkcja const nie może modyfikować elementu", "compile error: consteval function call requires constant expression argument": "błąd kompilacji: wywołanie funkcji consteval wymaga argumentu wyrażenia stałego", "compile error: constexpr variable requires constant expression initializer": "błąd kompilacji: zmienna constexpr wymaga wyrażenia stałego inicjator", "compile error: conversion is narrowing due to value change": "błąd kompilacji: konwersja zawęża się z powodu zmiany wartości", "compile error: copy constructor has been deleted": "błąd kompilacji: konstruktor kopiujący został usunięty", "compile error: default argument for y hasn't been defined yet": "błąd kompilacji: domyślny argument dla y nie został jeszcze zdefiniowany", "compile error: direct initialization not allowed for member default initializers": "błąd kompilacji: bezpośrednia inicjalizacja nie jest dozwolona dla domyślnych inicjatorów składowych", "compile error: erroneous redefinition of Pair": "błąd kompilacji: błędna redefinicja Para", "compile error: executable statements are not allowed in namespaces": "błąd kompilacji: instrukcje wykonywalne nie są dozwolone w przestrzeniach nazw", "compile error: foo(5) can't evaluate at compile-time": "błąd kompilacji: foo(5) nie może ocenić w czasie kompilacji", "compile error: function deleted": "błąd kompilacji: funkcja usunięta", "compile error: greater() not constexpr": "błąd kompilacji: większa() nie constexpr", "compile error: integer value 2 won't implicitly convert to a Pet": "błąd kompilacji: wartość całkowita 2 nie będzie domyślnie konwertuj na Pet", "compile error: integer value 3 won't implicitly convert to a Pet": "błąd kompilacji: wartość całkowita 3 nie zostanie domyślnie przekonwertowana na Pet", "compile error: list initialization disallows narrowing conversion": "błąd kompilacji: inicjalizacja listy nie pozwala na zawężającą konwersję", "compile error: list-init does not allow narrowing conversion": "błąd kompilacji: list-init nie pozwala na zawężającą konwersję", "compile error: list-init does not allow narrowing conversion of 4.5 to 4": "błąd kompilacji: list-init nie pozwala na zawężającą konwersję z 4.5 do 4", "compile error: max(5, 6) not a constant expression": "błąd kompilacji: max(5, 6) nie jest wyrażeniem stałym", "compile error: must be initialized by a constant expression": "błąd kompilacji: musi być zainicjowany wyrażeniem stałym", "compile error: no conversion from StudentNames to any type that operator<< can output": "błąd kompilacji: brak konwersji z StudentNames na dowolny typ, który operator<< może wyprowadzić", "compile error: no conversion from StudentNames to std::size_t": "błąd kompilacji: brak konwersji z StudentNames na std::size_t", "compile error: no match found": "kompilacja błąd: nie znaleziono dopasowania", "compile error: no matching constructor": "błąd kompilacji: brak pasującego konstruktora", "compile error: no value provided": "błąd kompilacji: brak podanej wartości", "compile error: not allowed as B::fun() is private": "błąd kompilacji: niedozwolone, ponieważ B::fun() jest prywatny", "compile error: not an lvalue": "błąd kompilacji: nie lwartość", "compile error: not initialized": "błąd kompilacji: nie zainicjowano", "compile error: overloaded function differs only by return type": "błąd kompilacji: funkcja przeciążona różni się tylko typem zwracanym", "compile error: overrides B::getName(), which is final": "błąd kompilacji: zastępuje B::getName(), który jest końcowy", "compile error: p is not a literal type": "błąd kompilacji: p nie jest typem dosłownym", "compile error: p not constexpr": "błąd kompilacji: p nie constexpr", "compile error: pig is not an enumerator of Color": "błąd kompilacji: pig nie jest modułem wyliczającym Color", "compile error: red not defined in this scope region": "błąd kompilacji: czerwony nie zdefiniowany w tym zakresie region", "compile error: redefinition of default argument": "błąd kompilacji: redefinicja domyślnego argumentu", "compile error: return value of five() is not constexpr": "błąd kompilacji: zwracana wartość five() nie jest constexpr", "compile error: static_assert condition failed": "błąd kompilacji: warunek static_assert nie powiódł się", "compile error: std::cin doesn't know how to input a Pet": "błąd kompilacji: std::cin nie wie, jak wprowadzić Pet", "compile error: std::cout doesn't know how to print this (will not implicitly convert to int)": "błąd kompilacji: std::cout nie wie, jak to wydrukować (nie zostanie domyślnie przekonwertowany na int)", "compile error: std::size() won't work on a pointer": "błąd kompilacji: std::size() nie będzie działać na wskaźnik", "compile error: std::vector<double> is not convertible to std::vector<int>": "błąd kompilacji: std::vector<double> nie można konwertować na std::vector<int>", "compile error: the compiler doesn't know how to compare different types Color and Fruit": "błąd kompilacji: kompilator nie wie, jak porównać różne typy Color i Fruit", "compile error: the m_day member is private": "błąd kompilacji: element m_day jest prywatny", "compile error: the print() member function is private": "błąd kompilacji: funkcja elementu print() jest prywatny", "compile error: too many initializers": "błąd kompilacji: zbyt wiele inicjatorów", "compile error: we can't call a function that returns void in this context": "błąd kompilacji: nie możemy wywołać funkcji, która zwraca void w tym kontekście", "compile error: we're trying to return a value": "błąd kompilacji: próbujemy zwrócić wartość", "compile in the catch-all handler": "kompilację w procedurze obsługi catch-all", "compiler replaces this with Pair<int>": "kompilator zastępuje to kompilatorem Pair<int>", "compiler will deduce type of num to be `int`": "wydedukuje typ num jako `int`", "compiler will try to convert { 1, 2 } to temporary object matching expected type (typically a parameter or return type)": "kompilator spróbuje przekonwertować { 1, 2 } na obiekt tymczasowy pasujący do oczekiwanego typu (zazwyczaj parametr lub typ zwracany)", "compiles but produces undefined behavior": "kompiluje, ale daje niezdefiniowane zachowanie", "compiles but strongly discouraged: non-const global variable definition (with initializer)": "kompiluje, ale zdecydowanie odradza: definicja zmiennej globalnej innej niż stała (z inicjatorem)", "compiles but strongly discouraged: non-const global variable definition (without initializer)": "kompiluje, ale zdecydowanie odradza się: definicja zmiennej globalnej niebędącej stałą (bez inicjatora)", "compiles: w2 copy-initialized to value 4": "kompiluje: w2 kopiowanie inicjowane do wartości 4", "compiles: w3 direct-initialized to value 4": "kompiluje: w3 bezpośrednio inicjowane do wartości 4", "condition evaluates to true because ptr is not nullptr": "warunek ma wartość true, ponieważ ptr nie ma wartości nullptr", "conditionally executes now": "wykonuje warunkowo teraz", "connect to server": "połącz z serwer", "const after the asterisk means this is a const pointer": "const po gwiazdce oznacza, że jest to wskaźnik const", "const char* will match a string literal": "const char* będzie pasować do literału ciągu", "const class type object": "const obiekt typu klasy", "const global variable g_y, initialized with a value": "const zmienna globalna g_y, zainicjowana wartością", "const globals can be defined as extern, making them external": "const globale można zdefiniować jako extern, czyniąc je zewnętrznymi", "const globals have internal linkage by default": "const globale mają domyślnie wewnętrzne połączenie", "const object, implicitly invokes (non-const) constructor": "obiekt const, domyślnie wywołuje konstruktor (inny niż const)", "const std::array<const Animal*, 6> animals{ &fred, &garbo, &misty, &pooky, &truffle, &zeke };": "const std::array<const Animal*, 6> zwierzęta{ &fred, &garbo, &misty, &pooky, &truffle, &zeke };", "const std::string (reference dropped, const dropped, const reapplied)": "const std::string (odniesienie zostało usunięte, const usunięte, const ponownie zastosowane)", "const std::string getAnimalName(Animal animal) // C++14": "const std::string getAnimalName(Animal zwierzę) // C++14", "const std::string& (reference dropped and reapplied, low-level const not dropped)": "const std::string& (odniesienie zostało usunięte i ponownie zastosowane, const niskiego poziomu nie zostało usunięte)", "const std::string*": "stała std::string*", "const std::string* const": "stała std::string* stała", "const std::string_view& (reference reapplied, low-level const not dropped)": "const std::string_view& (ponownie zastosowano odwołanie, nie usunięto stałej niskiego poziomu)", "constAbs() can be called like a normal function, but can handle different types of values (e.g. int, double, etc...)": "constAbs() można wywołać jak normalną funkcję, ale może obsługiwać różne typy wartości (np. int, double itp.)", "constant expression (sizeof can be determined at compile-time)": "wyrażenie stałe (sizeof można określić w czasie kompilacji)", "constant expression 3 + 4 may be evaluated at compile-time or runtime": "wyrażenie stałe 3 + 4 mogą być oceniane w czasie kompilacji lub w czasie wykonywania", "constant expression 3 + 4 must be evaluated at compile-time": "wyrażenie stałe 3 + 4 muszą być oceniane w czasie kompilacji", "constant expression, always true": "wyrażenie stałe, zawsze prawdziwe", "constexpr and const": "constexpr i const", "constexpr because it's a compile-time constant": "constexpr, ponieważ jest to stała czasu kompilacji", "constexpr but non-const": "constexpr ale non-const", "constexpr const std::string_view (reference dropped and top-level const dropped, constexpr applied, implicitly const)": "constexpr const std::string_view (usunięto odwołanie i constexpr najwyższego poziomu, zastosowano constexpr, domyślnie const)", "constexpr const std::string_view& (reference reapplied, low-level const not dropped, constexpr applied)": "constexpr const std::string_view& (ponownie zastosowano odwołanie, nie usunięto stałej niskiego poziomu, zastosowano constexpr)", "constexpr global variable g_z, initialized with a value": "zmienna globalna constexpr g_z, zainicjowana przez wartość", "constexpr globals can be defined as extern, making them external (but this is pretty useless, see the warning in the next section)": "globale constexpr można zdefiniować jako zewnętrzne, czyniąc je zewnętrznymi (ale jest to całkiem bezużyteczne, zobacz ostrzeżenie w następnej sekcji)", "constexpr globals have internal linkage by default": "globale constexpr mają domyślnie wewnętrzne powiązania", "constexpr int length{ sizeof(array) / sizeof(array[0]) }; // use instead if not C++17 capable": "constexpr int długość{ sizeof(array) / sizeof(array[0]) }; // zamiast tego użyj, jeśli nie obsługuje C++17", "construct a temporary Employee to pass to function (type deduced from parameter)": "skonstruuj tymczasowego pracownika, który będzie przekazywany do funkcji (typ wywnioskowany z parametru)", "construct a temporary Employee to pass to function (type explicitly specified) (preferred)": "konstruuj tymczasowego pracownika, który będzie przekazywany do funkcji (typ jawnie określony) (preferowane)", "constructors must be non-const": "konstruktory nie muszą być stałymi", "containing the function call.": "zawierającymi wywołanie funkcji.", "content here": "treść tutaj", "contents of iostream header here": "zawartość nagłówka iostream tutaj", "controls whether the loop ends or not": "kontroluje, czy pętla się kończy, czy nie", "conversion to unsigned may or may not preserve value": "konwersja na unsigned może, ale nie musi, zachować wartość", "convert '-5' to unsigned and back": "konwertować '-5' na unsigned i z powrotem", "convert 'c' to double and back": "konwertuj 'c' na double i z powrotem", "convert Animals::elephant to an integer using unary operator+": "konwertuj Animals::elephant na liczbę całkowitą za pomocą operatora jednoargumentowego+", "convert double 1.23456789 to float and back": "konwertuj double 1,23456789 na float i z powrotem", "convert double 3.5 to int and back": "konwertuj double 3,5 na int i z powrotem", "convert double to bool": "konwertuj double na bool", "convert double to float": "konwertuj double na float", "convert double to int": "konwertuj double na int", "convert double to long double": "konwertuj double na long double", "convert from int to short": "konwertuj z int na short", "convert int 3 to long and back": "konwertuj int 3 na long i odwrotnie", "convert int to bool": "konwertuj int na bool", "convert int to double": "konwertuj int na double", "convert int to long": "przekonwertuj int na long", "convert int to short": "przekonwertuj int na krótki", "convert int to unsigned int": "przekonwertuj int na unsigned int", "convert integer 2 to a Pet": "przekonwertuj liczbę całkowitą 2 na Pet", "convert our int to a double so we can call max(double, double)": "przekonwertuj naszą int na double, abyśmy mogli wywołać max(double, double)", "convert short to char": "konwertuj short na char", "convert to underlying type, will print 1 (C++23)": "konwertuje na typ bazowy, wypisze 1 (C++23)", "copies forward declaration from add.h here": "kopiuje dalej deklarację z add.h tutaj", "copies m_length elements of str.m_data into m_data": "kopiuje m_length elementy str.m_data do m_data", "copies the A portion of c into a (don't do this)": "kopiuje część A c do (nie rób tego)", "copy assignment of value 5 into variable width": "skopiuj przypisanie wartości 5 do zmiennej szerokości", "copy gets destroyed here": "kopia zostanie zniszczona tutaj", "copy here": "skopiuj tutaj", "copy initialization": "skopiuj inicjalizację", "copy initialization (non-explicit constructors only)": "skopiuj inicjalizację (tylko konstruktory niejawne)", "copy initialization allows implicit conversion from int to bool": "inicjalizacja kopiowania umożliwia niejawną konwersję z int na bool", "copy is a local variable, so it gets destroyed here.  The destructor deletes copy's string, which leaves hello with a dangling pointer": "copy jest zmienną lokalną, więc tutaj zostaje zniszczona. Destruktor usuwa ciąg kopii, co pozostawia hello ze zwisającym wskaźnikiem", "copy length elements of data into m_data": "skopiuj elementy długości danych do m_data", "copy list initialization": "skopiuj inicjalizację listy", "copy list initialization (non-explicit constructors only)": "skopiuj inicjalizację listy (tylko konstruktory niejawne)", "copy m_length elements from arr to m_array": "skopiuj elementy m_length z arr do m_array", "copy the bits from n into f": "skopiuj bity z n do f", "copy the elements": "skopiuj elementy", "copy the returned object into s_mychars": "skopiuj zwrócony obiekt do s_mychars", "copy-initialization": "kopiuj-inicjalizację", "copy-initialization (initial value after equals sign)": "kopiuj-inicjalizację (wartość początkowa po znaku równości)", "copy-initialization of value 5 into variable width": "skopiuj-inicjalizację wartości 5 do zmiennej szerokości", "copy-list initialization using braced list": "inicjalizacja listy kopiowania za pomocą nawiasów klamrowych lista", "copy-list-initialization of initial value 6 into variable height (rarely used)": "skopiuj-listę-inicjalizacja wartości początkowej 6 do zmiennej wysokości (rzadko używana)", "correct (aliased type name first)": "poprawna (najpierw nazwa typu aliasu)", "correct (but not recommended)": "poprawna (ale nie zalecana)", "correct and recommended (easier to read)": "poprawna i zalecana (łatwiejsza do odczytania)", "correct: a and b are initialized to 5": "poprawna: a i b są inicjalizowane do 5", "correct: a and b both have initializers": "poprawne: a i b mają inicjatory", "correct: if value is 0, or if value is 1": "poprawne: jeśli wartość wynosi 0 lub jeśli wartość wynosi 1", "correct: ptr3 and ptr4 are both pointers to an int": "poprawne: ptr3 i ptr4 są wskaźnikami do odpowiedniej funkcji int", "corresponding function.": ".", "could also be placed in namespace": "można również umieścić w przestrzeni nazw", "could be public if we want these to be accessible": "może być publiczne, jeśli chcemy, aby były dostępne", "count from 10 down to 0": "licz od 10 do 0", "count how many times the loop iterates": "policz, ile razy pętla wykona iteracje", "count is how many additional arguments we're passing": "liczba oznacza, ile dodatkowych argumentów przekazujemy", "count is now a std::size_t to make indexing the std::vector easier": "liczba jest teraz std::size_t, aby ułatwić indeksowanie std::vector", "cout lives in the iostream library": "cout znajduje się w iostream biblioteka", "create a Date object": "utwórz obiekt Date", "create a Fraction with a zero denominator": "utwórz ułamek o zerowym mianowniku", "create a Person named \"Lucy\"": "utwórz osobę o imieniu \"Lucy\"", "create a Person named \"Ricky\"": "utwórz osobę o imieniu \"Ricky\"", "create a copy of count": "utwórz kopię licznika", "create a function pointer and make it point to function printValue": "utwórz wskaźnik funkcji i ustaw go na funkcję printValue", "create a function pointer object, set to nullptr initially": "utwórz obiekt wskaźnika funkcji, początkowo ustaw na nullptr", "create a nested block": "utwórz zagnieżdżony blok", "create a reverse view": "utwórz widok odwrotny", "create a std::string local to this nested block": "utwórz std::string lokalnie dla tego zagnieżdżonego bloku", "create a teacher": "utwórz nauczyciela", "create a temporary std::bitset and print it": "utwórz tymczasowy std::bitset i wydrukuj to", "create a temporary std::string initialized with \"Hello\"": "utwórz tymczasowy std::string zainicjowany przez „Hello”", "create a temporary std::string using value initialization / default constructor": "utworzy tymczasowy std::string przy użyciu inicjalizacji wartości/konstruktora domyślnego", "create a value initialized std::random_device object": "utworzy wartość zainicjalizowaną obiekt std::random_device", "create a vector of length 3": "utworzy wektor o długości 3", "create a vector to hold 365 double values": "utwórz wektor przechowujący 365 podwójnych wartości", "create an Employee struct for Frank": "utwórz strukturę Pracownik dla Franka", "create an Employee struct for Joe": "utwórz strukturę Pracownik dla Joego", "create an apple": "utwórz jabłko", "create an empty Department": "utwórz pusty Dział", "create an object": "utwórz obiekt", "create named object p initialized with { 1, 2 }": "utwórz nazwany obiekt p zainicjowany za pomocą { 1, 2", "create normal type alias": "utwórz alias typu normalnego", "create ptr2 directly from res (instead of ptr1)": "utwórz ptr2 bezpośrednio z res (zamiast ptr1)", "create ptr2 using copy of ptr1": "utwórz ptr2 używając kopii ptr1", "create temporary object initialized with { 1, 2 }": "utwórz obiekt tymczasowy zainicjowany za pomocą { 1, 2", "create thumbnail": "utwórz miniaturę", "create variables a and b, but do not initialize them": "utwórz zmienne aib, ale nie rób tego zainicjuj je", "create vector with 3 elements": "utwórz wektor z 3 elementami", "createEmployee() returns an Employee by value (which means the returned value is an rvalue)": "createEmployee() zwraca pracownika według wartości (co oznacza, że zwrócona wartość jest wartością)", "creates a temporary object, and then copies it into the vector": "tworzy obiekt tymczasowy, a następnie kopiuje go do wektora", "creates object p3 using prior definition for Pair<double>": "tworzy obiekt p3 korzystając z wcześniejszej definicji pary<double>", "d and i are destroyed here": "d i i są niszczone tutaj", "d and i go out of scope here": "d i i wychodzą tutaj poza zakres", "d can be used in constant expressions!": "d można używać w wyrażeniach stałych!", "d created and initialized here": "d utworzony i zainicjalizowany tutaj", "d defined as const int d { 0 };": "d zdefiniowany jako const int d { 0 };", "d enters scope here": "d wchodzi tutaj w zakres", "d has type const double (const dropped but implicitly reapplied by constexpr)": "d ma typ const double (const usunięty, ale domyślnie ponownie zastosowany przez constexpr)", "d is a non-modifiable lvalue expression": "d jest niemodyfikowalnym wyrażeniem wartości", "d is const double (const dropped, const reapplied)": "d jest const double (const usunięty, const ponownie zastosowany)", "d is double, so this is floating point division": "d jest double, więc jest to dzielenie zmiennoprzecinkowe", "d is not usable in constant expressions (d is non-const)": "d nie można używać w wyrażeniach stałych (d nie jest stałą)", "d trivially converted from double to const double& (non-ref to ref conversion)": "d prosto konwertowane z double na const double& (konwersja inna niż ref)", "data lost: will be converted to float 1.23457 (precision lost)": "utrata danych: zostaną przekonwertowane na float 1.23457 (utrata precyzji)", "data lost: will be converted to int value 3 (fractional value 0.5 lost)": "utrata danych: zostaną przekonwertowane na wartość int 3 (utracona wartość ułamkowa 0,5)", "data was dynamically allocated, it won't be destroyed when it goes out of scope.": "dane zostały przydzielone dynamicznie, nie zostaną zniszczone, gdy wyjdą poza zakres.", "data() returns a pointer to the first element": "data() zwraca wskaźnik do pierwszy element", "debug code to ensure getUserInput() is working, we'll remove this later": "kod debugowania, aby upewnić się, że getUserInput() działa, usuniemy to później", "declaration of function bar that has no parameters and returns a Foo (inconsistent with `Foo bar{}` and `Foo()`)": "deklaracja paska funkcji, która nie ma parametrów i zwraca Foo (niezgodna z `Foo bar{}` i `Foo()`)", "declare a const iterator and assign to start of vector": "deklaracja iteratora const i przypisanie do początku wektora", "declare a double buffer with room for 4 doubles": "deklaracja podwójny bufor z miejscem na 4 doubles", "declare a non-type template parameter of type int named N": "zadeklaruj nietypowy parametr szablonu typu int o nazwie N", "declare a read-only iterator": "zadeklaruj iterator tylko do odczytu", "declare an inline namespace named V1": "zadeklaruj wbudowaną przestrzeń nazw o nazwie V1", "declare an inline namespace named V2": "zadeklaruj wbudowaną przestrzeń nazw o nazwie V2", "declare an inline unnamed namespace": "zadeklaruj wbudowaną przestrzeń nazw bez nazwy przestrzeń nazw", "declare an int array": "zadeklaruj tablicę int", "declare an integer array with room for 12 integers": "zadeklaruj tablicę liczb całkowitych z miejscem na 12 liczb całkowitych", "declare an integer array with room for 6 integers": "zadeklaruj tablicę liczb całkowitych z miejscem na 6 liczb całkowitych", "declare an iterator": "zadeklaruj iterator", "declare array large enough to hold 254 characters + null terminator": "zadeklaruj tablicę wystarczająco dużą, aby pomieścić 254 znaki + null terminator", "declare function pointer that returns an int and takes no parameters": "deklaruj wskaźnik funkcji, który zwraca wartość typu int i nie przyjmuje żadnych parametrów", "declare global variable (will be zero-initialized by default)": "deklaruj zmienną globalną (domyślnie będzie inicjalizowana zerem)", "declare s_value as static": "deklaruj wartość_s jako statyczną", "declare s_value as static (initializer moved below)": "deklaruj wartość_s jako statyczną (inicjator przeniesiony poniżej)", "declares our own \"cout\" function": "deklaruje własne „cout” funkcja", "decltype(arr) resolves to std::vector<int>": "decltype(arr) przekształca się w std::vector<int>", "decrements global value, not local value (parenthesis added for readability)": "zmniejsza wartość globalną, a nie lokalną (nawias dodano dla czytelności)", "deduce non-type template parameter from template argument": "wydedukuj parametr szablonu niebędący typem z argumentu szablonu", "deduced to pair<float, float>": "wydedukowano do pary<float, float>", "deduced to pair<unsigned int, unsigned int>": "wydedukowano do pary<unsigned int, unsigned int>", "deduces max<int>(int, int) (non-template functions not considered)": "dedukuje max<int>(int, int) (funkcje inne niż szablon nie są brane pod uwagę)", "deduces print<bool>(bool) (non-template functions not considered) -- prints 1": "dedukuje print<bool>(bool) (funkcje inne niż szablon nie są brane pod uwagę) -- wypisuje 1", "deep copy": "głębokie kopiowanie", "default T and U to type int": "domyślne T i U do wpisania int", "default argument for id": "domyślny argument dla id", "default initialize to false": "domyślna inicjalizacja na false", "default member initializer (will be ignored)": "domyślny inicjator elementu (zostanie zignorowany)", "default member initializer (will be used)": "domyślny inicjator elementu (będzie używany)", "default value (0)": "wartość domyślna (0)", "defaults to \"John\"": "domyślnie \"John\"", "defaults to \"John\" and 'J'": "domyślnie \"John\" i 'J'", "define Distance as an alias for type double": "zdefiniuj Odległość jako alias dla typu double", "define Miles as an alias for type long": "zdefiniuj Mile jako alias dla typu long", "define Speed as an alias for type long": "zdefiniuj Speed jako alias dla typu long", "define a function of type void(int)": "zdefiniuj funkcję typu void(int)", "define a named constant with our desired initialization value": "zdefiniuj nazwaną stałą z żądaną wartością inicjalizacyjną", "define a new variable and initialize it with num * 2": "zdefiniuj nową zmienną i zainicjuj ją num * 2", "define a pointer variable holding the address of str": "zdefiniuj zmienną wskaźnikową przechowującą adres str", "define a type alias for a function pointer to a void(int) function": "zdefiniuj alias typu dla wskaźnika funkcji do funkcji void(int)", "define a type alias named Color": "zdefiniuj alias typu o nazwie Kolor", "define a type alias with identifier 'Length'": "zdefiniuj alias typu o identyfikatorze 'Długość'", "define a variable named width, of type double": "zdefiniuj zmienną o nazwie szerokość, typu double", "define an array of 5 int values": "zdefiniuj tablicę 5 wartości typu int", "define an array of 5 integers of type int[5] (we'll cover this in a future chapter)": "zdefiniuj tablicę 5 liczb całkowitych typu int[5] (omówimy to w następnym rozdziale)", "define an array with 1000 elements, x[0] is initialized to 5": "zdefiniuj tablicę za pomocą 1000 elementów, x[0] jest inicjowane do 5", "define an array with 7 elements": "zdefiniuj tablicę z 7 elementami", "define an integer variable named width": "zdefiniuj zmienną całkowitą o nazwie szerokość", "define an integer variable named x": "zdefiniuj zmienną całkowitą o nazwie x", "define an integer variable named x (preferred)": "zdefiniuj zmienną całkowitą o nazwie x (preferowaną)", "define and initialize s_value to 1": "zdefiniuj i zainicjuj wartość_s do 1", "define and initialize s_value to 1 (we'll discuss this section below)": "zdefiniuj i zainicjuj wartość_s na 1 (ten rozdział omówimy poniżej)", "define apples in the scope of the nested block": "zdefiniuj jabłka w zakresie zagnieżdżonego bloku", "define integer variable x, initialized with value 5": "zdefiniuj zmienną całkowitą x, zainicjowaną wartością 5", "define our own Pair type": "zdefiniuj własny typ pary", "define the function add() inside namespace BasicMath": "zdefiniuj funkcję add() w przestrzeni nazw BasicMath", "define two integer variables, named y and z": "zdefiniuj dwie zmienne całkowite, nazwane y i z", "define variable num as an integer variable": "zdefiniuj zmienną num jako zmienną całkowitą", "define variable of compound type 'pointer to int'": "zdefiniuj zmienną typu złożonego „wskaźnik na int”", "define variable of compound type 'reference to int' (initialized with x)": "zdefiniuj zmienną typu złożonego „odniesienie do int” (zainicjowaną x)", "define variable of fundamental type 'double'": "zdefiniuj zmienną typu podstawowego 'double'", "define variable of fundamental type 'int'": "zdefiniuj zmienną typu podstawowego 'int'", "define variable width and initialize with initial value 5": "zdefiniuj szerokość zmiennej i zainicjuj jej wartością początkową 5", "define variable x to hold user input": "zdefiniuj zmienną x do przechowywania danych wejściowych użytkownika", "define variable x to hold user input (and value-initialize it)": "zdefiniuj zmienną x do przechowywania danych wejściowych użytkownika (i inicjuj je wartością)", "define variable y to hold user input (and value-initialize it)": "zdefiniuj zmienną y do przechowywania danych wejściowych użytkownika (i inicjuj wartość it)", "define your factorial() function template here": "zdefiniuj tutaj szablon funkcji silni()", "define your own namespace to hold constants": "zdefiniuj własną przestrzeń nazw do przechowywania stałych", "defines a 1 element vector containing value `5`.": "definiuje 1-elementowy wektor zawierający wartość `5`.", "defines a 5 element vector where elements are value-initialized.": "definiuje 5-elementowy wektor gdzie elementy są inicjowane przez wartość.", "defines a class type named Pair": "definiuje typ klasy o nazwie Pair", "defines a member function named print": "definiuje funkcję składową o nazwie print", "defines a member function named print()": "definiuje funkcję składową o nazwie print()", "defines a type template parameter named Pair (shadows Pair class type)": "definiuje parametr szablonu typu o nazwie Pair (cienie Typ klasy Pair)", "defines a variable of type double": "definiuje zmienną typu double", "defines explicitly initialized global variable": "definiuje jawnie zainicjowaną zmienną globalną", "defines explicitly value-initialized global variable": "definiuje jawnie zainicjowaną wartość globalną zmienną", "defines initialized const external global variable": "definiuje zainicjowaną stałą zewnętrzną zmienną globalną", "defines initialized constexpr external global variable": "definiuje zainicjowaną zewnętrzną zmienną globalną constexpr", "defines initialized external global variable": "definiuje zainicjowaną zewnętrzną zmienną globalną", "defines initialized internal global const variable": "definiuje zainicjowaną wewnętrzną globalną stałą zmienna", "defines initialized internal global constexpr variable": "definiuje zainicjalizowaną wewnętrzną zmienną globalną constexpr", "defines initialized internal global variable": "definiuje zainicjalizowaną wewnętrzną zmienną globalną", "defines internal function": "definiuje funkcję wewnętrzną", "defines non-initialized external global variable (zero initialized by default)": "definiuje niezainicjowaną zewnętrzną zmienną globalną (domyślnie inicjowane jest zero)", "defines non-initialized global variable (zero initialized by default)": "definiuje niezainicjowaną zmienną globalną (zero inicjowane przez domyślnie)", "defines non-initialized internal global variable (zero initialized by default)": "definiuje niezainicjowaną wewnętrzną zmienną globalną (domyślnie inicjowane jest zero)", "defines our own \"cout\" function in the global namespace": "definiuje własną funkcję „cout” w globalnej przestrzeni nazw", "definition for add() in header file -- don't do this!": "definicja dla add() w pliku nagłówkowym -- nie rób tego!", "definition of function pointer ptr": "definicja wskaźnika funkcji ptr", "definition of variable bar, value-initialized": "definicja paska zmiennej, zainicjowana wartość", "delegate initialization to Employee(std::string_view, int) constructor": "deleguj inicjalizację do konstruktora Employee(std::string_view, int)", "delegate to the other constructor": "deleguj do innego konstruktora", "delete each element in the vector here": "usuń tutaj każdy element wektora", "delete it": "usuń go", "department goes out of scope here and is destroyed": "dział wykracza poza zakres tutaj i zostaje zniszczony", "dereference our loop variable to get the current element": "usuń odwołanie do naszej pętli zmienna, aby uzyskać bieżący element", "dereference std::optional to get matching enumerator": "dereferencja std::opcjonalny, aby uzyskać pasujący moduł wyliczający", "dereference to get pointer to int, dereference again to get int value": "dereferencja, aby uzyskać wskaźnik do int, ponownie wyłuskaj, aby uzyskać wartość int", "dereference to get value stored in o1 (undefined behavior if o1 does not have a value)": "dereferencja w celu uzyskania wartości zapisanej w o1 (niezdefiniowane zachowanie, jeśli o1 nie ma wartości)", "derived catch blocks go first": "wyprowadzone bloki catch idą pierwsze", "destructor will close the file": "destruktor zamknie plik", "differentiated from foo(int, int)": "w odróżnieniu od foo(int, int)", "direct access to global variable": "bezpośredni dostęp do zmiennej globalnej", "direct function call to Foo::printValue(int)": "bezpośrednie wywołanie funkcji Foo::printValue(int)", "direct function call to printValue(int)": "bezpośrednie wywołanie funkcji do printValue(int)", "direct function call to printValue<int>(int)": "bezpośrednie wywołanie funkcji do printValue<int>(int)", "direct initialization of value 5 into variable width": "bezpośrednia inicjalizacja wartości 5 do zmiennej szerokości", "direct initialization using parenthesized list (C++20)": "bezpośrednia inicjalizacja za pomocą listy w nawiasach (C++20)", "direct-initialization (initial value in parenthesis)": "bezpośrednia inicjalizacja (wartość początkowa w nawias)", "direct-list-initialization (initial value in braces)": "bezpośrednia-inicjalizacja-listy (wartość początkowa w nawiasach klamrowych)", "direct-list-initialization of initial value 5 into variable width (preferred)": "bezpośrednia-inicjalizacja-listy o wartości początkowej 5 do zmiennej szerokości (preferowane)", "direct-list-initialization with initial value 0": "bezpośrednia-inicjalizacja-listy o wartości początkowej 0", "disable asserts (must be placed before any #includes)": "wyłącz potwierdzenia (należy umieścić przed jakimkolwiek #includes)", "distance is actually just a long": "odległość to właściwie tylko długi", "divide by count of items (integral in nature)": "dzielenie przez liczbę elementów (z natury całkowej)", "division by 0 is undefined in mathematics": "dzielenie przez 0 jest niezdefiniowane w matematyce", "do left shift (which shifts the leftmost bit off the end)": "zrób przesunięcie w lewo (które przesuwa skrajny lewy bit poza koniec)", "do not define y here": "nie definiuj tutaj y", "do something else": "zrób coś innego", "do something else that doesn't involve dereferencing ptr (print an error message, do nothing at all, etc...)": "zrób coś innego, co nie wymaga wyłuskiwania ptr (drukuj komunikat o błędzie, w ogóle nic nie rób itp...)", "do something with selection here": "zrób coś z zaznaczeniem tutaj", "do something with x": "zrób coś z x", "do stuff with ptr here": "zrób coś z ptr tutaj", "do the conversion": "wykonaj konwersję", "do the copy": "zrób kopię", "doPrint() called for the first time": "doPrint() wywołaną po raz pierwszy", "doPrint() called for the second time": "doPrint() wywołaną po raz drugi time", "doPrint() is the called function in this example": "doPrint() to funkcja wywoływana w tym przykładzie", "does a emplace_back": "wykonuje emplace_back", "does an emplace_back": "wykonuje emplace_back", "does floating point division, initializes d with value 2.5": "dokonuje dzielenia zmiennoprzecinkowego, inicjuje d wartością 2,5", "does integer division, initializes d with value 2.0": "dokonuje dzielenia liczb całkowitych, inicjuje d wartością 2.0", "does not compile (initializer not a pointer)": "nie kompiluje się (inicjator nie jest wskaźnikiem)", "does not create an implicit block": "nie tworzy ukrytego bloku", "does not throw exceptions": "nie generuje wyjątków", "does not work": "nie działa", "does this look like it's setting the day member to 5?": "czy to wygląda, jakby ustawiało element dnia na 5?", "doesn't create copy when called": "nie tworzy kopii, gdy wywołany", "doesn't make a copy": "nie tworzy kopii", "dollars will be implicitly cast to a Cents here": "dolary zostaną tutaj domyślnie przerzucone na centy", "don't fall-through to next case": "nie przechodź do następnego przypadku", "don't forget to use array delete": "nie zapomnij użyć usuwania tablicy", "don't print a number, but print two spaces": "nie drukuj liczby, ale wydrukuj dwie spacje", "don't you think so?": "nie sądzisz więc?", "double can be numerically converted to unsigned int or to float": "double można numerycznie przekonwertować na unsigned int lub na float", "double for-loop with indices": "podwójną pętlę for z indeksami", "double is a non-template parameter": "double jest parametrem innym niż szablon", "double num's value, then assign that value back to num": "double wartość num, a następnie przypisz tę wartość z powrotem do num", "double quoted (by itself) (unconventional but okay)": "w podwójnym cudzysłowie (samo w sobie) (niekonwencjonalne, ale OK)", "double range-based for-loop": "pętla for oparta na podwójnym zakresie", "double value 0.123456789 has 9 significant digits, but float can only support about 7": "wartość double 0.123456789 ma 9 cyfr znaczących, ale float może obsługiwać tylko około 7", "double value 3.0 implicitly converted to type float": "wartość double 3.0 pośrednio przekonwertowana na typ float", "double& is a reference to a double": "double& jest odniesieniem do podwójnego", "dynamic cast using a reference instead of a pointer": "dynamicznego rzutowania przy użyciu odniesienia zamiast wskaźnika", "dynamically allocate an integer": "dynamicznie przydziel liczbę całkowitą", "dynamically allocate an integer (and discard the result)": "dynamicznie przydziel liczbę całkowitą (i odrzuć wynik)", "dynamically allocate an integer and assign the address to ptr so we can access it later": "dynamicznie przydziel liczbę całkowitą i przypisz adres do ptr, abyśmy mogli uzyskać do niej później dostęp", "e is a runtime constant": "e jest stałą czasu wykonania", "e is constexpr double (const dropped, constexpr reapplied)": "e jest constexpr double (const usunięte, constexpr ponownie zastosowany)", "e is not usable in constant expressions (initializer is not a constant expression)": "e nie można używać w wyrażeniach stałych (inicjator nie jest wyrażeniem stałym)", "e is our range-declaration": "e to nasza deklaracja zakresu", "early return (only when x < 0)": "wcześniejszy powrót (tylko gdy x < 0)", "easier to read": "łatwiejszy do odczytania", "easier to read (we don't have to read the return type unless we care)": "łatwiejszy do odczytania (nie musimy czytać typu powrotu, chyba że care)", "easiest way to access the s and sv suffixes": "najłatwiejszy sposób dostępu do sufiksów s i sv", "easy access to the s suffix": "łatwy dostęp do sufiksu s", "either hello or world will be returned by reference": "albo hello, albo świat zostanie zwrócony przez odwołanie", "element will be a Shape*": "element będzie Kształt*", "elements are type std::string_view": "elementy są typu std::string_view", "empty function parameters is an implicit void": "puste parametry funkcji są niejawną pustką", "empty string": "pusty ciąg", "enable automatic flushing for std::cout (for debugging)": "włącz automatyczne opróżnianie dla std::cout (do debugowania)", "end for loop": "koniec pętli", "end of another nested block": "koniec kolejnego zagnieżdżonego bloku", "end points to one-past-the-end element": "punkt końcowy elementu znajdującego się za końcem", "ensure 'all' contains the correct number of enumerators": "upewnij się, że „all” zawiera poprawną liczbę modułów wyliczających", "ensuring that only one count exists": "upewnij się, że istnieje tylko jeden licznik", "enter 5 or -5": "wprowadź 5 lub -5", "erase the buffer": "usuń bufor", "erase the element currently being iterated over": "usuń aktualnie wykonywany element over", "erase the element currently being iterated over, set `it` to next element": "usuń element aktualnie poddawany iteracji, ustaw `it` na następny element", "erase() invalidates iterators to the erased element (and subsequent elements)": "erase() unieważnia iteratory do usuniętego elementu (i kolejnych elementów)", "error: ' used before first digit of value": "błąd: ' użyty przed pierwszą cyfrą wartości", "error: '6' converts to integer value 54, which is already used": "błąd: '6' konwertuje na wartość całkowitą 54, która jest już używana", "error: 2 is not an enumerator of Color": "błąd: 2 nie jest moduł wyliczający Color", "error: 5 is an rvalue": "błąd: 5 to wartość", "error: 5 is an rvalue expression and x is a modifiable lvalue expression": "błąd: 5 to wyrażenie wartości, a x to modyfikowalne wyrażenie wartości", "error: Move constructor was deleted": "błąd: Konstruktor przenoszenia został usunięty", "error: Storage hasn't seen the full definition of class Display": "błąd: Pamięć nie widziała pełnej definicji klasy Display", "error: already used value 54!": "błąd: już użyta wartość 54!", "error: can not assign value of x to literal value 5": "błąd: nie można przypisz wartość x do wartości literału 5", "error: can not change const value": "błąd: nie można zmienić wartości stałej", "error: can't forward declare nested type prior to outer class definition": "błąd: nie można przekazać dalej zadeklarowania typu zagnieżdżonego przed definicją klasy zewnętrznej", "error: can't implicitly convert initializer list to Foo": "błąd: nie można niejawnie przekonwertować listy inicjatorów na Foo", "error: can't implicitly convert int to Foo": "błąd: nie można niejawnie przekonwertować int na Foo", "error: can't take address of r-value": "błąd: nie można przyjąć adresu wartość r", "error: compiler can't find matching function": "błąd: kompilator nie może znaleźć pasującej funkcji", "error: const qualifer can not be applied twice": "błąd: const kwalifikatora nie można zastosować dwukrotnie", "error: const variables can not be changed": "błąd: zmiennych const nie można zmienić", "error: const variables must be initialized": "błąd: zmienne const muszą zostać zainicjowane", "error: constAge is const, so we cannot change its value": "błąd: constAge jest const, więc nie możemy zmienić jego wartości", "error: constant variables must be initialized": "błąd: stała zmienne muszą zostać zainicjowane", "error: consteval functions must evaluate at compile-time": "błąd: funkcje consteval muszą zostać obliczone w czasie kompilacji", "error: constexpr variables must be initialized": "błąd: zmienne constexpr muszą zostać zainicjowane", "error: does not match above function (cannot skip argument for sv)": "błąd: nie pasują do powyższej funkcji (nie można pominąć argumentu dla sv)", "error: double to int not safe": "błąd: double do int nie jest bezpieczny", "error: getValue() is private in Derived": "błąd: getValue() jest prywatny w Derived", "error: getValue(int) is private in Derived": "błąd: getValue(int) jest prywatny w Derived", "error: initialization order does not match order of declaration in struct": "błąd: kolejność inicjalizacji nie jest zgodna z kolejnością deklaracji w struct", "error: length is not a constant expression": "błąd: długość nie jest wyrażeniem stałym", "error: m_value is private in Derived": "błąd: m_wartość jest prywatna w Derived", "error: naming collision with the above blue": "błąd: kolizja nazewnictwa z powyższym niebieskim", "error: narrowing conversion from unsigned int to std::uint8_t": "błąd: zawężenie konwersja z unsigned int na std::uint8_t", "error: numStudents is not a constant expression": "błąd: numStudents nie jest wyrażeniem stałym", "error: once initialized, a const pointer can not be changed.": "błąd: po zainicjowaniu wskaźnik const nie może zostać zmieniony.", "error: print() was expecting an int argument, we tried to pass in a string literal": "błąd: print() oczekiwał argumentu int, próbowaliśmy przekazać literał łańcuchowy", "error: ref can not bind to non-modifiable lvalue": "błąd: ref nie może powiązać z niemodyfikowalnym lwartość", "error: references must be initialized": "błąd: referencje muszą zostać zainicjowane", "error: s_value is private and can't be accessed directly outside the class": "błąd: wartość_s jest prywatna i nie można uzyskać do niej dostępu bezpośrednio poza klasą", "error: the compiler will deduce this to be a zero-length array, which is disallowed!": "błąd: kompilator wywnioskuje, że jest to tablica o zerowej długości, co jest niedozwolone!", "error: the template non-type argument must be constexpr": "błąd: argument nietypowy szablonu musi być constexpr", "error: this jump is illegal because...": "błąd: ten skok jest nielegalny ponieważ...", "error: this will assume we're accessing index 2 of an array of IntLists": "błąd: zakłada się, że uzyskujemy dostęp do indeksu 2 tablicy IntLists", "error: too few template arguments, both arguments not deduced": "błąd: za mało argumentów szablonu, nie wydedukowano obu argumentów", "error: too few template arguments, second argument not deduced": "błąd: za mało argumentów szablonu, nie wydedukowano drugiego argumentu", "error: we can not modify an object through a const reference": "błąd: nie możemy zmodyfikować obiektu poprzez odwołanie do stałej", "error: white is not an enumerator of Color": "błąd: biały nie jest moduł wyliczający Color", "error: y not declared yet, so compiler doesn't know what it is": "błąd: y nie został jeszcze zadeklarowany, więc kompilator nie wie, co to jest", "error: z is a non-modifiable lvalue": "błąd: z jest niemodyfikowalną wartością", "especially when all bunched together": "szczególnie gdy wszystkie są zebrane razem", "especially when all lined up": "szczególnie gdy wszystkie są ustawione w jednej linii", "especially when lines are different lengths": "szczególnie gdy linie są różne długości", "evaluate (a, b) first to get result of b, then assign that value to variable z.": "najpierw oceń (a, b), aby uzyskać wynik b, następnie przypisz tę wartość do zmiennej z.", "evaluates as \"(z = a), b\", so z gets assigned the value of a, and b is evaluated and discarded.": "ocenia jako \"(z = a), b\", więc z otrzymuje wartość a, a b jest oceniane i odrzucane.", "evaluates to the return value of function five()": "ocenia wartość zwracaną przez funkcję five()", "evaluation causes arr to decay, type deduction should deduce type int*": "ocena powoduje zanik arr, typ dedukcji powinien wywnioskować, wpisz int*", "even though it has a definition": "nawet jeśli ma definicję", "even though prime is the actual array, within this function it should be treated as a constant": "mimo że liczba pierwsza jest rzeczywistą tablicą, w ramach tej funkcji powinna być traktowana jako stała", "even though the body of add() isn't defined until here": "mimo że treść funkcji add() nie jest zdefiniowana aż do tego miejsca", "even when the return expression is a constant expression": "nawet jeśli wyrażenie zwrotne jest wyrażeniem stałym", "every square number by @multiplier.": "każda liczba kwadratowa @multiplier.", "exact match with foo(double)": "dokładne dopasowanie z foo(double)", "exact match with foo(int)": "dokładne dopasowanie do foo(int)", "exception caught here and handled": "tutaj złapany i obsłużony wyjątek", "execution continues here": "wykonanie jest kontynuowane tutaj", "execution continues here after the exception is handled": "wykonanie jest kontynuowane tutaj po obsłużeniu wyjątku", "execution starts here": "wykonanie rozpoczyna się tutaj", "execution will continue at the first statement beyond the loop": "wykonanie będzie kontynuowane od pierwszej instrukcji poza pętlą", "execution will continue here after the break": "wykonanie będzie kontynuowane tutaj po przerwaniu", "exit loop if user enters 0": "wyjście z pętli, jeśli użytkownik wejdzie 0", "exit the loop now": "wyjdź teraz z pętli", "expensive to copy": "kosztowne kopiowanie", "explicit call to max<int>": "jawne wywołanie max<int>", "explicit conversion from int to char, so that a char is assigned to variable ch": "jawna konwersja z int na char, tak że znak jest przypisany do zmiennej ch", "explicit conversion to int, will print 1": "jawna konwersja na int, wyświetli 1", "explicit default value": "jawna wartość domyślna", "explicit test for equivalence": "jawna test równoważności", "explicit use of this": "jawne użycie tego", "explicitly close the file": "jawnie zamknij plik", "explicitly convert double value 5.5 to an int": "jawnie przekonwertuj wartość double 5.5 na liczbę typu int", "explicitly creates a temporary int list-initialized with value c": "jawnie tworzy tymczasową listę int zainicjalizowaną wartością c", "explicitly define the length of the array": "jawnie zdefiniuj długość tablicy", "explicitly specifies the underlying type is unsigned int": "jawnie określa podstawowy typ to unsigned int", "explicitly specify class template Pair<int, int> (C++11 onward)": "jawnie określ szablon klasy Pair<int, int> (C++11 i nowsze)", "explicitly specify class template Pair<int> (C++11 onward)": "jawnie określ szablon klasy Pair<int> (C++11 i nowsze)", "explicitly specify class template std::pair<int, int> (C++11 onward)": "jawnie określ szablon klasy std::pair<int, int> (C++11 i nowsze)", "expressions with multiple assignments still benefit from parenthesis": "wyrażenia z wieloma przypisaniami nadal korzystają z nawias", "extra set of braces to initialize the C-style array member with implementation_defined_name": "dodatkowy zestaw nawiasów klamrowych do inicjalizacji elementu tablicy w stylu C z nazwą_definiowaną_implementacji", "extract value into tX, return success or not": "wyodrębnij wartość do tX, zwróć sukces lub nie", "extracts a, leaves \" b\\n\" in stream": "wyodrębnij a, pozostaw „b\\n” w strumieniu", "extracts space, leaves \"b\\n\" in stream": "wyodrębnij spację, pozostaw „b\\n” w strumieniu", "extraneous semicolon, operator+++ does not exist": "zewnętrzny średnik, operator+++ nie istnieje", "f is copied into the function parameter using copy constructor": "f jest kopiowane do parametru funkcji przy użyciu konstruktora kopiującego", "f is not usable in constant expressions (not a const integral variable)": "f nie można używać w wyrażeniach stałych (nie jest stałą zmienną całkowitą)", "f is pass by value": "f jest przekazywane przez wartość", "f suffix causes a to be deduced to float": "f sufiks powoduje wydedukowanie a jako float", "f.m_value is initialized to default value 4": "f.m_wartość jest inicjowana do wartości domyślnej 4", "f1 of operator<< binds to the temporary, no copies are created.": "f1 operatora<< wiąże się z tymczasowym, nie są tworzone żadne kopie.", "f1.numerator value initialized to 0, f1.denominator defaulted to 1": "wartość f1.numerator inicjowana na 0, f1.denominator domyślnie na 1", "f2 is copied into the function parameter using copy constructor": "f2 jest kopiowana do parametru funkcji za pomocą konstruktora kopiującego", "f2.numerator value initialized to 0, f2.denominator defaulted to 1": "f2.numerator wartość inicjowana na 0, f2.denominator domyślnie na 1", "f3.numerator initialized to 6, f3.denominator defaulted to 1": "f3.numerator zainicjalizowany na 6, f3.mianownik domyślnie na 1", "f4.numerator initialized to 5, f4.denominator initialized to 8": "f4.numerator zainicjalizowany na 5, f4.mianownik zainicjalizowany na 8", "fail if this is a zero-length std::array": "nie powiodło się, jeśli jest to std::array", "fail the program in debug mode if a null pointer is passed (since this should never happen)": "niepowodzenie programu w trybie debugowania, jeśli zostanie przekazany wskaźnik zerowy (ponieważ to nigdy nie powinno się zdarzyć)", "fails when x is -5": "nie powiedzie się, gdy x wynosi -5", "false; boo() is implicitly noexcept(false)": "fałsz; boo() jest domyślnie noexcept(false)", "false; foo() throws an exception": "false; foo() zgłasza wyjątek", "fcnPtr is a pointer to a function that takes no arguments and returns an integer": "fcnPtr jest wskaźnikiem do funkcji, która nie przyjmuje argumentów i zwraca liczbę całkowitą", "fcnPtr now points to function goo": "fcnPtr wskazuje teraz na funkcję goo", "fcnPtr points to function foo": "fcnPtr wskazuje na funkcję foo", "fill it with values however you like": "wypełnij ją dowolnie wybranymi wartościami", "fill the array with values 10000 to 1": "wypełnij tablicę wartościami 10000 do 1", "first call to getValueFromUser": "pierwsze wywołanie getValueFromUser", "first negative, no decimal overflow": "pierwsza wartość ujemna, brak przepełnienia dziesiętnego", "first negative, possible decimal overflow": "pierwsza wartość ujemna, możliwe przepełnienie dziesiętne", "first we modify the state": "najpierw modyfikujemy stan", "first we need to deallocate any value that this string is holding!": "najpierw musimy zwolnić dowolną wartość przechowywaną w tym ciągu!", "first will have whatever type T is replaced with": "najpierw będzie dowolny typ T zostaje zastąpiony przez", "first, we need to tell the compiler that a class named Vector3d exists": "najpierw musimy powiedzieć kompilatorowi, że istnieje klasa o nazwie Vector3d", "five() is a function that returns the value 5": "five() to funkcja, która zwraca wartość 5", "flip b4 to 1011": "odwróć b4 na 1011", "flip b8 to 1111 1011": "odwróć b8 do 1111 1011", "flip bits 4 and 5 at the same time": "odwróć bity 4 i 5 jednocześnie czas", "flip option4 from on to off, or vice versa": "przełącz opcję 4 z włączonej na wyłączoną lub odwrotnie", "flip options 4 and 5": "odwróć opcje 4 i 5", "flush buffer after each insertion": "opróżnij bufor po każdym wstawieniu", "focus on this line": "skoncentruj się na tej linii", "foo and main (and std::cout) go out of scope here (the end of the file)": "foo i main (i std::cout) wychodzą tutaj poza zakres (koniec pliku)", "foo is a function": "foo to funkcja", "foo is defined in the global scope, x is defined within scope of foo()": "foo jest zdefiniowane w zasięgu globalnym, x jest zdefiniowane w zakresie foo()", "foo is popped off the call stack here": "foo jest tutaj wysuwane ze stosu wywołań", "foo is pushed on the call stack here": "foo jest wypychane na stos wywołań tutaj", "foo modified after this call": "foo zmodyfikowane po tym wywołaniu", "foo modified after this call, may not be obvious": "foo zmodyfikowane po tym wywołaniu, może nie być oczywiste", "foo modified after this call, slightly more obvious": "foo zmodyfikowane po tym wywołaniu, nieco bardziej oczywiste", "for BasicMath::add()": "dla BasicMath::add()", "for BasicMath::e": "dla BasicMath::e", "for BasicMath::pi": "dla BasicMath::pi", "for C++14, use std::uniform_int_distribution<> die6{ 1, 6 };": "dla C++14 użyj std::uniform_int_distribution<> die6{ 1, 6 };", "for CHAR_BIT": "dla CHAR_BIT", "for EXIT_SUCCESS and EXIT_FAILURE": "dla EXIT_SUCCESS i EXIT_FAILURE", "for NULL": "dla NULL", "for Random::mt": "dla Random::mt", "for assert": "dla potwierdzenia", "for assert()": "dla Assert()", "for const objects": "dla obiektów const", "for declaring Point3d::moveByVector() as a friend": "do deklarowania Point3d::moveByVector() jako znajomego", "for fast and least types": "dla szybkich i najmniejszych typów", "for fixed width integers": "dla liczb całkowitych o stałej szerokości", "for fixed-width integers": "dla liczb całkowitych o stałej szerokości", "for loop with iterators": "for pętla z iteratory", "for output manipulator std::setprecision()": "dla manipulatora wyjściowego std::setprecision()", "for rand() and srand()": "for Rand() i srand()", "for someone to casually determine what the next number in the sequence will be.": "dla kogoś, kto może przypadkowo określić, jaka będzie następna liczba w sekwencji.", "for sqrt()": "dla sqrt()", "for sqrt() function": "dla funkcji sqrt()", "for std::abort": "dla std::abort", "for std::abort()": "dla std::abort()", "for std::abs": "dla std::abs", "for std::abs (constexpr in C++23)": "for std::abs (constexpr w C++23)", "for std::abs()": "dla std::abs()", "for std::array": "dla std::array", "for std::as_const": "dla std::as_const", "for std::back_inserter": "dla std::back_inserter", "for std::bitset": "dla std::bitset", "for std::boolalpha": "dla std::boolalpha", "for std::chrono": "dla std::chrono", "for std::chrono functions": "dla funkcji std::chrono", "for std::common_type": "dla std::common_type", "for std::common_type_t": "dla std::common_type_t", "for std::copy": "dla std::copy", "for std::copy()": "dla std::copy()", "for std::copy_n": "dla std::copy_n", "for std::cout": "dla std::cout", "for std::cout and std::cin": "dla std::cout i std::cin", "for std::cout and std::endl": "dla std::cout i std::endl", "for std::exception": "dla std::exception", "for std::exit": "dla std::exit", "for std::exit()": "dla std::exit()", "for std::gcd": "dla std::gcd", "for std::greater": "dla std::greater", "for std::initializer_list": "dla std::initializer_list", "for std::int64_t": "dla std::int64_t", "for std::int8_t": "dla std::int8_t", "for std::iota": "dla std::iota", "for std::is_constant_evaluated": "dla std::is_constant_evaluated", "for std::is_constant_evaluated()": "dla std::is_constant_evaluated()", "for std::max": "dla std::max", "for std::max and std::copy_n": "dla std::max i std::copy_n", "for std::midpoint": "dla std::midpoint", "for std::move": "dla std::move", "for std::mt19937": "dla std::mt19937", "for std::mt19937 and std::random_device": "dla std::mt19937 i std::random_device", "for std::mt19937 and std::uniform_int_distribution": "dla std::mt19937 i std::uniform_int_distribution", "for std::nullptr_t": "dla std::nullptr_t", "for std::numeric_limits": "dla std::numeric_limits", "for std::optional": "dla std::opcjonalne", "for std::optional (C++17)": "dla std::opcjonalne (C++17)", "for std::pair": "dla std::pair", "for std::pair<T, U>": "dla std::pair<T, U>", "for std::reference_wrapper": "dla std::reference_wrapper", "for std::runtime_error": "dla std::runtime_error", "for std::setprecision()": "dla std::setprecision()", "for std::setw (which sets the width of the subsequent output)": "for std::setw (który ustawia szerokość kolejnego wyjścia)", "for std::shared_ptr": "dla std::shared_ptr", "for std::shared_ptr and std::weak_ptr": "dla std::shared_ptr i std::weak_ptr", "for std::shuffle": "dla std::shuffle", "for std::sin() and std::cos()": "dla std::sin() i std::cos()", "for std::size": "dla std::size", "for std::size and std::ssize": "dla std::size i std::ssize", "for std::size()": "dla std::size()", "for std::size_t": "dla std::size_t", "for std::size_t and std::ptrdiff_t": "dla std::size_t i std::ptrdiff_t", "for std::sort": "dla std::sort", "for std::sqrt": "dla std::sqrt", "for std::string": "dla std::string", "for std::string_view": "dla std::string_view", "for std::stringstream": "dla std::stringstream", "for std::strlen": "dla std::strlen", "for std::swap": "dla std::swap", "for std::to_underlying() (C++23)": "dla std::to_underlying() (C++23)", "for std::tolower": "dla std::tolower", "for std::transform": "dla std::transform", "for std::uint8_t": "dla std::uint8_t", "for std::underlying_type_t": "dla std::underlying_type_t", "for std::unique_ptr": "dla std::unique_ptr", "for std::vector": "dla std::vector", "for strlen()": "dla strlen()", "for sv suffix": "dla sufiksu sv", "for the parameter of the function moveByVector()": "dla parametru funkcji moveByVector()", "for this example": "dla tego przykładu", "for time()": "dla time()", "for typeid()": "dla typeid()", "for-loop with explicit index": "pętla for z jawnym indeksem", "for-loop with index": "pętla for z indeksem", "for-loop with pointer": "pętla for ze wskaźnikiem", "for-loop with pointer (Note: ptr can't be const, because we increment it)": "pętla for ze wskaźnikiem (Uwaga: ptr nie może być stałą, ponieważ ją zwiększamy)", "forget to implement its effect.": "zapomnij o zaimplementowaniu jego skutek.", "forward declaration above needed for this line": "deklaracja forward potrzebna dla tej linii", "forward declaration for Storage needed for reference here": "deklaracja forward dla Storage potrzebna tutaj w celach informacyjnych", "forward declaration for class Display": "deklaracja forward dla klasy Display", "forward declaration for class Storage": "deklaracja forward dla klasy Storage", "forward declaration for class Vector3d for function moveByVector()": "deklaracja forward dla klasy Vector3d dla funkcji moveByVector()", "forward declaration for const global variable": "deklaracja forward dla stałej zmiennej globalnej", "forward declaration for doSomething": "deklaracja forward dla const doSomething", "forward declaration for function add": "deklaracja forward dla funkcji add", "forward declaration for function doSomething()": "deklaracja forward dla funkcji doSomething()", "forward declaration for function foo": "deklaracja forward dla funkcji foo", "forward declaration for function foo()": "deklaracja forward dla funkcji foo()", "forward declaration for function getInteger": "deklaracja forward dla funkcji getInteger", "forward declaration for function sayHi, makes sayHi accessible in this file": "deklaracja forward dla funkcji sayHi, udostępnia sayHi w tym plik", "forward declaration for getSquarePerimeter": "deklaracja forward dla getSquarePerimeter", "forward declaration for getSquareSides": "deklaracja forward dla getSquareSides", "forward declaration for non-constant global variable": "deklaracja forward dla niestałej zmiennej globalnej", "forward declaration needed for this line": "deklaracja forward potrzebna dla tej linii", "forward declaration of add() (using a function declaration)": "deklaracja forward add() (przy użyciu deklaracji funkcji)", "forward declaration of function fcn": "deklaracja funkcji forward fcn", "forward declaration using function prototype": "deklaracja do przodu przy użyciu prototypu funkcji", "forward declaration, no default argument": "deklaracja do przodu, brak argumentu domyślnego", "forwards the arguments so the object can be created directly in the vector (no copy made)": "przekazuje argumenty, aby obiekt mógł zostać utworzony bezpośrednio w wektorze (bez tworzenia kopii)", "from add.h:": "z add.h:", "from constructor body are caught here": "z treści konstruktora przechwytywane są tutaj", "from square.h": "z kwadratu.h", "from wave.h (via square.h)": "z wave.h (via Square.h)", "full definition of Storage class": "pełna definicja klasy Storage", "fully specialized for type double": "w pełni wyspecjalizowana dla typu double", "fully specialized for type double (for comparison, not used)": "w pełni wyspecjalizowana dla typu double (dla porównania, nieużywana)", "fully specialized for type double*": "w pełni wyspecjalizowana dla typu double*", "function add() is part of namespace BasicMath": "funkcja add() jest częścią przestrzeni nazw BasicMath", "function call to foo()": "wywołanie funkcji foo()", "function declaration includes return type, name, parameters, and semicolon.  No function body!": "deklaracja funkcji zawiera typ zwracany, nazwę, parametry i średnik. Brak treści funkcji!", "function initializations": "inicjalizacje funkcji", "function is consteval": "funkcja jest stała", "function is constexpr": "funkcja jest constexpr", "function is now consteval": "funkcja jest teraz consteval", "function parameters x and y are local variables": "parametry funkcji x i y są zmiennymi lokalnymi", "function pointer initializers": "funkcja inicjatory wskaźników", "function prototype for add.h -- don't forget the semicolon!": "prototyp funkcji dla add.h -- nie zapomnij o średniku!", "function prototypes": "prototypy funkcji", "function returns here": "funkcja zwraca tutaj", "function template definition": "definicja szablonu funkcji", "function template for max(T, T)": "szablon funkcji dla max(T, T)", "function template forward declaration": "szablon funkcji deklaracja przodu", "function to calculate the greater of two int values": "funkcja do obliczenia większej z dwóch int wartości", "function will return to caller here": "funkcja zwróci tutaj funkcję wywołującą", "g_x goes out of scope here": "g_x wykracza tutaj poza zakres", "g_x is initialized first": "g_x jest inicjalizowane jako pierwsze", "g_x is now inside the Foo namespace, but is still a global variable": "g_x znajduje się teraz w przestrzeni nazw Foo, ale nadal jest zmienną globalną", "g_y and g_z goes out of scope here": "g_y i g_z wykraczają tutaj poza zakres", "g_y isn't initialized when this is called": "g_y nie jest inicjalizowane, gdy jest to wywoływany", "generate 10 random values": "wygeneruj 10 losowych wartości", "generate a roll of the die here": "wygeneruj tutaj rzut kostką", "generate the next id": "wygeneruj następny identyfikator", "generates a seeded std::mt19937 and copies it into our global object": "generuje zaszczepiony std::mt19937 i kopiuje go do naszego obiektu globalnego", "generates an explicitly defaulted default constructor": "generuje jawnie domyślny konstruktor domyślny", "get 8 integers of random numbers from std::random_device for our seed": "pobierz 8 losowych liczb całkowitych liczby z std::random_device dla naszego nasionka", "get a pointer to x": "pobierz wskaźnik do x", "get a reference to the first element": "pobierz referencję do pierwszego elementu", "get a reference to x": "pobierz referencję do x", "get a value": "pobierz wartość", "get a value from the user": "pobierz wartość od użytkownika", "get each array row": "pobierz każdy wiersz tablicy", "get each element of the row": "pobierz każdy element wiersz", "get end iterator of underlying C-style string": "pobierz iterator końcowy bazowego ciągu w stylu C", "get input string from user": "pobierz ciąg wejściowy od użytkownika", "get integer value from user's keyboard": "pobierz wartość całkowitą z klawiatury użytkownika", "get length of first dimension (rows)": "pobierz długość pierwszego wymiaru (wiersze)", "get length of second dimension (cols)": "pobierz długość drugiego wymiaru (cols)", "get length of second dimension (cols), undefined behavior if length of first dimension is zero!": "pobierz długość drugiego wymiaru (cols), niezdefiniowane zachowanie, jeśli długość pierwszego wymiaru wynosi zero!", "get number from keyboard and store it in variable x": "pobierz liczbę z klawiatury i zapisz ją w zmiennej x", "get number of chars in name (including spaces)": "pobierz liczbę znaków w nazwie (ze spacjami)", "get one more char from the user": "pobierz jeszcze jeden znak od użytkownika", "get one more char from the user (waits for user to press enter)": "pobierz jeszcze jeden znak od użytkownika (czeka, aż użytkownik naciśnie enter)", "get our IntList object, then call overloaded operator[]": "pobierz nasz obiekt IntList, a następnie wywołaj przeciążony operator[]", "get shared_ptr to Ricky's partner": "pobierz wspólna_ptr do partnera Ricky'ego", "get the entire line, including spaces": "pobierz całą linię ze spacjami", "get the value": "pobierz wartość", "get two numbers and store in variable x and y respectively": "pobierz dwie liczby i zapisz odpowiednio w zmiennych x i y", "getName() returns the user-entered string as a temporary std::string": "getName() zwraca wprowadzony przez użytkownika ciąg znaków jako tymczasowy std::string", "getNumber returns an int by value": "getNumber zwraca liczbę int przez wartość", "getSinCos will return the sin and cos in variables sin and cos": "getSinCos zwróci sin i cos w zmiennych sin i cos", "gets tower height from user and returns it": "pobierze wysokość wieży od użytkownika i zwróci ją", "getter for day": "getSinCos na dzień", "getter for month": "getter na miesiąc", "getter for year": "getter na rok", "getter returns by const reference": "getter zwraca według stałej referencji", "getter returns by value": "getter zwraca według wartość", "give this class some initial state for this example": "nadaj tej klasie pewien stan początkowy dla tego przykładu", "global variables can be seen and used everywhere in the file": "zmienne globalne mogą być widoczne i używane w całym pliku", "go to next iteration": "przejdź do następnej iteracji", "goo() is now constexpr": "goo() jest teraz constexpr", "good: we're explicitly telling the compiler this narrowing conversion is intentional": "dobry: wyraźnie mówimy kompilatorowi, że ta zawężająca konwersja jest zamierzona", "grab the next value from the id generator": "pobierz następną wartość z generator id", "greater(5, 6) may be evaluated at compile-time or runtime": "większy(5, 6) może zostać oceniony w czasie kompilacji lub w czasie wykonywania", "greater(5, 6) must be evaluated at compile-time": "większy(5, 6) musi zostać oceniony w czasie kompilacji", "guess == number, so the user won": "zgadnij == liczba, więc użytkownik wygrał", "h/t to potterman28wxcv for a variant of this code": "h/t do potterman28wxcv dla wariantu tego kodu", "h/t to reader Chris for this solution": "h/t do czytelnika Chrisa za to rozwiązanie", "h/t to reader David Pinheiro for simplifying this": "h/t do czytnika Davida Pinheiro za uproszczenie tego", "h/t to reader Donlod for this solution": "h/t do czytnika Donloda za to rozwiązanie", "h/t to reader EmtyC for this version": "h/t do czytnika EmtyC dla tej wersji", "h/t to reader Gapo for this solution": "h/t do czytnika Gapo za to rozwiązanie", "h/t to reader Olivier for the initial version of the function": "h/t do czytnika Oliviera za wstępną wersję funkcji", "h/t to reader Olivier for this updated solution": "h/t czytelnikowi Olivierowi za zaktualizowane rozwiązanie", "h/t to reader Waldo for an early version of this example": "h/t czytelnikowi Waldo za wczesną wersję tego przykładu", "h/t to reader Waldo for suggesting this quiz": "h/t czytelnikowi Waldo za zasugerowanie tego quizu", "h/t to reader Waldo for this example": "h/t czytelnikowi Waldo za ten przykład", "h/t to reader yellowEmu for the first draft of this program": "h/t czytelnikowi YellowEmu za pierwszą wersję tego programu", "h/t to reader yellowEmu for the idea of adding a counter": "h/t czytelnikowi YellowEmu za pomysł dodania licznik", "handle case where new returned null": "obsługa przypadku, w którym new zwróciło wartość null", "handle error somehow (e.g. throw an exception)": "obsługa w jakiś sposób błędu (np. zgłoszenie wyjątku)", "handle exception of type double": "obsługa wyjątku typu double", "handle invalid index here": "obsługa tutaj nieprawidłowego indeksu", "handle our own string": "obsługa własnego ciągu znaków", "harder to read": "trudniejsze do odczytania", "harder to read (where is the name of the function in this mess?)": "trudniejsze do odczytania (gdzie jest nazwa funkcji w tym bałaganie?)", "has an Employee parameter": "posiada parametr Pracownik", "has external linkage, can be accessed by other files": "posiada zewnętrzne powiązanie, można uzyskać do niego dostęp z innych plików", "has internal linkage, is accessible only within this file": "posiada wewnętrzne powiązanie, jest dostępny tylko w tym pliku", "has side effect of assigning 5 to x, evaluates to x": "ma efekt uboczny w postaci przypisania 5 do x, ocenia się na x", "has side effect of printing value of x to console, evaluates to std::cout": "ma efekt uboczny w postaci wypisywania wartości x do konsoli, ocenia się std::cout", "has static duration, destroyed at end of program": "ma statyczny czas trwania, niszczony na końcu programu", "height can only be const (not constexpr) because its initializer is not a constant expression": "wysokość może mieć tylko stałą (nie constexpr), ponieważ jej inicjator nie jest wyrażeniem stałym", "here": "tutaj", "here are our member variables": "tutaj są nasze zmienne składowe", "here is our loop-statement": "tutaj jest nasza instrukcja pętli", "here u (initial velocity) = 0, so (u * t) = 0": "tutaj u (prędkość początkowa) = 0, więc (u * t) = 0", "here's a trivial example": "oto trywialny przykład", "here's a trivial throw statement": "oto trywialna instrukcja rzutu", "here's int value 3": "tutaj wartość int 3", "here's our constructor function that takes two initializers": "oto nasza funkcja konstruktora, która pobiera dwa inicjatory", "here's our destructor": "oto nasza destructor", "here's our factional part": "Oto nasza część frakcyjna", "here's our float variable": "Oto nasza zmienna zmiennoprzecinkowa", "here's our lambda, no capture clause": "Oto nasza lambda, bez klauzuli przechwytywania", "here's our member initialization list": "Oto nasza lista inicjowania członków", "here's our non-fractional part": "Oto nasza część nieułamkowa", "here's our private access specifier": "Oto nasz prywatny dostęp specyfikator", "here's our public access specifier": "oto nasz specyfikator dostępu publicznego", "here's the outer block apples": "oto zewnętrzne jabłka bloku", "hex for 0000 0001": "szesnastkowe dla 0000 0001", "hex for 0000 0010": "szesnastkowe dla 0000 0010", "hex for 0000 0100": "szesnastkowe dla 0000 0100", "hex for 0000 1000": "szesnastkowe dla 0000 1000", "hex for 0001 0000": "hex dla 0001 0000", "hex for 0010 0000": "hex dla 0010 0000", "hex for 0100 0000": "hex dla 0100 0000", "hex for 1000 0000": "hex dla 1000 0000", "hides the global variable value": "ukrywa zmienną globalną wartość", "hides the global variable value (wherever local variable value is in scope)": "ukrywa wartość zmiennej globalnej (gdziekolwiek w zakresie znajduje się wartość zmiennej lokalnej)", "hold the first 5 prime numbers": "przechowuje pierwsze 5 liczb pierwszych", "hold the first 5 prime numbers (as int)": "przechowuje pierwsze 5 liczb pierwszych (jako int)", "holds the maximum value seen so far": "przechowuje maksymalną wartość zaobserwowaną do tej pory", "holds the minimum value seen so far": "przechowuje minimalną wartość zaobserwowaną do tej pory", "how are these used?": "jak to jest używane?", "how do we access elements from m_list?": "jak uzyskać dostęp do elementów z m_list?", "how do we initialize joe.id, joe.age, and joe.wage?": "jak zainicjalizować joe.id, joe.age i joe.wage?", "how do we print the Derived object's name here, having only a Base pointer?": "jak wydrukować tutaj nazwę obiektu Derived, mając tylko wskaźnik bazowy?", "how many aces worth 11 points the player has": "ile asów wartych 11 punktów ma gracz", "however, if we cast our void pointer to an int pointer...": "jednak jeśli rzucimy nasz wskaźnik void na wskaźnik int...", "however, otherPtr is still a dangling pointer!": "jednakże, otherPtr jest nadal wskaźnikiem wiszącym!", "i assigned value": "przypisano mi wartość", "i can still be accessed here": "nadal mogę tu uzyskać dostęp", "i created and initialized here": "tutaj utworzyłem i zainicjowałem", "i defined outside loop": "zdefiniowałem pętlę zewnętrzną", "i enters scope here": "tutaj wprowadzam zakres", "i is an int, so x will be deduced as an int": "i jest int, więc x zostanie wydedukowane jako int", "id1 is a normal variable now and receives a copy of the value returned by reference from getNextId()": "id1 jest normalną zmienną teraz i otrzymuje kopię wartości zwróconej przez referencję z getNextId()", "id1 is a reference": "id1 jest referencją", "id2 is a normal variable now and receives a copy of the value returned by reference from getNextId()": "id2 jest teraz normalną zmienną i otrzymuje kopię wartości zwróconej przez referencję z getNextId()", "id2 is a reference": "id2 jest referencją", "identifier cout is qualified by namespace std": "identyfikator cout jest kwalifikowany przez przestrzeń nazw std", "identifier foo is qualified by the global namespace": "identifier foo jest kwalifikowany przez globalną przestrzeń nazw", "if all extractions succeeded": "jeśli wszystkie wyodrębnienia powiodły się", "if any extractable input is negative": "jeśli jakiekolwiek możliwe do wyodrębnienia dane wejściowe są ujemne", "if array[midpoint] < target, then we know the number must be in the upper half of the array": "jeśli tablica[punkt środkowy] < cel, to wiemy, że liczba musi znajdować się w górnej połowie tablicy", "if array[midpoint] > target, then we know the number must be in the lower half of the array": "jeśli tablica[punkt środkowy] > cel, to wiemy, że liczba musi znajdować się w dolnej połowie tablicy", "if c is 'a'": "jeśli c jest 'a'", "if conversion fails, set myint to a default value": "jeśli konwersja się nie powiedzie, ustaw myint na wartość domyślną", "if data exists in the current string, delete it": "jeśli w bieżącym ciągu istnieją dane, usuń je", "if dealer busted": "jeśli krupier odpadł", "if empty spot": "jeśli puste miejsce", "if evaluating in constant context": "jeśli ocena w stałym kontekście", "if exp is odd": "jeśli exp jest nieparzysty", "if foo() is resolved at compile-time, then `goo(b)` can also be resolved at compile-time": "jeśli foo() zostanie rozwiązane na w czasie kompilacji, to `goo(b)` można również rozwiązać w czasie kompilacji", "if one digit number": "jeśli liczba jednocyfrowa", "if option4 is set, do something": "jeśli ustawiona jest opcja 4, zrób coś", "if our array has elements of type T, our average should have type T too": "jeśli nasza tablica zawiera elementy typu T, nasza średnia też powinna mieć typ T", "if our denominator is semantically invalid": "jeśli nasz mianownik jest semantycznie nieprawidłowy", "if player busted": "jeśli gracz przerwany", "if ptr is a null pointer, early return back to the caller": "jeśli ptr jest wskaźnikiem zerowym, wcześniej wróć z powrotem do wywołującego", "if ptr is not a null pointer": "jeśli ptr nie jest wskaźnikiem zerowym", "if stack.size == 0": "jeśli rozmiar stosu == 0", "if the array is already the right length, we're done": "jeśli tablica ma już odpowiednią długość, koniec", "if the const is on the left side of the *, the const belongs to the value": "jeśli const znajduje się po lewej stronie *, const należy do wartość", "if the const is on the right side of the *, the const belongs to the pointer": "jeśli const znajduje się po prawej stronie *, const należy do wskaźnika", "if the distance between a and b is less than or equal to absEpsilon, then a and b are \"close enough\"": "jeśli odległość między a i b jest mniejsza lub równa absEpsilon, to a i b są „wystarczająco blisko”", "if the function returned a value": "jeśli funkcja zwróciła wartość", "if the left bit was a 1": "jeśli lewy bit wynosił 1", "if the loop variable is divisible by 10, print a newline": "jeśli zmienna pętli jest podzielna przez 10, wydrukuj znak nowej linii", "if the number is divisible by 4, skip this iteration": "jeśli liczba jest podzielna przez 4, pomiń tę iterację", "if the number is not divisible by 4...": "jeśli liczba nie jest podzielna przez 4...", "if the previous extraction failed": "jeśli poprzednie wyodrębnienie nie powiodło się", "if the shirt is blue": "jeśli koszulka jest niebieska", "if the user did not enter 2, 3, 5, 7, the digit must not be prime": "jeśli użytkownik nie wpisał 2, 3, 5, 7, cyfra nie może być prime", "if the user did not pass in a supported operation": "jeśli użytkownik nie przekazał obsługiwanej operacji", "if the user entered 2": "jeśli użytkownik wprowadził 2", "if the user entered an invalid character": "jeśli użytkownik wprowadził nieprawidłowy znak", "if the user lost": "jeśli użytkownik zgubił", "if two digit number": "jeśli liczba dwucyfrowa", "if user did it wrong": "jeśli użytkownik zrobił to źle", "if user entered 2 or 3 or 5 or 7 the digit is prime": "jeśli użytkownik wprowadził 2 lub 3 lub 5 lub 7 cyfra jest liczba pierwsza", "if user entered 2, the digit is prime": "jeśli użytkownik wpisał 2, cyfra jest pierwsza", "if user entered 3, the digit is prime": "jeśli użytkownik wpisał 3, cyfra jest pierwsza", "if user entered 5, the digit is prime": "jeśli użytkownik wpisał 5, cyfra jest pierwsza", "if user entered 7, the digit is prime": "jeśli użytkownik wpisał 7, cyfra jest pierwsza", "if v.size == 0": "jeśli v.size == 0", "if we cleared out more than one additional character": "jeśli wykasowaliśmy więcej niż jedno dodatkowe znak", "if we declared y here, immediately before its actual first use...": "jeśli zadeklarowaliśmy y tutaj, bezpośrednio przed jego pierwszym pierwszym użyciem...", "if we didn't find any divisors, then x must be prime": "jeśli nie znaleźliśmy żadnych dzielników, to x musi być liczbą pierwszą", "if we found a match": "jeśli znaleźliśmy dopasowanie", "if we reached this point, we can assume ptr is valid": "jeśli doszliśmy do tego punktu, możemy założyć, że ptr jest poprawny", "if we rename this": "jeśli zmienimy nazwę tego", "if we were to perform indirection through the result, then we'd just print the single char that ptr is pointing to": "jeśli mielibyśmy wykonać pośrednie przez wyniku, to po prostu wypiszemy pojedynczy znak, na który wskazuje ptr", "if we're in release node": "jeśli jesteśmy w węźle wydania", "if we're not in failure mode": "jeśli nie jesteśmy w trybie awarii", "if we're turning a bit off": "jeśli trochę się wyłączymy", "if x % 2 == 0, 2 divides evenly into our number, which means it must be an even number": "jeśli x % 2 == 0, 2 dzieli się równo przez naszą liczbę, co oznacza, że musi to być liczba parzysta", "if x is even and y is odd, x goes first (no swap needed)": "jeśli x jest parzyste, a y jest nieparzyste, x jest pierwsze (bez konieczności zamiany)", "if x is evenly divisible": "jeśli x jest równomiernie podzielne", "if x is negative, 0, or 1 then the number is not prime": "jeśli x jest ujemne, 0 lub 1, to liczba nie jest pierwsza", "if x is odd and y is even, y goes first (swap needed)": "jeśli x jest nieparzyste, a y jest parzyste, y jest pierwsze (wymagana zamiana)", "if x is semantically invalid": "jeśli x jest semantyczne nieprawidłowy", "ifstream is used for reading files": "ifstream jest używany do odczytu plików", "ignore any characters in the input buffer until we find a newline": "zignoruj wszystkie znaki w buforze wejściowym, dopóki nie znajdziemy znaku nowej linii", "ignore any characters in the input buffer until we find an enter character": "zignoruj wszystkie znaki w buforze wejściowym, dopóki nie znajdziemy znaku Enter", "ignore any extra characters in the input buffer (regardless of whether we had an error or not)": "zignoruj wszelkie dodatkowe znaki w buforze wejściowym (niezależnie od tego, czy wystąpił błąd, czy nie)", "ignore the & for now, we'll cover these in a future lesson": "zignoruj & na razie, omówimy to w przyszłości lekcja", "ignore the constexpr here for this example": "zignoruj constexpr w tym przykładzie", "ignore this for now": "zignoruj to na razie", "illegal: initialization is not allowed before the case labels": "illegal: inicjalizacja nie jest dozwolona przed etykietami przypadków", "illegal: initialization is not allowed if subsequent cases exist": "illegal: inicjalizacja nie jest dozwolona, jeśli istnieją kolejne przypadki", "implement this function as a friend of class Vector3d": "zaimplementuj tę funkcję jako przyjaciel klasy Vector3d", "implement this iteratively": "zaimplementuj to iteracyjnie", "implement this recursively": "zaimplementuj to rekurencyjnie", "implementation-defined prior to C++20, -1 as of C++20": "implementacja zdefiniowana przed C++20, -1 od C++20", "implicit conversion from Dollars to Cents okay because its not marked as explicit": "niejawna konwersja z dolarów na centy w porządku, ponieważ nie jest oznaczona jako jawna", "implicit conversion to Boolean": "ukryta konwersja na wartość logiczną", "implicit conversion to std::string": "ukryta konwersja na std::string", "implicit use of this": "niejawne użycie tego", "implicitly iterates over v": "niejawnie iteruje po v", "import template definition for max<T>(T, T)": "importuj definicję szablonu dla max<T>(T, T)", "import the function template definition": "importuj definicję szablonu funkcji", "imports the declaration of std::cout": "importuj deklarację std::cout", "imports the declaration of std::cout into the global scope": "importuj deklarację std::cout do zasięg globalny", "in C++20, prefer std::ssize()": "w C++20, preferuj std::ssize()", "in C++23, you can uncomment these since multidimensional operator[] is supported": "w C++23, możesz je odkomentować, ponieważ wielowymiarowy operator[] jest obsługiwany", "in debug mode, compile in a catch that will never be hit (for syntactic reasons)": "w trybie debugowania, skompiluj w catch, który nigdy nie zostanie trafiony (ze względów składniowych)", "in str.": "w str.", "in the smaller of the two arrays.": "w mniejszym z dwóch tablice.", "include a copy of each constant in this file": "dołącz kopię każdej stałej w tym pliku", "include all the forward declarations": "dołącz wszystkie deklaracje forward", "include our Fraction definition in this code file": "dołącz naszą definicję ułamka do tego pliku kodu", "including this one, causing a compilation error": "w tym tę, powodując błąd kompilacji", "incorrect (typedef name first)": "niepoprawny (najpierw wpisano nazwę)", "incorrect: if value is 0, or if 1": "niepoprawnie: jeśli wartość wynosi 0 lub jeśli 1", "incorrect: ptr1 is a pointer to an int, but ptr2 is just a plain int!": "niepoprawnie: ptr1 to wskaźnik do int, ale ptr2 to zwykła int!", "increment by 2 each iteration": "zwiększanie o 2 każdy iteracja", "increment the loop counter": "zwiększ licznik pętli", "increment x and y, evaluates to the right operand": "zwiększ x i y, oblicz do prawego argumentu", "increments local value, not global value": "zwiększa wartość lokalną, a nie globalną", "increments x to 1": "zwiększa x do 1", "increments x to 2": "zwiększa x do 2", "indented from label (misleading)": "wcięcie z etykiety (wprowadza w błąd)", "indented from switch block": "wcięcie z bloku przełączników", "index 7 is out of bounds!": "indeks 7 jest poza zakresem!", "index from 0 to length-1": "indeks od 0 do długości-1", "index is signed": "indeks jest podpisany", "index is unsigned": "indeks jest bez znaku", "index needs to be an int, not a std::size_t, otherwise we won't be able to detect if the user passes in a negative index": "indeks musi być int, a nie std::size_t, w przeciwnym razie możemy nie będzie w stanie wykryć, czy użytkownik przekazał ujemny indeks", "index using a signed type": "indeks przy użyciu typu ze znakiem", "index with y (row) first, then x (col)": "indeks z najpierw y (wiersz), a następnie x (col)", "infinite loop": "nieskończona pętla", "init() evaluated in compile-time context": "init() oceniana w kontekście czasu kompilacji", "initialize 8-bit integral type with value 65": "zainicjuj 8-bitowy typ całkowity wartością 65", "initialize a fixed array before C++11": "zainicjuj stałą tablicę przed C++11", "initialize a fixed array in C++11": "zainicjuj stałą tablicę w C++11", "initialize const variable using non-const value": "zainicjuj zmienną stałą przy użyciu wartości innej niż stała", "initialize floating point variable with int 3": "zainicjuj zmienną zmiennoprzecinkową za pomocą int 3", "initialize myInt with value 65": "zainicjuj myInt wartością 65", "initialize name with string literal \"Alex\"": "zainicjuj nazwę za pomocą literał łańcuchowy \"Alex\"", "initialize num with the return value of getValueFromUser()": "zainicjuj num wartością zwracaną przez getValueFromUser()", "initialize num with the return value of getValueFromUserUB()": "zainicjuj num wartością zwracaną przez getValueFromUserUB()", "initialize our Mersenne Twister with the std::seed_seq": "zainicjuj nasz Mersenne Twister za pomocą std::seed_seq", "initialize our function pointer with function print": "zainicjuj nasz wskaźnik funkcji za pomocą funkcji print", "initialize ptr with address of v1": "zainicjuj ptr adresem v1", "initialize ptr with address of variable x": "zainicjuj ptr adresem zmiennej x", "initialize static variable at point of definition": "zainicjuj zmienną statyczną w punkcie definicji", "initialize sum to 0 at start of program": "zainicjuj sumę do 0 na początku programu", "initialize using aggregate initialization": "zainicjuj za pomocą inicjalizacji agregatowej", "initialize variable a with literal value 2": "zainicjuj zmienną a wartością literalną 2", "initialize variable b with computed value 5": "zainicjuj zmienną b obliczoną wartością 5", "initialize variable c with computed value 10": "zainicjuj zmienną c obliczoną wartością 10", "initialize variable d with variable value 5": "zainicjuj zmienną d wartością zmiennej 5", "initialize variable e with function return value 5": "zainicjuj zmienną e wartością zwracaną przez funkcję 5", "initialize with C-style string literal": "zainicjuj za pomocą literału łańcuchowego w stylu C", "initialize with a value": "zainicjuj wartością", "initialize with code point for '5' (stored as integer 53)": "zainicjuj punktem kodowym dla „5” (przechowywanym jako liczba całkowita 53)", "initialize with code point for 'a' (stored as integer 97) (preferred)": "zainicjuj punktem kodowym dla „a” (zapisywanym jako liczba całkowita 97) (preferowane)", "initialize with integer 5 (stored as integer 5)": "zainicjuj liczbą całkowitą 5 (zapisywanym jako liczba całkowita 5)", "initialize with integer 97 ('a') (not preferred)": "zainicjuj liczbą całkowitą 97 („a”) (niepreferowane)", "initialize with no value": "zainicjuj bez wartości", "initialize with std::string": "zainicjuj za pomocą std::string", "initialize with std::string_view": "zainicjuj za pomocą std::string_view", "initializer after equals sign (copy initialization)": "inicjator po znaku równości (skopiuj inicjalizacja)", "initializer for C-style array member with implementation_defined_name": "inicjator elementu tablicy w stylu C z nazwą_definiowaną_implementacją", "initializer for array element 0": "inicjator elementu tablicy 0", "initializer for array element 1": "inicjator elementu tablicy 1", "initializer for array element 2": "inicjator elementu tablicy 2", "initializer for houses": "inicjator dla domów", "initializer in braces (direct list initialization)": "inicjator w nawiasach klamrowych (lista bezpośrednia inicjalizacja)", "initializer in braces after equals sign (copy list initialization)": "inicjator w nawiasach po znaku równości (inicjalizacja kopiowania listy)", "initializer in parentheses (direct initialization)": "inicjator w nawiasach (inicjalizacja bezpośrednia)", "initializer is empty braces (value initialization)": "inicjator w pustych nawiasach (inicjalizacja wartości)", "initially created empty": "początkowo utworzony pusty", "inline keyword means this function is an inline function": "słowo kluczowe inline oznacza, że ta funkcja jest funkcją wbudowaną", "inner destroyed here": "zniszczona wewnętrznie tutaj", "inner if statement": "wewnętrzna instrukcja if", "inner if-statement": "wewnętrzna instrukcja if", "inner loop is columns / x": "wewnętrzna pętla to kolumny / x", "inner loop on all numbers": "wewnętrzna pętla na wszystkich liczbach", "inner loops between 1 and outer": "wewnętrzne pętle między 1 a zewnętrzną", "input an integer": "wprowadzenie liczby całkowitej", "inputs are constexpr values": "wejścia to constexpr wartości", "insert \"en garde!\" into the stringstream": "wstaw „en garde!” do strumienia stringów", "insert a string of numbers into the stream": "wstaw ciąg liczb do strumienia", "insert at end of array": "wstaw na końcu tablicy", "insert at front of array": "wstaw na początek tablicy", "insert substring of sInsert from index [3,7) into sString at index 2": "wstaw podciąg sWstaw z indeksu [3,7) do sString pod indeksem 2", "instantiate an object of the inner class": "utwórz instancję obiektu wewnętrznego klasa", "instantiate other templates here": "Tworzy tutaj instancję innych szablonów", "instantiates Pair<double> and creates object p2": "tworzy instancję Pair<double> i tworzy obiekt p2", "instantiates Pair<int> and creates object p1": "tworzy instancję Pair<int> i tworzy obiekt p1", "instantiates Storage<double*> from partially specialized class": "tworzy instancję Storage<double*> z częściowo wyspecjalizowanej klasy", "instantiates and calls add<double, int>()": "tworzy instancję i wywołuje add<double, int>()", "instantiates and calls add<double>()": "tworzy instancje i wywołuje add<double>()", "instantiates and calls add<int, int, int>()": "tworzy instancje i wywołuje add<int, int, int>()", "instantiates and calls function max<double>(double, double)": "tworzy instancje i wywołuje funkcję max<double>(double, double)", "instantiates and calls function max<int>(int, int)": "tworzy instancje i wywołuje funkcję max<int>(int, int)", "instantiates and calls max<double>(double, double)": "tworzy instancje i wywołuje max<double>(double, double)", "instantiates and calls max<int>(int, int)": "tworzy instancje i wywołuje max<int>(int, int)", "instead of this": "zamiast tego", "int and main must be whitespace separated": "int i main muszą być oddzielone spacjami", "int and x must be whitespace separated": "int i x muszą być oddzielone spacjami", "int can be numerically converted to unsigned int or to float": "int można konwertować numerycznie na unsigned int lub float", "int cast to a double": "int rzutowany na double", "int is the return type": "int jest typem zwracanym", "int midpoint{ min + ((max-min) / 2) }; // this way of calculating midpoint avoids overflow": "int punkt środkowy{ min + ((max-min) / 2) }; // ten sposób obliczania punktu środkowego pozwala uniknąć przepełnienia", "int non-type template parameter": "int parametr inny niż typ szablonu", "int parameter means this is postfix operator++": "parametr int oznacza, że jest to operator postfix++", "int parameter means this is postfix operator--": "parametr int oznacza, że jest to operator postfix--", "int value 3 implicitly converted to type double": "int wartość 3 niejawnie konwertowana na typ double", "int value 3 implicitly converted to type long": "int wartość 3 niejawnie konwertowana na typ long", "int value 5 implicitly converted to type bool": "int wartość 5 niejawnie przekonwertowany na typ bool", "int value 6 implicitly converted to type double": "int wartość 6 niejawnie przekonwertowany na typ double", "int& is a reference to a int": "int& jest odwołaniem do int", "int8_t is usually a typedef for signed char": "int8_t jest zwykle typedef dla podpisanego char", "intentional fallthrough -- note the semicolon to indicate the null statement": "celowe przejście -- zwróć uwagę na średnik wskazujący instrukcję zerową", "intentionally non-constexpr for this example": "w tym przypadku celowo nieconstexpr przykład", "intentionally overflow to invoke wraparound behavior": "celowe przepełnienie w celu wywołania zachowania zawijającego", "ints are usually 4 bytes": "intły mają zwykle 4 bajty", "invalid (whitespace not allowed)": "nieprawidłowe (niedozwolone białe znaki)", "invalid: conversion of double to int is narrowing conversion, disallowed by list initialization": "nieprawidłowe: konwersja double na int zawęża konwersję, niedozwolona przez inicjalizację listy", "invalid: non-const lvalue reference can't bind to a non-modifiable lvalue": "nieprawidłowe: odwołanie do wartości innej niż stała nie może zostać powiązane z wartością niemodyfikowalną", "invalid: non-const lvalue reference can't bind to an rvalue": "nieprawidłowe: odwołanie do wartości innej niż stała nie może zostać powiązane z wartością", "invalid: non-const lvalue reference can't bind to rvalue (result of converting x to double)": "nieprawidłowe: odwołanie do wartości innej niż stała nie może zostać powiązane z wartością (wynik konwersji x na wartość double)", "invalid: will produce compilation error": "nieprawidłowe: spowoduje kompilację błąd", "invoke both count and the copy": "wywołuje zarówno licznik, jak i kopię", "invoke printValue indirectly through the function pointer": "wywołuje printValue pośrednio poprzez wskaźnik funkcji", "invokes copy assignment": "wywołuje przypisanie kopii", "invokes copy constructor": "wywołuje konstruktor kopiujący", "is the same as": "jest tym samym, co", "is this foo a user-defined function, or part of the NS library?": "czy to foo jest funkcją zdefiniowaną przez użytkownika, czy częścią biblioteki NS?", "isEven is false": "isEven jest false", "isEven is true": "isEven ma wartość true", "issue on this line": "problem w tej linii", "it can access the private members of Accumulator": "może uzyskać dostęp do prywatnych elementów akumulatora", "it is bad coding style to nest if statements this way": "zagnieżdżanie instrukcji if w ten sposób jest złym stylem", "it to the end of our vector.  Then return the grade.": "na końcu naszego wektora. Następnie zwróć ocenę.", "it works!": "działa!", "it's okay to do this": "można to zrobić", "iterate from `begin` up to (but excluding) `end`": "iteruj od `początku` do (ale z wyłączeniem) `końca`", "iterate from begin up to (but excluding) end": "iteruj od początku do (ale z wyłączeniem) końca", "iterate over array fibonacci and copy each value into `num`": "iteruj po tablicy fibonacci i skopiuj każdą wartość do `num`", "iterate through all the elements": "iteruj po wszystkich elementach", "iteration is 0 based, but counting iterations is 1-based.  So add 1 here to adjust.": "iteracja opiera się na 0, ale liczenie iteracji opiera się na 1. Zatem dodaj tutaj 1, aby dostosować.", "joe exists until end of function": "joe istnieje do końca funkcji", "joe.wage will be value-initialized to 0.0": "joe.wage zostanie zainicjalizowana wartością 0,0", "joe.whatever will be value-initialized to 0.0": "joe.cokolwiek zostanie zainicjalizowana wartością 0,0", "jump forward; statement label 'end' is visible here due to it having function scope": "przeskocz do przodu; etykieta instrukcji 'end' jest tutaj widoczna, ponieważ ma zakres funkcji", "jump over value 10": "przeskok o wartość 10", "jump to address 0x002717f0": "skok do adresu 0x002717f0", "jump to end of loop body": "skok na koniec treści pętli", "jump to the end of the switch block": "skok na koniec bloku przełączników", "jumps over the print statement and doesn't print anything": "przeskakuje instrukcję print i nie jest drukowany cokolwiek", "just return x + y directly": "po prostu zwróć bezpośrednio x + y", "just to prove it works": "tylko żeby udowodnić, że to działa", "keep track of whether the leftmost bit was a 1": "śledź, czy skrajny lewy bit był argumentem o wartości 1", "l-value argument calls l-value version of function": "l-wartość wywołuje wersję funkcji o l-wartości", "l-value arguments will select this function": "argumenty o wartości l wybiorą tę funkcję", "l-value reference initialized with l-value x": "odniesienie do wartości l zainicjowane wartością l x", "l-value references": "odniesienia do l-wartości", "lambda object stored in a std::function": "obiekt lambda przechowywany w std::function", "largest 16-bit unsigned value possible": "największa możliwa 16-bitowa wartość bez znaku", "largestIndex is the index of the largest element we've encountered so far.": "largestIndex to indeks największego elementu, jaki napotkaliśmy do tej pory.", "length is a runtime constant": "długość to stała czasu wykonania", "length is initially 3": "długość jest początkowo 3", "length is initially 5": "długość wynosi początkowo 5", "let compiler determine the return type of unsigned short + char": "niech kompilator określi typ zwracany unsigned short + char", "let the initializer list set length of the array": "niech lista inicjatorów ustawi długość tablicy", "let's hope their name is less than 25 chars!": "miejmy nadzieję, że ich nazwa będzie krótsza niż 25 znaków!", "let's hope there are less than 500 records!": "miejmy nadzieję, że rekordów będzie mniej niż 500!", "let's write a # over the vowel": "piszmy # nad samogłoską", "likely a user-defined function": "prawdopodobnie funkcja zdefiniowana przez użytkownika", "list initialization using braced list (preferred)": "inicjalizacja listy przy użyciu listy w nawiasach klamrowych (preferowana)", "list initialized with specific value": "lista zainicjowana określoną wartością", "local value is destroyed": "wartość lokalna jest niszczona", "location because we don't want to move the file pointer.": "lokalizacja, ponieważ nie chcemy przesuwać wskaźnika pliku.", "long does not match int or double, so what happens?": "long nie pasuje do int ani double, więc co z tego się dzieje?", "long doubles are usually 8 or 12 bytes": "długie dublety mają zwykle 8 lub 12 bajtów", "loop between 1 and outer": "pętla między 1 a zewnętrzną", "loop between outer and 1": "pętla między zewnętrzną a 1", "loop until user enters valid input": "pętla do momentu wprowadzenia przez użytkownika prawidłowego wejścia", "loop until user terminates": "pętla do zakończenia przez użytkownika", "m/s^2 -- gravity is light on this planet": "m/s^2 -- grawitacja jest na tym lekka planet", "m_data is a pointer, so we need to deep copy it if it is non-null": "m_data jest wskaźnikiem, więc musimy go głęboko skopiować, jeśli nie ma wartości null", "m_data not declared yet": "m_data nie została jeszcze zadeklarowana", "m_ptr is now sharing the Resource that contains it": "m_ptr udostępnia teraz zasób, który go zawiera", "main does not need to pass anything": "main nie musi przejść wszystko", "main must pass x as an argument": "main musi przekazać x jako argument", "main's x and y are usable within this function only": "x i y maina można używać tylko w tej funkcji", "main's x is created, initialized, and enters scope here": "x maina jest tworzone, inicjowane i wchodzi tutaj w zakres", "main's y and x go out of scope and are destroyed here": "y i x maina wychodzą poza zakres i są tutaj niszczone", "main's y is created, initialized, and enters scope here": "y maina są tworzone, inicjowane i wchodzą w zakres tutaj", "make ALL getValue functions private": "uczyń WSZYSTKIE funkcje getValue prywatnymi", "make VectPairSI an alias for this crazy type": "ustaw VectPairSI aliasem dla tego szalonego typu", "make a virtual destructor in case we delete an IErrorLog pointer, so the proper derived destructor is called": "utwórz wirtualny destruktor na wypadek, gdybyśmy usunęli wskaźnik IErrorLog, aby wywołany został odpowiedni destruktor pochodny", "make all Base::print() functions eligible for overload resolution": "uprawnij wszystkie funkcje Base::print() do rozpoznawania przeciążenia", "make another std::shared_ptr pointing to the same thing": "ustaw kolejny std::shared_ptr wskazujący na to samo", "make sure T is an integral type": "upewnij się, że T jest typem całkowitym", "make sure age is positive": "upewnij się, że wiek jest dodatni", "make sure all data is sent before object is destroyed": "upewnij się, że wszystkie dane zostaną wysłane przed zniszczeniem obiektu", "make sure array exists": "upewnij się, że tablica istnieje", "make sure d is non-null": "upewnij się, że d nie jest null", "make sure fcnPtr isn't a null pointer": "upewnij się, że fcnPtr nie jest wskaźnikiem zerowym", "make sure our inventory has the correct number of initializers": "upewnij się, że w naszym inwentarzu jest poprawna liczba inicjatorów", "make sure sort works when values don't need to be swapped": "upewnij się, że sortowanie działa, gdy wartości nie wymagają zamiany", "make sure sort works when values need to be swapped": "upewnij się, że sortowanie działa, gdy trzeba zamienić wartości", "make sure source isn't a null string": "upewnij się upewnij się, że źródło nie jest ciągiem pustym", "make sure the source no longer owns the pointer": "upewnij się, że źródło nie jest już właścicielem wskaźnika", "make sure we deallocate any pointer the destination is already holding first": "upewnij się, że najpierw zwolnimy każdy wskaźnik, który miejsce docelowe już posiada", "make sure we handle single digit decimal": "upewnij się, że obsługujemy jednocyfrowy zapis dziesiętny", "make the compiler think we're assigning a value to this variable": "spraw, aby kompilator myślał, że przypisujemy wartość do tej zmiennej", "makes a copy of a dangling reference": "tworzy kopię wiszącego reference", "makes copy of referenced member": "tworzy kopię elementu, do którego się odwołuje", "makes copy of s_itemID, increments the real s_itemID, then returns the value in the copy": "tworzy kopię s_itemID, zwiększa rzeczywisty s_itemID, a następnie zwraca wartość w kopii", "makes it obvious foo is modified, but another copy made here": "pokazuje, że foo zostało zmodyfikowane, ale kolejna kopia wykonana tutaj", "makes std::cout accessible as \"cout\"": "sprawia, że std::cout jest dostępny jako „cout”", "mark this function as inaccessible": "oznacz tę funkcję jako inaccessible", "matches print(Pair<double, int>)": "dopasowuje print(Pair<double, int>)", "matches print(Point)": "dopasowuje print(Point)", "matches someFcn(float, double) -- the float is promoted to a double": "dopasowuje SomeFcn(float, double) -- float jest promowany do double", "matches someFcn(int, double) -- the float is promoted to a double": "dopasowuje SomeFcn(int, double) -- float jest promowany do double", "max enters scope here": "max wchodzi w zakres tutaj", "max is the index of the upper bounds of the array we're searching.": "max jest indeksem górnych granic tablicy, którą przeszukujemy.", "max, y, and x leave scope here": "max, y i x pozostawiają tutaj zakres", "may evaluate at runtime or compile-time": "mogą oceniać w czasie wykonywania lub kompilacji", "may or may not execute at compile-time, but will always return 5": "może lub nie mogą być wykonywane w czasie kompilacji, ale zawsze zwrócą 5", "may throw either std::out_of_range or a pointer to an integer": "może wyrzucić std::out_of_range lub wskaźnik do liczba całkowita", "may trigger a sign conversion warning if Student::Names defaults to a signed underlying type": "może wywołać ostrzeżenie o konwersji znaku, jeśli Student::Names domyślnie wybiera podstawowy typ ze znakiem", "member function.": "funkcję składową.", "member functions also accessed using member selection operator (.)": "funkcje składowe są również dostępne za pomocą operatora wyboru elementów (.)", "member functions defined outside the class need their own template declaration": "funkcje składowe zdefiniowane poza klasą wymagają własnej deklaracji szablonu", "member variables accessed using member selection operator (.)": "zmienne składowe dostępne za pomocą operatora wyboru elementów (.)", "members are private by default": "członkowie są domyślnie prywatni", "members are public by default": "członkowie są domyślnie publiczni", "members can access other private members": "członkowie mogą uzyskać dostęp do innych prywatnych członków", "memcmp compares the first n characters of two C-style strings and returns 0 if they are equal": "memcmp porównuje pierwsze n znaków dwóch ciągów w stylu C i zwraca 0, jeśli są równe", "messy, we have to break our print statement to call this function": "nieporządne, musimy przerwać naszą instrukcję print, aby to wywołać funkcja", "mhz is actually just a long": "mhz to właściwie tylko długi", "min is the index of the lower bounds of the array we're searching.": "min to indeks dolnych granic tablicy, którą przeszukujemy.", "missing semicolon at end of statement": "brakujący średnik na końcu instrukcji", "mixin Box class": "klasa mixin Box", "mixin Label class": "klasa mixin Label", "mixin Tooltip class": "mixin klasa Tooltip", "modifies s, which invalidates sv (s is still valid)": "modyfikuje s, co unieważnia sv (s jest nadal ważne)", "modify the object in array element 1": "zmodyfikuj obiekt w elemencie tablicy 1", "move 14 bytes before end of file": "przesuń 14 bajtów przed końcem pliku", "move 8 more bytes into file": "przenieś o 8 kolejnych bajtów do pliku", "move to 22nd byte in file": "przejdź do 22. bajtu w pliku", "move to 24th byte in file": "przejdź do 24. bajtu plik", "move to 5th character": "przejdź do 5. znaku", "move to beginning of file": "przejdź na początek pliku", "move to end of file": "przejdź na koniec pliku", "move to second element": "przejdź do drugiego elementu", "move to the 28th byte before end of the file": "przejdź do 28. bajtu przed końcem pliku", "moved this from A to B": "przeniosłem to z A do B", "much easier to read than 2132673462": "znacznie łatwiejsze do odczytania niż 2132673462", "multi-line": "wieloliniowy", "must dereference iterator to get element": "trzeba wyłuskać iterator, aby uzyskać element", "must first allocate an assignable object": "musi najpierw przydzielić obiekt, który można przypisać", "must use fully qualified name outside class": "musi użyć w pełni kwalifikowanej nazwy poza klasą", "my apple is red": "moje jabłko jest czerwone", "my cup is blue": "moja filiżanka jest niebieska", "my shirt is green": "moja koszula jest zielony", "name initialized with return value of function": "nazwa zainicjowana wartością zwracaną przez funkcję", "name is already type char*": "nazwa jest już typu char*", "names don't match the declaration": "nazwy nie pasują do deklaracji", "narr will decay to type int*": "narr przejdzie do typu int*", "needed prior to adoption of P2448R1 in C++23 (see note below)": "potrzebne przed przyjęciem P2448R1 w C++23 (patrz uwaga poniżej)", "needed so main.cpp knows that add() is a function defined elsewhere": "potrzebne więc main.cpp wie, że add() jest funkcją zdefiniowaną gdzie indziej", "needed to use ellipsis": "potrzebną do użycia wielokropka", "needs both constexpr and const": "potrzebuje constexpr i const", "nested block apples destroyed": "zniszczenie zagnieżdżonych jabłek blokowych", "new function added": "dodana nowa funkcja", "new int allocates 4 bytes in the heap": "nowa int przydziela 4 bajty na stercie", "new int[10] allocates 40 bytes in the heap": "new int[10] przydziela 40 bajtów na stercie", "new variable just to gate the loop": "nowa zmienna tylko do bramki pętli", "no copies through assignment!": "brak kopii poprzez przypisanie!", "no default initialization value (bad)": "brak domyślnej wartości inicjalizacyjnej (złe)", "no init-statement or end-expression": "brak instrukcji init lub wyrażenia końcowego", "no initialization value (bad)": "brak wartości inicjalizacyjnej (złe)", "no inner block apples defined in this example": "brak zdefiniowanych jabłek bloków wewnętrznych w tym przykładzie", "no longer a friend of Accumulator": "nie jest już przyjacielem akumulatora", "no longer has a naming collision with color_blue": "nie ma już kolizji nazw z color_blue", "no matching case exists and there is no default case": "nie istnieje żaden pasujący przypadek ani nie ma przypadku domyślnego", "no need to check for a denominator of 0 here since copy must already be a valid Fraction": "nie ma potrzeby sprawdzania tutaj mianownika 0, ponieważ kopia musi już być prawidłowym ułamkiem", "no need to override what() since we can just use std::runtime_error::what()": "nie ma potrzeby zastępowania what() ponieważ możemy po prostu użyć std::runtime_error::what()", "no object needed": "nie jest potrzebny żaden obiekt", "no return statement, because this function doesn't return a value": "brak instrukcji return, ponieważ ta funkcja nie zwraca wartości", "no scope resolution results in self-call and infinite recursion": "brak rozdzielczości zakresu skutkuje samodzielnym wywołaniem i nieskończoną rekursją", "no suffix is a C-style string literal": "żaden sufiks nie jest literałem łańcuchowym w stylu C", "no variable name since we don't use the exception itself in the catch block below": "brak nazwy zmiennej, ponieważ nie używamy samego wyjątku w bloku catch poniżej", "non-const member function can change members": "funkcja składowa niebędąca stałą może zmieniać elementy", "non-constant globals are external by default (no need to use extern)": "niestałe globale są domyślnie zewnętrzne (nie ma potrzeby aby użyć extern)", "non-constant globals have external linkage by default": "niestałe globale mają domyślnie zewnętrzne powiązanie", "non-constant globals have external linkage by default, but can be given internal linkage via the static keyword": "niestałe globale mają domyślnie zewnętrzne powiązanie, ale można im nadać wewnętrzne powiązanie za pomocą statycznego słowa kluczowego", "non-constexpr signed value": "non-constexpr wartość ze znakiem", "non-member function accessed using normal calling convention": "funkcja niebędąca składową dostępna przy użyciu normalnej konwencji wywoływania", "non-member function main is part of \"the public\"": "funkcja niebędąca składową main jest częścią „publiczna”", "non-member version of print": "wersja druku niebędąca członkiem", "nonsensical, but for the sake of example...": "bezsensowna, ale dla przykładu...", "not a narrowing conversion, even though precision lost!": "nie jest to konwersja zawężająca, mimo utraty precyzji!", "not a number (mathematically invalid)": "nie liczba (nieprawidłowa matematycznie)", "not a sign conversion since name is unsigned": "nie konwersja znaku, ponieważ nazwa jest bez znaku", "not allowed": "nie dozwolone", "not allowed: can not access private base members from derived class": "niedozwolone: nie można uzyskać dostępu do prywatnych elementów bazowych z klasy pochodnej", "not allowed: can not access private members from outside class": "niedozwolone: nie można uzyskać dostępu do prywatnych elementów spoza klasy", "not allowed: can not access protected members from outside class": "niedozwolone: nie można uzyskać dostępu do chronionych elementów spoza klasy", "not allowed: constexpr variables can't be forward declared": "niedozwolone: zmiennych constexpr nie można zadeklarować w przód", "not allowed: ptr points to a \"const int\" so we can't change the value through ptr": "niedozwolone: ptr wskazuje na „const int”, więc nie możemy zmienić wartości ptr", "not allowed: ref is const": "niedozwolone: ref jest const", "not allowed: we can't change a const value": "niedozwolone: nie możemy zmienić wartości stałej", "not called because exception was handled by A": "nie wywołane, ponieważ wyjątek został obsłużony przez A", "not called because exception was handled by prior catch block": "nie wywołane, ponieważ wyjątek został obsłużony przez wcześniejszy blok catch", "not caught: exception not thrown within try": "nie przechwycony: wyjątek nie został zgłoszony w try", "not caught: exception type mismatch": "nie przechwycony: typ wyjątku niedopasowanie", "not const at all": "w ogóle nie jest constex", "not constexpr": "nie constexpr", "not constexpr but value is known at compile-time": "nie constexpr, ale wartość jest znana w czasie kompilacji", "not copyable": "nie jest kopiowalna", "not differentiated from print(int)": "nie różni się od print(int)", "not indented from switch statement": "nie jest wcięta od instrukcji switch", "not narrowing, even though loss of precision results": "nie zawęża się, nawet jeśli utrata precyzji wyniki", "not obvious whether d is usable in a constant expression or not": "nie jest oczywiste, czy d można zastosować w wyrażeniu stałym, czy nie", "not obvious whether e is usable in a constant expression or not": "nie jest oczywiste, czy e można użyć w wyrażeniu stałym, czy nie", "not ok!": "nie ok!", "not okay": "nie w porządku", "not okay, 0x0012FF7C is treated as an integer literal": "nie w porządku, 0x0012FF7C jest traktowane jako literał całkowity", "not okay, though some compilers may allow": "nie w porządku, chociaż niektóre kompilatory mogą zezwolenie", "not okay: a pointer to a double can't point to an int object": "nie w porządku: wskaźnik do obiektu double nie może wskazywać na obiekt int", "not okay: a pointer to an int can't point to a double object": "nie w porządku: wskaźnik do obiektu typu int nie może wskazywać na obiekt double", "not okay: derived classes can't access private members in the base class": "nie w porządku: klasy pochodne nie mają dostępu do prywatnych elementów klasy bazowej", "not okay: m_private is inaccessible from derived class": "nie w porządku: m_private jest niedostępny z klasy pochodnej", "not okay: m_private is inaccessible in Pri": "nie w porządku: m_private jest niedostępny w Pri", "not okay: m_private is inaccessible in Pub": "nie w porządku: m_private jest niedostępny w Pub", "not okay: m_private is private in Base": "nie w porządku: m_private jest prywatny w Base", "not okay: m_protected is now private in Pri": "nie w porządku: m_protected jest teraz prywatny w Pri", "not okay: m_protected is protected in Base": "nie w porządku: m_protected jest chroniony w Base", "not okay: m_protected is protected in Pub": "nie w porządku: m_protected jest chroniony w Pub", "not okay: m_public is now private in Pri": "nie w porządku: m_public jest teraz prywatny w Pri", "not on Name": "nie w Imię", "not used in compound expression, condition contains no operators": "nie jest używany w wyrażeniu złożonym, warunek nie zawiera operatorów", "not used in compound expression, condition contains operators": "nie jest używany w wyrażeniu złożonym, warunek zawiera operatory", "not using m_ prefix because this is a struct": "nie używa prefiksu m_, ponieważ jest to struktura", "not valid": "nieprawidłowa", "not virtual": "nie wirtualna", "note addition of block here": "zauważ dodanie tutaj bloku", "note addition of constructor (getName() now called from here)": "zauważ dodanie konstruktora (getName() teraz wywoływanego z tutaj)", "note addition of explicit block here": "zwróć uwagę na dodanie tutaj wyraźnego bloku", "note addition of try keyword here": "zwróć uwagę na dodanie tutaj słowa kluczowego try", "note addition of virtual keyword": "zwróć uwagę na dodanie słowa kluczowego virtual", "note call to Base::identify() here": "zwróć uwagę na wywołanie Base::identify() tutaj", "note pass by reference here": "zauważ tutaj przekazanie przez referencję", "note that eatStack() calls itself": "zauważ, że eatStack() wywołuje samą siebie", "note that foo is not defined yet": "zauważ, że foo nie jest zdefiniowane jeszcze", "note that point must be non-const so we can modify the object": "zauważ, że punkt nie musi być stałą, abyśmy mogli zmodyfikować obiekt", "note that simple has been changed from an object prefix to a function argument!": "zauważ, że simple został zmieniony z przedrostka obiektu na argument funkcji!", "note that speak is a pure virtual function": "zauważ, że mówienie jest czysto wirtualną funkcją", "note that speak is now a pure virtual function": "zauważ, że mówienie jest teraz czysto wirtualną funkcją", "note that the following statement has not changed": "zauważ, że poniższe stwierdzenie nie uległo zmianie", "note that this implementation is a non-friend": "zauważ, że ta implementacja jest non-friend", "note that this is print<5> and not print<int>": "zauważ, że to jest print<5>, a nie print<int>", "note that this is print<`c`> and not print<char>": "zauważ, że to jest print<`c`>, a nie print<char>", "note that this points to one spot beyond the last element": "zauważ, że to wskazuje na jedno miejsce poza ostatnim elementem", "note that this template parameter declaration matches the one for std::array": "zauważ, że ta deklaracja parametrów szablonu pasuje do tej dla std::array", "note that this works even with no operator<< that explicitly handles Derived objects": "zauważ, że to działa nawet bez operatora<< który jawnie obsługuje obiekty pochodne", "note the parameter has type Pair, not Pair<T>": "zauważ, że parametr jest typu Pair, a nie Pair<T>", "note the semicolon at the end of this line": "zwróć uwagę na średnik na końcu tej linii", "note the semicolon here": "zwróć uwagę na średnik w tym miejscu", "note this is at same level of indentation as the function itself": "zauważ, że jest to ten sam poziom wcięcia co sama funkcja", "note use of final specifier here": "zwróć uwagę na użycie tutaj końcowego specyfikatora", "note use of final specifier on following line -- that makes this function not able to be overridden in derived classes": "zwróć uwagę na użycie końcowego specyfikatora następujący wiersz -- sprawia, że tej funkcji nie można zastąpić w klasach pochodnych", "note use of std::array here": "zwróć uwagę na użycie std::array tutaj", "note: No definition for function add": "uwaga: brak definicji funkcji add", "note: PoweredDevice is now a virtual base class": "uwaga: PoweredDevice jest teraz wirtualną klasą bazową", "note: The result of f1 * f2 is an r-value": "uwaga: wynikiem f1 * f2 jest wartość r", "note: The this-> prefix in the above line is needed.": "uwaga: przedrostek this-> w powyższym wierszu jest potrzebny.", "note: We're now rethrowing the object here": "uwaga: teraz ponownie wrzucamy obiekt tutaj", "note: added std::ws here": "uwaga: dodano std::ws tutaj", "note: banana is not directly accessible, we have to use Fruit::banana": "uwaga: banan nie jest bezpośrednio dostępny, musimy użyć Fruit::banana", "note: base now passed by reference": "uwaga: baza jest teraz mijana referencja", "note: base passed by value, not reference": "uwaga: podstawa przekazywana przez wartość, a nie odniesienie", "note: decltype(x) evaluates to the type of x": "uwaga: decltype(x) ocenia typ x", "note: does not perform range/overflow checking, use with caution": "uwaga: nie sprawdza zakresu/przepełnienia, używaj ostrożnie", "note: exp must be non-negative": "uwaga: exp musi być nieujemna", "note: explicit (just for sake of example)": "uwaga: jawna (tylko dla przykładu)", "note: explicitly specifying this returns a double": "uwaga: jawnie określenie tej opcji zwraca podwójną", "note: function is const": "uwaga: funkcja to const", "note: get() used here to get a pointer to the Resource": "uwaga: get() użyta tutaj w celu uzyskania wskaźnika do zasobu", "note: inner will be created and destroyed at the end of the block": "uwaga: wartość wewnętrzna zostanie utworzona i zniszczona na końcu bloku", "note: need curly braces to instantiate object": "uwaga: do utworzenia instancji obiektu potrzebne są nawiasy klamrowe", "note: nested type declared here": "uwaga: zadeklarowany tutaj typ zagnieżdżony", "note: no default initialization value": "uwaga: brak wartości domyślnej wartość inicjalizacyjna", "note: no enumerator with value 0 in this list": "uwaga: brak modułu wyliczającego o wartości 0 na tej liście", "note: no initializer here": "uwaga: brak tutaj inicjatora", "note: no initializer here either": "uwaga: brak tutaj również inicjatora", "note: no parenthesis here": "uwaga: brak nawiasu", "note: no print() function here": "uwaga: brak tutaj funkcji print()", "note: no specified return type": "uwaga: brak określonego typu zwracanego", "note: no std::ws here": "uwaga: nie std::ws tutaj", "note: no variable name since we don't use it in the catch block below": "uwaga: brak nazwy zmiennej, ponieważ nie używamy jej w bloku catch poniżej", "note: no virtual keyword in B, C, and D": "uwaga: brak wirtualnego słowa kluczowego w B, C i D", "note: not const": "uwaga: nie const", "note: not constexpr for this example": "uwaga: nie constexpr w tym przykładzie", "note: not virtual": "uwaga: nie wirtualny", "note: not virtual (your compiler may warn you about this)": "uwaga: nie wirtualny (Twój kompilator może ostrzegam cię o tym)", "note: now inline constexpr": "uwaga: teraz wbudowane constexpr", "note: only the length has been templated here": "uwaga: tutaj szablonem została tylko długość", "note: parameter is a short": "uwaga: parametr jest krótki", "note: pre-C++17, use std::function<double(double, double)> instead": "uwaga: wersja przed C++17, użyj zamiast tego std::function<double(double, double)>", "note: ptr is a pointer to non-const in this example": "uwaga: ptr jest w tym przypadku wskaźnikiem do wartości innej niż stała przykład", "note: ptr is now a pointer to a const": "uwaga: ptr jest teraz wskaźnikiem do const", "note: rBase is a B this time": "uwaga: rBase jest tym razem B", "note: red is not directly accessible, we have to use Color::red": "uwaga: kolor czerwony nie jest bezpośrednio dostępny, musimy użyć Color::red", "note: this function could be constexpr, but we haven't covered constexpr functions yet": "uwaga: ta funkcja może być constexpr, ale nie omówiliśmy jeszcze funkcji constexpr", "note: this function is a member function!": "uwaga: ta funkcja jest funkcją składową!", "note: this function is not a member function nor a friend function!": "uwaga: ta funkcja nie jest funkcją składową ani funkcją zaprzyjaźnioną!", "note: this function is not a member function!": "uwaga: ta funkcja nie jest funkcją składową funkcja!", "note: this program has an error somewhere": "uwaga: ten program zawiera gdzieś błąd", "note: this sets the global g_mode variable to 1.  It does not declare a local g_mode variable!": "uwaga: ustawia globalną zmienną g_mode na 1. Nie deklaruje lokalnej zmiennej g_mode!", "note: uses CTAD to deduce template arguments": "uwaga: używa CTAD do wyprowadzania argumentów szablonu", "note: variable is non-const": "uwaga: zmienna nie jest stałą", "note: we can't define this function here, because Vector3d hasn't been defined yet (just forward declared)": "uwaga: nie możemy tutaj zdefiniować tej funkcji, ponieważ Vector3d nie został zdefiniowany yet (tylko zadeklarowane forward)", "note: we can't use \"int\" here because it's a keyword, so we'll use \"tInt\" instead": "uwaga: nie możemy tutaj użyć „int”, ponieważ jest to słowo kluczowe, więc zamiast tego użyjemy „tInt”", "note: we changed the implementation of this class!": "uwaga: zmieniliśmy implementację tej klasy!", "note: we use cleanup rather than cleanup() since we're not making a function call to cleanup() right now": "uwaga: używamy czyszczenia zamiast cleanup(), ponieważ w tej chwili nie wykonujemy wywołania funkcji cleanup()", "note: we're not instantiating any objects of type Something": "uwaga: nie tworzymy instancji dowolne obiekty typu Coś", "now 6": "teraz 6", "now a class instead of a struct": "teraz klasa zamiast struktury", "now a const member function": "teraz stała funkcja członkowska", "now a constexpr function": "teraz funkcja constexpr", "now a non-static local variable, destroyed when function ends": "teraz niestatyczna zmienna lokalna, niszczona po zakończeniu funkcji", "now a pointer to a const int": "teraz wskaźnik do const int", "now a std::string_view": "teraz std::string_view", "now a std::string_view literal": "teraz std::string_view literał", "now also works with rvalue arguments": "teraz działa także z argumentami rvalue", "now an enum class": "teraz klasa wyliczeniowa", "now calls Foo(std::initializer_list<int>)": "teraz wywołuje Foo(std::initializer_list<int>)", "now compiles": "teraz kompiluje", "now const": "teraz const", "now constexpr": "teraz constexpr", "now do the deep copy": "teraz wykonaj głęboką kopię", "now explicit": "teraz jawnie", "now hexadecimal": "teraz szesnastkowo", "now inline": "teraz inline", "now marked as explicit": "teraz oznaczone jako jawne", "now mutable": "teraz zmienne", "now obvious this 30 is used in a different context": "teraz oczywiste, że 30 jest użyte w innym kontekście", "now obvious what this 30 means": "teraz oczywiste, co to 30 oznacza", "now ok, prints 3": "teraz OK, wypisuje 3", "now private": "teraz prywatne", "now returns a T&": "teraz zwraca T&", "now using auto to deduce type of N": "teraz używając auto do wydedukowania typu N", "now using constexpr if": "teraz używam constexpr if", "now, f.a = 1, f.b = 3, f.c = 0": "teraz, f.a = 1, f.b = 3, f.c = 0", "numStudents is non-constant": "numStudents jest niestałe", "numeric promotion of bool to int": "numeryczne awansowanie boola na int", "numeric promotion of char to int": "numeryczne awansowanie znaku na int", "numeric promotion of float to double": "numeryczne awansowanie float na podwójna", "numeric promotion of short to int": "numeryczna promocja skrótu na int", "obvious that x is being modified": "oczywiste, że x jest modyfikowane", "obvious we should update this": "oczywiste, że i tak powinniśmy zaktualizować ten", "of scope immediately after this anyway.": "zakres natychmiast po tym.", "ofstream is used for writing files": "ofstream jest używany do zapisywania plików", "ok, CTAD can be used here": "ok, można tu użyć CTAD", "ok, can bind to global": "ok, można powiązać z global", "ok, can bind to static local": "ok, można powiązać ze statycznym local", "ok, template arguments explicitly specified": "ok, jawnie określono argumenty szablonu", "ok: 4 + 5 is a constant expression": "ok: 4 + 5 to wyrażenie stałe", "ok: 5 is a literal value that we're sending to the console to be printed": "ok: 5 to literał, który wysyłamy do konsoli w celu wydrukowania", "ok: 5 is rvalue literal, y binds to temporary int object": "ok: 5 to dosłowna wartość, y wiąże się z tymczasową wartością int obiekt", "ok: 9.8 is a constant expression": "ok: 9.8 to wyrażenie stałe", "ok: a pointer to a double can point to a double object": "ok: wskaźnik do obiektu typu double może wskazywać na obiekt typu double", "ok: a pointer to an int can point to an int object": "ok: wskaźnik do typu int może wskazywać na obiekt typu int", "ok: age is non-const, so we can change its value": "ok: wiek nie jest stały, więc możemy zmienić jego wartość", "ok: can brace initialize unscoped enumeration with specified base with integer (C++17)": "ok: można nawiasem inicjować wyliczenie bez zakresu o określonej podstawie za pomocą liczba całkowita (C++17)", "ok: can call const member function on non-const object": "ok: można wywołać funkcję członkowską const na obiekcie innym niż stała", "ok: compiler will convert int value 6 to unsigned int value 6": "ok: kompilator przekonwertuje wartość int 6 na wartość int bez znaku 6", "ok: compiler will convert int value 7 to long value 7": "ok: kompilator przekonwertuje wartość int 7 na wartość long 7", "ok: compiler will instantiate passByRef(const std::array<double, 5>& arr)": "ok: kompilator utworzy instancję passByRef(const std::array<double, 5>& arr)", "ok: compiler will instantiate passByRef(const std::array<int, 5>& arr)": "ok: kompilator utworzy instancję passByRef(const std::array<int, 5>& arr)", "ok: compiler will instantiate passByRef(const std::array<int, 6>& arr)": "ok: kompilator utworzy instancję passByRef(const std::array<int, 6>& arr)", "ok: compiler will instantiate passByRef(const std::vector<double>&)": "ok: kompilator utworzy instancję passByRef(const std::vector<double>&)", "ok: compiler will instantiate passByRef(const std::vector<int>&)": "ok: kompilator utworzy instancję passByRef(const std::vector<int>&)", "ok: const object can call const member function": "ok: obiekt const może wywołać funkcję członkowską const", "ok: explicitly create a Dollars": "ok: jawnie utwórz Dollars", "ok: f1.a = 1, f1.b = 0 (value initialized), f1.c = 3": "ok: f1.a = 1, f1.b = 0 (wartość zainicjowana), f1.c = 3", "ok: f2.a = 1, f2.b = 0 (value initialized), f2.c = 3": "ok: f2.a = 1, f2.b = 0 (wartość zainicjalizowana), f2.c = 3", "ok: inexpensive bind to std::string argument": "ok: niedrogie powiązanie z argumentem std::string", "ok: inexpensive conversion of C-style string literal to std::string_view": "ok: niedroga konwersja literału łańcuchowego w stylu C na std::string_view", "ok: may evaluate at compile-time or runtime": "ok: może ocenić w czasie kompilacji lub w czasie wykonywania", "ok: return value is constexpr std::size_t and can be converted to int, not a narrowing conversion": "ok: zwracana wartość to constexpr std::size_t i można ją przekonwertować na int, a nie zawężającą konwersję", "ok: s is constexpr and can be converted safely, not a narrowing conversion": "ok: s jest constexpr i można ją bezpiecznie przekonwertować, a nie zawężenie konwersja", "ok: static_cast will use explicit constructors": "ok: static_cast użyje jawnych konstruktorów", "ok: sum is a constant expression": "ok: suma jest wyrażeniem stałym", "ok: this is actually a std::array<int, 2>, not an array of references": "ok: to jest właściwie std::array<int, 2>, a nie tablica odniesień", "ok: unnamed parameter will not generate warning": "ok: nienazwany parametr nie zostanie wygenerowany ostrzeżenie", "ok: use move semantics": "ok: użyj semantyki przenoszenia", "ok: value initialized": "ok: wartość zainicjowana", "ok: we can call a function that does not return a value": "ok: możemy wywołać funkcję, która nie zwraca wartości", "ok: we can call a function that returns a value, and ignore that return value": "ok: możemy wywołać funkcję, która zwraca wartość i zignorować tę zwracaną wartość", "ok: we can call a function that returns a value, and the value will be used": "ok: możemy wywołać funkcję, która zwraca wartość, a wartość zostanie użyta", "ok: we can do a range-based for on a std::array": "ok: my może wykonać operację w oparciu o zakres na std::array", "ok: we're explicitly specifying the template arguments": "ok: jawnie określamy argumenty szablonu", "ok: will evaluate at compile-time": "ok: ocenimy w czasie kompilacji", "ok: x is a modifiable lvalue": "ok: x jest modyfikowalną lwartością", "ok: x is a modifiable lvalue, y binds to x": "ok: x jest modyfikowalną lwartością, y wiąże się z x", "ok: z is a non-modifiable lvalue, y binds to z": "ok: z jest niemodyfikowalną lwartością, y wiąże się z z", "okay (but redundant) since nested type has already been declared as part of outer class definition": "OK (ale zbędny), ponieważ typ zagnieżdżony został już zadeklarowany jako część definicji klasy zewnętrznej", "okay (there is no suffix for short, we don't need a static_cast here)": "OK (nie ma tu żadnego przyrostka, nie potrzebujemy tutaj static_cast)", "okay (we don't need a static_cast here)": "OK (nie potrzebujemy tutaj static_cast)", "okay (we don't need to use `1.5f`)": "OK (nie musimy używać `1.5f`)", "okay (we don't need to use `5u`)": "OK (nie musimy używać `5u`)", "okay because foo is still defined before any calls to goo": "OK, ponieważ foo jest nadal zdefiniowane przed jakimkolwiek wywołaniem goo", "okay but bad practice: definition is allowed within a case": "OK, ale zła praktyka: definicja jest dozwolona w obrębie przypadku", "okay if gravity was initialized with a literal": "OK, jeśli grawitacja została zainicjowana literałem", "okay if int is 32-bit, narrowing if x is 64-bit": "OK, jeśli int jest 32-bitowy, zawężanie, jeśli x jest 64-bitowe", "okay if someFcn() returns 0.0 as a literal only": "w porządku, jeśli SomeFcn() zwraca 0,0 tylko jako literał", "okay now": "w porządku teraz", "okay to call non-const member function on non-const object": "w porządku, aby wywołać funkcję składową inną niż stała na obiekcie niestałym", "okay to dereference": "w porządku wyłuskanie", "okay to modify members in non-const constructor": "w porządku modyfikowanie elementów składowych w obiektach innych niż stałe konstruktor", "okay to use signed index": "OK, aby użyć indeksu ze znakiem", "okay to use unsigned index": "OK, aby użyć indeksu bez znaku", "okay, accessing enumerator from global namespace": "OK, dostęp do modułu wyliczającego z globalnej przestrzeni nazw", "okay, foo implicitly converts to function pointer to foo": "OK, foo niejawnie konwertuje wskaźnik funkcji na foo", "okay, function is an override of A::getName3(int)": "OK, funkcja jest zastąpieniem A::getName3(int)", "okay, main() allowed to access public members": "okej, main() ma dostęp do elementów publicznych", "okay, produces double value 5.0": "okej, tworzy podwójną wartość 5.0", "okay, produces long value 5": "okej, tworzy długą wartość 5", "okay, sum is an lvalue": "okej, suma jest lwartością", "okay, variables can be initialized inside a block inside a case": "okej, zmienne mogą być inicjalizowane wewnątrz bloku wewnątrz case", "okay: 3 converted from int to std::size_t, not a narrowing conversion": "OK: 3 skonwertowane z int na std::size_t, a nie zawężająca konwersja", "okay: 5 is an rvalue": "OK: 5 to wartość", "okay: A function forward declaration": "OK: Deklaracja przekazania funkcji", "okay: A::fun() is public, resolves to private B::fun() at runtime": "OK: A::fun() jest publiczna, przekształca się w prywatną B::fun() w czasie wykonywania", "okay: assignment is allowed": "OK: przypisanie jest dozwolone", "okay: both arguments defaulted": "okej: oba argumenty ustawione domyślnie", "okay: both operands have matching type int": "okej: oba operandy mają pasujący typ int", "okay: calls non-const version of operator[]": "oky: wywołuje inną niż stała wersję operatora[]", "okay: can forward declare non-nested type": "okej: można przekazać dalej deklarację typu niezagnieżdżonego", "okay: constant expression a can be used as argument to constexpr function foo()": "ok: wyrażenie stałe a może być użyte jako argument funkcji constexpr foo()", "okay: constexpr index implicitly converted to std::size_t, not a narrowing conversion": "ok: indeks constexpr niejawnie przekonwertowany na std::size_t, a nie konwersja zawężająca", "okay: conversion is not narrowing due to exclusion clause": "ok: konwersja nie zawęża się z powodu klauzuli wykluczającej", "okay: copy-assignment allows narrowing conversion of 4.5 to 4": "ok: przypisanie kopii umożliwia zawężającą konwersję z 4,5 do 4", "okay: d defaults to 10.0": "ok: d domyślnie 10.0", "okay: definition is allowed before the case labels": "OK: definicja jest dozwolona przed etykietami przypadków", "okay: definition of forward declared type inside the enclosing class": "OK: definicja typu forward zadeklarowanego wewnątrz klasy otaczającej", "okay: definition of forward declared type outside the enclosing class": "OK: definicja typu forward zadeklarowanego poza klasą otaczającą", "okay: forward declaration inside the enclosing class okay": "OK: deklaracja forward wewnątrz klasy otaczającej OK", "okay: function definition": "OK: definicja funkcji", "okay: function forward declaration": "OK: deklaracja funkcji w przód", "okay: function printHi() is called, no value is returned": "OK: funkcja printHi() jest wywoływana, żadna wartość nie jest zwracana", "okay: initialization is fine": "OK: inicjalizacja jest w porządku", "okay: initialized to false": "OK: inicjalizacja na false", "okay: initialized to true": "OK: inicjalizacja na true", "okay: int to double is safe": "OK: int na double jest bezpieczne", "okay: int value 1 converted to double": "okay: int wartość 1 skonwertowana na double", "okay: it's obvious 1000 is a conversion factor": "ok: to oczywiste, że 1000 to współczynnik konwersji", "okay: m_protected is now private in Pri": "okay: m_protected jest teraz prywatny w Pri", "okay: m_protected was inherited as protected": "ok: m_protected został odziedziczony jako chroniony", "okay: m_public is now private in Pri": "ok: m_public jest teraz prywatny w Pri", "okay: m_public is public in Base": "okay: m_public jest publiczny w Base", "okay: m_public is public in Pub": "okay: m_public jest publiczny w Pub", "okay: m_public was inherited as public": "okay: m_public został odziedziczony jako publiczny", "okay: m_value is public in Base": "okay: m_value jest publiczny w Base", "okay: must evaluate at compile-time": "okay: należy ocenić w czasie kompilacji", "okay: no sign conversion warnings": "OK: brak konwersji znaku ostrzeżenia", "okay: non-const lvalue reference bound to a modifiable lvalue": "okay: odniesienie do lwartości niebędące stałą powiązane z modyfikowalną wartością", "okay: overloaded function differentiated by parameter type": "ok: przeciążona funkcja zróżnicowana według typu parametru", "okay: ptr is pointing to a \"const int\"": "okay: ptr wskazuje na „const int”", "okay: ptr now points at const int y": "OK: ptr wskazuje teraz na const int y", "okay: ref is a an lvalue reference to a const value": "OK: ref jest referencją do lwartości const wartość", "okay: reference to int is bound to int variable": "ok: odwołanie do int jest powiązane ze zmienną int", "okay: the const pointer is initialized to the address of x": "ok: wskaźnik const jest inicjowany na adres x", "okay: the day member is public": "ok: element dnia jest publiczny", "okay: the print() member function is public": "OK: funkcja członkowska print() jest publiczna", "okay: the value 5 is returned, but is ignored since main() doesn't do anything with it": "ok: wartość 5 jest zwracana, ale jest ignorowana, ponieważ funkcja main() nic nie robi z tym", "okay: the value being pointed to is non-const": "OK: wskazywana wartość nie jest stała", "okay: use CTAD to infer std::vector<int>": "OK: użyj CTAD, aby wywnioskować std::vector<int>", "okay: val is independent of referenced member": "OK: val jest niezależna od elementu, do którego się odwołuje", "okay: we can access the const object": "OK: możemy uzyskać dostęp do const obiekt", "okay: we can access the object through our const reference": "ok: możemy uzyskać dostęp do obiektu poprzez nasze odwołanie do stałej", "okay: we can bind a const reference to a modifiable lvalue": "ok: możemy powiązać odwołanie do stałej z modyfikowalną wartością", "okay: we can create std::string using std::string_view initializer": "ok: możemy utworzyć std::string za pomocą inicjatora std::string_view", "okay: we can explicitly cast a std::string_view to a std::string": "OK: możemy jawnie rzucić std::string_view na std::string", "okay: we're just incrementing our generator": "OK: właśnie zwiększamy nasz generator", "okay: we're starting our id generator with value 0": "OK: zaczynamy nasz generator identyfikatorów z wartością 0", "okay: will be converted to float value 1.2 (value preserved)": "OK: zostanie przekonwertowany na wartość zmiennoprzecinkową 1.2 (wartość zachowana)", "okay: will be converted to int value 3 (value preserved)": "OK: zostanie przekonwertowany na wartość int 3 (wartość zachowana)", "okay: will be converted to unsigned int 5 (value preserved)": "OK: zostanie przekonwertowany na unsigned int 5 (wartość zachowana)", "okay: will evaluate at runtime": "ok: ocenimy w czasie wykonywania", "okay: x is a modifiable lvalue, we can still modify it through the original identifier": "ok: x jest modyfikowalną wartością, nadal możemy ją modyfikować poprzez oryginalny identyfikator", "okay: y was declared above, so we can use it here too": "ok: y zostało zadeklarowane powyżej, więc możemy go użyć również tutaj", "old address lost, memory leak results": "utracono stary adres, skutkiem jest wyciek pamięci", "one extra indentation for continuation line": "jedno dodatkowe wcięcie dla kontynuacji linia", "only evaluates when prior if-statement condition is false": "wykonuje tylko wtedy, gdy wcześniejszy warunek instrukcji if jest fałszywy", "only executes if x > 20": "wykonuje się tylko wtedy, gdy x > 20", "only executes if x >= 0": "wykonuje się tylko wtedy, gdy x >= 0", "only initialize first 3 elements": "tylko inicjuje pierwsze 3 elementy", "only initialized the first time this function is called": "inicjuje się tylko przy pierwszym wywołaniu tej funkcji", "only invokes Something(int), no copy constructor": "wywołuje tylko coś(int), bez kopiowania konstruktor", "oops, didn't realize this was pass by value on the calling end": "ups, nie zdawałem sobie sprawy, że to była przekazywana wartość po stronie wywołującej", "oops, only 4 values": "ups, tylko 4 wartości", "oops, we forgot to initialize x, but the compiler may not complain": "ups, zapomnieliśmy zainicjować x, ale kompilator może nie narzekać", "oops, we used an assignment here instead of a test for equality": "ups, użyliśmy tutaj przypisania zamiast testu dla równość", "oops, we used operator< instead of operator<=": "ups, użyliśmy operatora< zamiast operatora<=", "oops, we used operator> instead of operator<": "oops, użyliśmy operatora> zamiast operatora<", "oops, we used operator>= instead of operator>": "ups, użyliśmy operatora>= zamiast operatora>", "oops, we wanted a double here but we accidentally provided an int literal": "ups, chcieliśmy tutaj podwójnego, ale przez przypadek podaliśmy literał int", "oops, we wanted floating point division here": "ups, chcieliśmy podziału zmiennoprzecinkowego tutaj", "open setup.ini for reading": "otwórz plik setup.ini do odczytu", "operator+ uses operands 2 and 3 to evaluate to value 5": "operator+ używa operandów 2 i 3 do obliczenia wartości 5", "operator++ has side effect of incrementing x": "operator++ ma efekt uboczny w postaci zwiększania x", "operator<< has side effect of modifying the state of the console": "operator<< ma efekt uboczny w postaci modyfikacji stanu konsoli", "operator== returns true if x equals y, and false otherwise": "operator== zwraca wartość true, jeśli x jest równe y, i fałsz w przeciwnym razie", "operator[] expects an index of type std::size_t, no conversion required": "operator[] oczekuje indeksu typu std::size_t, konwersja nie jest wymagana", "or change the implementation transparently to the callers": "lub zmień implementację w sposób przejrzysty dla wywołujących", "or if c is 'A'": "lub jeśli c to „A”", "or if c is 'E'": "lub jeśli c to „E”", "or if c is 'I'": "lub jeśli c to „I”", "or if c is 'O'": "lub jeśli c to „O”", "or if c is 'U'": "lub jeśli c to „U”", "or if c is 'e'": "lub jeśli c to „e”", "or if c is 'i'": "lub jeśli c to „i”", "or if c is 'o'": "lub jeśli c to „o”", "or if c is 'u'": "lub jeśli c to „u”", "or if the user entered 3": "lub jeśli użytkownik wprowadził 3", "or if the user entered 5": "lub jeśli użytkownik wprowadził 5", "or if the user entered 7": "lub jeśli użytkownik wprowadził 7", "or return std::nullopt": "lub zwróć std::nullopt", "or throw exception when !value": "lub zgłoś wyjątek, gdy !wartość", "otherPtr is now pointed at that same memory location": "otherPtr jest teraz wskazywana w tym samym miejscu pamięci", "otherwise add number to our sum": "w przeciwnym razie dodaj liczbę do naszej sumy", "otherwise compare the model": "w przeciwnym razie porównaj model", "otherwise create a new StudentGrade for this student and add": "w przeciwnym razie utwórz nową StudentGrade dla tego ucznia i dodaj", "otherwise just decrement to next number": "w przeciwnym razie po prostu zmniejsz do następnej liczby", "otherwise just increment to next number": "w przeciwnym razie po prostu zwiększ do następnej liczba", "otherwise sort in ascending order": "w przeciwnym razie posortuj rosnąco", "otherwise tell the user what went wrong": "w przeciwnym razie powiedz użytkownikowi, co poszło nie tak", "otherwise the digit must not be prime": "w przeciwnym razie cyfra nie może być liczbą pierwszą", "otherwise y could still be used here, where it's not needed": "w przeciwnym razie y nadal mogłoby zostać użyte tutaj, gdzie nie jest potrzebne", "otherwise, our binarySearch() function must be broken": "w przeciwnym razie nasza funkcja binarySearch() musi być zepsuty", "our array has elements of type int": "nasza tablica zawiera elementy typu int", "our functions wouldn't work with r-values.": "nasze funkcje nie będą działać z wartościami r.", "our member is now private": "nasz element jest teraz prywatny", "our new helper function": "nasza nowa funkcja pomocnicza", "our pig evolved into a whale!": "nasza świnia wyewoluowała w wieloryba!", "our print statement is back here": "nasza instrukcja drukowania jest tutaj", "outer block apples destroyed": "zewnętrzne jabłka blokowe zniszczone", "outer block apples retains its value even after we leave the nested block": "zewnętrzny blok jabłek zachowuje swoją wartość nawet po opuszczeniu zagnieżdżonego bloku", "outer if statement": "zewnętrzna instrukcja if", "outer if-statement": "zewnętrzna instrukcja if", "outer loop is rows / y": "zewnętrzna pętla to wiersze / y", "outer loop on letters": "zewnętrzna pętla na literach", "outer loops between 1 and 5": "zewnętrzna pętla między 1 a 5", "output our string as a sequence of characters": "wyprowadź nasze string jako sekwencja znaków", "output string": "ciąg wyjściowy", "outputs string": "ciąg wyjściowy", "overload of print() function for partially specialized StaticArray<char, size>": "przeciążenie funkcji print() dla częściowo wyspecjalizowanej StaticArray<char, size>", "p deduced to std::pair<int, int>": "p wydedukowany do std::pair<int, int>", "p is non-const": "p nie jest stałą", "p.greater() evaluates at runtime or compile-time": "p.greater() ocenia w czasie wykonywania lub czas kompilacji", "p3.reset();                   // Compile error: can't call non-const member function on const object": "p3.reset(); // Błąd kompilacji: nie można wywołać funkcji składowej innej niż stała na obiekcie const", "parenthesis init to set vector's capacity to 3": "inicjacja nawiasu, aby ustawić pojemność wektora na 3", "pass by non-const reference": "przekaż referencje inne niż stałe", "pass by non-const references requires lvalue": "przekaż referencje inne niż stałe wymaga lvalue", "pass by reference": "przekaż przez referencję", "pass by value": "przekaż wartość", "pass by value because Pair is small": "przekaż wartość, ponieważ Para jest mała", "pass our constant to the function as a parameter": "przekazuje naszą stałą do funkcji jako parametr", "pass str by address, does not make a copy of str": "przekazuje str przez adres, nie tworzy kopii str", "pass str by reference, does not make a copy of str": "przekazuje str przez referencję, nie tworzy kopii str", "pass str by value, makes a copy of str": "przekazuje str przez wartość, tworzy kopię str", "pass to `const std::string&` parameter": "przejdź do parametru `const std::string&`", "paw is not a pointer, use .": "paw nie jest wskaźnikiem, użyj .", "pet is an in/out parameter": "pet to parametr wejścia/wyjścia", "phi is used": "phi jest używane", "pi is used": "pi jest używane", "player wins if current board == solved board": "gracz wygrywa, jeśli bieżąca plansza == rozwiązana plansza", "plog::none eliminates writing of most messages, essentially turning logging off": "plog::none eliminuje pisanie większości wiadomości, zasadniczo wyłączając wylogowywanie", "point to the new array.": "wskaż na nową tablica.", "pointer to a pointer to an int, two asterisks": "wskaźnik na wskaźnik na int, dwie gwiazdki", "pointer to an int, one asterisk": "wskaźnik na int, jedna gwiazdka", "pointers convert to Boolean false if they are null, and Boolean true if they are non-null": "wskaźniki są konwertowane na wartość Boolean false, jeśli mają wartość null, i wartość Boolean true, jeśli są różne od wartości null", "points to a \"const int\" and is const itself.  We can't modify the value nor the address.": "wskazują na „const int” i same w sobie są const. Nie możemy modyfikować wartości ani adresu.", "points to a \"const int\" but is not const itself.  We can only modify the address.": "wskazuje na „const int”, ale sama w sobie nie jest stałą. Możemy jedynie modyfikować adres.", "points to an \"int\" and is const itself.   We can only modify the value.": "wskazuje na „int” i sam w sobie jest const. Możemy jedynie modyfikować wartość.", "points to an \"int\" but is not const itself.  We can modify the value or the address.": "wskazuje na „int”, ale sama w sobie nie jest stałą. Możemy modyfikować wartość lub adres.", "pop_back() pops an element off the stack": "pop_back() usuwa element ze stosu", "possible warning: copy initialization allows narrowing conversion": "możliwe ostrzeżenie: inicjalizacja kopiowania pozwala na zawężenie konwersji", "possible warning: index implicitly converted to std::size_t, narrowing conversion": "możliwe ostrzeżenie: indeks niejawnie konwertowany na std::size_t, zawężanie konwersji", "possible warning: narrowing conversion from unsigned int to std::uint8_t": "możliwe ostrzeżenie: zawężanie konwersji z unsigned int do std::uint8_t", "postfix has an int parameter": "postfix ma parametr int", "potions are independent of size.": "mikstury są niezależne od rozmiaru.", "pre-C++17 use std::array<const char*, 12>": "przed wersją C++17 użyj std::array<const char*, 12>", "precondition: array length must be greater than 3 so element 3 exists": "warunek: długość tablicy musi być większa niż 3, aby element 3 istniał", "prefer \"long long\" instead of \"long long int\"": "preferuj „long long” zamiast „long long int”", "prefer \"long\" instead of \"long int\"": "preferuj „long” zamiast „long int”", "prefer \"short\" instead of \"short int\"": "preferuj „short” zamiast „short int”", "prefer this in most cases": "preferuj to w większości przypadków", "prefer this one": "preferuj to jedno", "preferred use of const before type": "preferowane użycie const przed typem", "preprocessor replaces MY_NAME with \"Alex\"": "preprocesor zastępuje MY_NAME przez \"Alex\"", "prime and its elements cannot be modified": "prime i jego elementów nie można modyfikować", "prime decays to a pointer": "prime rozpada się na wskaźnik", "prime decays to an const int* pointer": "prime rozpada się na const int* wskaźnik", "prime is the actual array": "prime jest rzeczywistą wartością tablica", "prime1 explicitly defined to have length 5": "prime1 jawnie zdefiniowana jako długość 5", "prime2 deduced by compiler to have length 5": "prime2 wydedukowana przez kompilator jako długość 5", "print 'a' 3 times": "drukuj 'a' 3 razy", "print 1 -- does this make sense?": "drukuj 1 -- czy to ma sens?", "print 27 in hex": "drukuj 27 w formacie szesnastkowym", "print 4 to console": "wydrukuj 4 do konsoli", "print 5 1 time": "drukuj 5 1 raz", "print 55": "drukuj 55", "print 7": "drukuj 7", "print Hello world! to console": "drukuj Witaj, świecie! do konsoli", "print T however it normally prints": "wypisz T, jednak normalnie wypisuje", "print a newline at the end of each row": "wydrukuj znak nowej linii na końcu każdego wiersza", "print address held by ptr": "wydrukuj adres trzymany przez ptr", "print an error": "wydrukuj błąd", "print array dimensions": "wydrukuj wymiary tablicy", "print array in 1d": "wydrukuj tablicę w 1d", "print array in 2d": "wydrukuj tablicę w 2d", "print array using a single dimension": "wydrukuj tablicę używając pojedynczego wymiaru", "print array using two dimensions": "wydrukuj tablicę używając dwóch wymiarów", "print bool as true or false rather than 1 or 0": "wypisz bool jako prawdę lub fałsz zamiast 1 lub 0", "print bool as true or false, not 1 or 0": "wydrukuj bool jako prawdę lub fałsz, a nie 1 lub 0", "print bool as true/false": "wydrukuj bool jako prawda/fałsz", "print boolean as true/false": "wydrukuj wartość bool jako prawda/fałsz", "print bools as true or false": "wydrukuj bool jako prawda lub false", "print default value with no field width": "drukuj wartość domyślną bez szerokości pola", "print default with field width": "drukuj wartość domyślną z szerokością pola", "print e2.m_name": "drukuj e2.m_name", "print each shape in vector v on its own line here": "drukuj każdy kształt wektorem v w osobnej linii tutaj", "print error message": "drukuj komunikat o błędzie", "print f (containing the bits from n)": "drukuj f (zawierający bity z n)", "print function declaration": "funkcja wydruku deklaracja", "print function definition": "wydrukuj definicję funkcji", "print how many bytes of memory an int value takes": "wydrukuj, ile bajtów pamięci zajmuje wartość typu int", "print i": "drukuj i", "print internally justified": "drukuj wyrównane wewnętrznie", "print joe's age": "drukuj wiek Joego", "print left justified": "drukuj wyjustowane do lewej", "print means Foo::print": "drukuj oznacza Foo::print", "print now takes an int parameter": "drukuj teraz wartość typu int parametr", "print our color's name to whatever output stream out": "wydrukuj nazwę naszego koloru na dowolnym strumieniu wyjściowym", "print our letter first": "wydrukuj najpierw naszą literę", "print ptr as C-style string": "wydrukuj ptr jako ciąg w stylu C", "print right justified": "drukuj wyjustowane do prawej", "print takes a double parameter": "drukuj pobiera podwójny parametr", "print the CEO's wage": "wydrukuj pensję dyrektora generalnego", "print the Resource that res is owning": "wydrukuj zasób, który jest res właściciel", "print the creature's name and location": "wydrukuj nazwę i lokalizację stworzenia", "print the current character": "wydrukuj bieżący znak", "print the current value of `num`": "wydrukuj aktualną wartość `num`", "print the date": "wydrukuj datę", "print the element in row 1, column 2": "wydrukuj element w wierszu 1, kolumnie 2", "print the following values in hex": "wydrukuj następujące wartości w formacie szesnastkowym", "print the literal character `H`": "wydrukuj znak dosłowny `H`", "print the literal number `-6.7`": "wydrukuj liczbę dosłowną `-6,7`", "print the literal number `5`": "wydrukuj liczbę dosłowną `5`", "print the literal text `Hello`": "wydrukuj tekst dosłowny `Witajcie`", "print the memory address of variable x": "wydrukuj adres pamięci zmiennej x", "print the number (pad numbers under 10 with a leading 0 for formatting purposes)": "wydrukuj liczbę (numery padów poniżej 10 z 0 na początku dla celów formatowania)", "print the number and a single space": "wydrukuj liczbę i pojedynczą spację", "print the numbers separated by a dash": "wydrukuj liczby oddzielone myślnikiem", "print the sorted list of names": "wydrukuj posortowaną listę nazw", "print the type of &x": "wydrukuj typ &x", "print the type of x": "wydrukuj typ x", "print the value 5": "wydrukuj wartość 5", "print the value at the address being pointed to (x's address)": "wydrukuj wartość pod wskazanym adresem (adres x)", "print the value at the address being pointed to (y's address)": "wydrukuj wartość pod adresem adres wskazywany (adres y)", "print the value at the address that ptr is holding (x's address)": "wydrukuj wartość pod adresem, który przechowuje ptr (adres x)", "print the value at the memory address of variable x (parentheses not required, but make it easier to read)": "wydrukuj wartość pod adresem pamięci zmiennej x (nawiasy nie są wymagane, ale ułatwiają odczytanie)", "print the value doubled": "wydrukuj wartość podwojoną", "print the value of a literal": "wydrukuj wartość literału", "print the value of a variable": "wydrukuj wartość a zmienna", "print the value of element with index 3": "wydrukuj wartość elementu o indeksie 3", "print the value of element with index 3 (7)": "wydrukuj wartość elementu o indeksie 3 (7)", "print the value of the element it points to": "wydrukuj wartość elementu, na który wskazuje", "print the value of the first element": "wydrukuj wartość pierwszego elementu", "print the value of variable x": "wydrukuj wartość zmiennej x", "print the value of x (5)": "wydrukuj wartość x (5)", "print the value of x to the screen": "wydrukuj wartość x na ekran", "print the value of x to the screen (who knows what we'll get, because x is uninitialized)": "wypisz wartość x na ekran (kto wie, co otrzymamy, bo x jest niezainicjowane)", "print the value of x via ref (5)": "wydrukuj wartość x przez ref (5)", "print the value via the copy": "wydrukuj wartość przez kopię", "print the value via the dereferenced pointer": "wydrukuj wartość za pomocą wyłuskanego wskaźnika", "print the value via the reference": "wydrukuj wartość przez odwołanie", "print true or false instead of 1 or 0": "wydrukuj wartość prawda lub fałsz zamiast 1 lub 0", "print true or false rather than 1 or 0": "wydrukuj prawdę lub fałsz zamiast 1 lub 0", "print value of nested block apples": "wydrukuj wartość zagnieżdżonego bloku jabłka", "print value of outer block apples": "wydrukuj wartość zewnętrznego bloku jabłka", "print value of variable ch as an int": "wydrukuj wartość zmiennej ch jako liczbę całkowitą", "print value of x (0110), then 1": "wypisz wartość x (0110), następnie 1", "print value of x (5) to console": "wypisz wartość x (5) do konsoli", "print value of x through dereferenced ptr": "wypisz wartość x przez wyłuskany ptr", "print x left shifted by 1 (1100)": "wydrukuj x przesunięte w lewo o 1 (1100)", "print x's value": "wydrukuj wartość x", "print your card rank and suit here": "wydrukuj tutaj rangę i kolor swojej karty", "print(1); // ambiguous function call": "drukuj(1); // niejednoznaczne wywołanie funkcji", "printString(sv);   // compile error: won't implicitly convert std::string_view to a std::string": "printString(sv); // błąd kompilacji: nie zostanie domyślnie przekonwertowany std::string_view na std::string", "printString(sv); // compile error: a std::string_view won't implicitly convert to a std::string": "printString(sv); // błąd kompilacji: std::string_view nie zostanie domyślnie przekonwertowany na std::string", "printValue is public in Derived, so this is okay": "printValue jest publiczny w Derived, więc wszystko jest w porządku", "prints 97 (since r2 is a reference to int)": "drukuje 97 (ponieważ r2 jest odniesieniem do int)", "prints 97 -- does this make sense?": "drukuje 97 -- czy to ma sens?", "prints a double value": "wypisuje wartość podwójną wartość", "prints value of outer block apples": "wypisuje wartość zewnętrznych bloków jabłek", "prints value of ref (5)": "wypisuje wartość ref (5)", "prints value of x (5)": "wypisuje wartość x (5)", "private access specifier not required here since classes default to private members": "prywatny specyfikator dostępu nie jest tutaj wymagany, ponieważ klasy domyślnie mają składowe prywatne", "private constructor can't be called by public": "prywatny konstruktor nie może zostać wywołany przez publiczne", "private due to above private: specifier": "prywatny ze względu na powyższe prywatne: specyfikator", "private members can be accessed in member functions": "dostęp do elementów prywatnych można uzyskać w funkcjach składowych", "private members can not be accessed by the public": "do elementów prywatnych nie można uzyskać dostępu publicznego", "promoted to match foo(double)": "promowane do dopasowania foo(double)", "promoted to match foo(int)": "promowane do dopasowania foo(int)", "protected so only derived classes can access": "chronione, więc dostęp tylko klasy pochodne mają dostęp", "ptr goes out of scope, Resource destroyed": "ptr wykracza poza zakres, zasób zniszczony", "ptr holds the address of x": "ptr przechowuje adres x", "ptr initialized to point at x": "ptr zainicjowany tak, aby wskazywał x", "ptr is a normal (non-const) pointer": "ptr jest normalnym (nie stałym) wskaźnikiem", "ptr is a null pointer": "ptr jest wskaźnikiem zerowym", "ptr is a null pointer, and is not holding an address": "ptr jest wskaźnikiem zerowym i nie przechowuje adresu", "ptr is a pointer to a Triangle, which contains members that are pointers to a Point": "ptr jest wskaźnikiem do trójkąta, który zawiera elementy będące wskaźnikami do punktu", "ptr is a pointer, use ->": "ptr jest wskaźnikiem, użyj ->", "ptr is a void pointer": "ptr jest wskaźnikiem pustki", "ptr is a void pointer that is currently a null pointer": "ptr jest wskaźnikiem pustki, który obecnie jest wskaźnikiem zerowym", "ptr is now a null pointer (for example only, don't do this)": "ptr jest teraz wskaźnikiem zerowym (tylko na przykład, nie rób tego)", "ptr is now a null pointer, and is not holding an address": "ptr jest teraz wskaźnikiem zerowym i nie jest trzymający adres", "ptr is now a nullptr": "ptr jest teraz nullptr", "ptr is now dangling and pointing to invalid object": "ptr zwisa teraz i wskazuje na nieprawidłowy obiekt", "ptr now owns the Resource": "ptr jest teraz właścicielem zasobu", "ptr now pointing at object x (no longer a null pointer)": "ptr wskazuje teraz na obiekt x (nie jest już wskaźnikiem zerowym)", "ptr points to a \"const int\"": "ptr wskazuje na „const int”", "ptr points to const int x": "ptr wskazuje na const int x", "ptr points to x": "ptr wskazuje na x", "ptr will always point to x": "ptr zawsze będzie wskazywał x", "ptr1 and ptr2 may not have sequential addresses": "ptr1 i ptr2 może nie mieć adresów sekwencyjnych", "ptr1 goes out of scope here, and the allocated Resource is destroyed": "ptr1 wykracza tutaj poza zakres, a przydzielony zasób ulega zniszczeniu", "ptr1 goes out of scope here, and the allocated Resource is destroyed again": "ptr1 wykracza poza zakres tutaj, a przydzielony zasób zostaje zniszczony ponownie", "ptr2 goes out of scope here, and the allocated Resource is destroyed": "ptr2 wykracza poza zakres tutaj, a przydzielony zasób zostaje zniszczony", "ptr2 goes out of scope here, but nothing happens": "ptr2 wykracza tutaj poza zakres, ale nic się nie dzieje", "ptr2 is a valid pointer": "ptr2 jest prawidłowym wskaźnikiem", "ptr2 is now a null pointer": "ptr2 jest teraz wskaźnikiem zerowym", "ptr2 is now a null pointer (for example only, don't do this)": "ptr2 jest teraz wskaźnikiem zerowym (tylko na przykład, nie rób tego this)", "ptr2 is uninitialized": "ptr2 jest niezainicjowany", "public due to above public: specifier": "public z powodu powyższego public: specyfikator", "public members can be accessed by the public": "publiczne elementy członkowskie mogą być dostępne publicznie", "public members can be accessed in member functions of the class type": "publiczne elementy członkowskie mogą być dostępne w funkcjach składowych typu klasy", "push_back version (C++17 or older)": "wersja push_back (C++ 17 lub starsza)", "push_back won't use explicit constructors, emplace_back will": "push_back nie będzie używać jawnych konstruktorzy, emplace_back", "push_back() pushes an element on the stack": "push_back() umieści element na stosie", "put a value in that memory location": "umieści wartość w tym miejscu pamięci", "put the value 7 in the first element of the array": "umieści wartość 7 w pierwszym elemencie tablicy", "put us back in 'normal' operation mode": "wprowadzi nas z powrotem do „normalnego” trybu pracy", "put us back in 'normal' operation mode (if needed)": "wprowadzi nas z powrotem do „normalnego” trybu pracy (jeśli potrzebne)", "r-value argument calls r-value version of function": "argument r-wartość wywołuje wersję funkcji r-wartość", "r-value arguments will select this function": "argumenty-wartość r wybierają tę funkcję", "r-value reference initialized with r-value 5": "odniesienie do wartości r zainicjowane wartością r 5", "r-value reference to temporary Fraction": "odniesienie do wartości r do tymczasowego ułamka", "r-value references": "odniesienia do wartości r", "rBase is an lvalue reference (not an rvalue reference)": "rBase to odniesienie do wartości (a nie odniesienie do wartości)", "range-based for loop": "oparty na zakresie dla pętli", "range-based for-loop": "oparty na zakresie pętli for", "rather than rewrite the file. We do not need to pass in std::ios::out": "zamiast przepisywania pliku. Nie musimy przekazywać std::ios::out", "read a full line of text into color": "czytaj całą linię tekstu na kolor", "read a full line of text into name": "czytaj całą linię tekstu na nazwę", "read in value of x from user": "wczytaj wartość x od użytkownika", "reallocate resizes the array.  Any existing elements will be destroyed.  This function operates quickly.": "reallocate zmienia rozmiar tablicy. Wszelkie istniejące elementy zostaną zniszczone. Funkcja ta działa szybko.", "reassign pointer to address of value": "przypisz ponownie wskaźnik do adresu wartości", "recursive function call": "wywołanie funkcji rekurencyjnej", "red is considered part of Color's scope region": "czerwony jest uważany za część obszaru zasięgu Color", "redundant, but makes it clear that what follows is private": "zbędny, ale wyjaśnia, że to, co następuje, jest prywatne", "ref is a reference to x": "ref jest odniesieniem do x", "ref is an lvalue reference to x (when used with a type, & means lvalue reference)": "ref jest odniesieniem do wartości x (w przypadku użycia z typ, & oznacza odwołanie do lwartości)", "ref is an lvalue reference variable that can now be used as an alias for variable x": "ref jest zmienną referencyjną lwartości, która może być teraz użyta jako alias dla zmiennej x", "ref is destroyed here -- x is unaware of this": "ref jest tutaj niszczony -- x nie jest tego świadomy", "ref is now an alias for `x`": "ref jest teraz aliasem dla `x`", "ref is now an alias for variable x": "ref jest teraz aliasem dla zmiennej x", "ref is now an alias for x": "ref jest teraz aliasem for x", "reference becomes dangling when return value of createEmployee() is destroyed": "referencja zawiesza się, gdy wartość zwracana przez createEmployee() zostaje zniszczona", "reference to variable value": "odniesienie do wartości zmiennej", "reference_wrapper": "opakowanie_odniesienia", "references don't have a top-level const syntax, as they are implicitly top-level const": "referencje nie mają składni const najwyższego poziomu, ponieważ domyślnie są const najwyższego poziomu", "refptr is now a reference to a pointer": "refptr jest teraz referencją do a wskaźnik", "register cleanup() to be called automatically when std::exit() is called": "register cleanup() będzie wywoływany automatycznie po wywołaniu std::exit()", "reminder: low-precision floating point literals of the same type can be tested for equality": "przypomnienie: literały zmiennoprzecinkowe o niskiej precyzji tego samego typu można przetestować pod kątem równości", "reminder: std::uint8_t will likely print as a char": "przypomnienie: std::uint8_t prawdopodobnie zostanie wydrukowane jako znak", "reminder: std::vector can't be constexpr": "przypomnienie: std::vector nie może być constexpr", "remove any extraneous input (only if extraction succeded)": "usuń wszelkie dodatkowe dane wejściowe (tylko jeśli wyodrębnienie się powiodło)", "remove inline keyword if not C++17 capable": "usuń wbudowane słowo kluczowe, jeśli nie obsługuje C++17", "removed -- before x": "usunięto -- przed x", "removed the access functions in this example (since they aren't used)": "usunięto funkcje dostępu w tym przykładzie (ponieważ nie są używane)", "required to use std::string_view": "wymagane do użycia std::string_view", "requires C++20 for floating point non-type parameters": "wymaga C++20 dla parametrów zmiennoprzecinkowych nietypowych", "requires an overloaded Car::operator<": "wymaga przeciążonego Car::operator<", "requires an overloaded Car::operator<<": "wymaga przeciążonego Car::operator<<", "requires an overloaded operator<": "wymaga przeciążonego operatora<", "requires an overloaded operator<<": "wymaga przeciążonego operator<<", "requires constructor to be constexpr when evaluated at compile-time": "wymaga, aby konstruktor był constexpr podczas oceny w czasie kompilacji", "requires greater() to be constexpr when evaluated at compile-time": "wymaga, aby funkcja Great() była constexpr podczas oceny w czasie kompilacji", "requires object to call": "wymaga wywołania obiektu", "res goes out of scope here, and destroys the allocated Resource for us": "res wykracza poza tutaj zakres i niszczy przydzielony nam zasób", "res goes out of scope here, and the allocated Resource is destroyed": "res wykracza poza zakres tutaj, a przydzielony zasób jest zniszczone", "res1 and res2 go out of scope here": "res1 i res2 wychodzą tutaj poza zakres", "res2 = res1; // Won't compile: copy assignment is disabled": "res2 = res1; // Nie zostanie skompilowany: przypisanie kopii jest wyłączone", "res2 assumes ownership, res1 is set to null": "res2 przejmuje własność, res1 jest ustawione na null", "reserve space for 6 elements (but do not change length)": "zarezerwuj miejsce na 6 elementów (ale nie zmieniaj długości)", "reset all elements of the matrix to 0.0": "zresetuj wszystkie elementy macierzy do 0.0", "reset the input stream to good": "zresetuj strumień wejściowy do dobrego", "reset the state bits back to goodbit so we can use ignore()": "zresetuj bity stanu do dobrego, więc możemy można użyć funkcji ignorowania()", "reset the view": "zresetuj widok", "resize resizes the array.  Any existing elements will be kept.  This function operates slowly.": "resize zmienia rozmiar tablicy. Wszelkie istniejące elementy zostaną zachowane. Ta funkcja działa powoli.", "resize to 0 elements": "zmień rozmiar na 0 elementów", "resize to 3 elements": "zmień rozmiar na 3 elementy", "resize to 5 elements": "zmień rozmiar na 5 elementów", "resolves to Cow::speak(), prints \"Moo\"": "przekształca się w Cow::speak(), wypisuje \"Moo\"", "resolves to max<int, double>": "rozwiązuje do max<int, double>", "resolves to print(char)": "rozwiązuje do print(char)", "resolves to print(std::string_view)": "rozpoczyna drukowanie(std::string_view)", "rest of code that uses iostream functionality here": "resztę kodu, który używa tutaj funkcjonalności iostream", "result in an ambiguous function call compilation error (gcc and Clang do this)": "powoduje niejednoznaczny błąd kompilacji wywołania funkcji (robią to gcc i Clang)", "rethrow the existing exception": "ponownie zgłasza istniejący wyjątek", "return *this in case someone wants to chain +='s together": "zwraca *to na wypadek, gdyby ktoś chciał połączyć += w łańcuch razem", "return 0.0 as a sentinel to indicate an error occurred": "zwróć 0,0 jako wskaźnik wskazujący, że wystąpił błąd", "return a std::string_view viewing \"false\"": "zwróć std::string_view przeglądanie „false”", "return a std::string_view viewing \"true\"": "zwróć std::string_view wyświetlanie „true”", "return a std::string_view viewing f": "zwróć std::string_view przeglądanie f", "return a std::string_view viewing t": "zwróć std::string_view przeglądanie t", "return a std::string_view.": "zwraca std::string_view.", "return an int value": "zwróć wartość int", "return an unnamed Point3d": "zwróć nienazwany Point3d", "return by value": "zwróć według wartości", "return it to the caller": "zwróć ją wywołującemu", "return memory back to operating system": "zwróć pamięć z powrotem do systemu operacyjnego", "return std::all_of(name.begin(), name.end(), [](char ch) {": "return std::all_of(nazwa.begin(), nazwa.end(), [](char ch) {", "return std::equal(input.begin(), input.end(), pattern.begin(), [](char ch, char mask) -> bool {": "return std::equal(input.begin(), input.end(), wzór.begin(), [](char ch, char mask) -> bool {", "return std::ostream so we can chain calls to operator<<": "return std::ostream, abyśmy mogli łączyć wywołania z operatorem<<", "return the existing object so we can chain this operator": "zwróć istniejący obiekt, abyśmy mogli połączyć ten operator", "return the memory pointed to by ptr to the operating system": "zwróć pamięć wskazywaną przez ptr do operacji system", "return the memory to the operating system.  ptr and otherPtr are now dangling pointers.": "zwróć pamięć do systemu operacyjnego. ptr i otherPtr są teraz wskaźnikami wiszącymi.", "return the memory to the operating system.  ptr is now a dangling pointer.": "zwróć pamięć do systemu operacyjnego. ptr jest teraz wskaźnikiem wiszącym.", "return the object": "zwróć obiekt", "return the result of operator() to the caller": "zwróć wynik operatora() do obiektu wywołującego", "return the sum of all the integers between 1 (inclusive) and sumto (inclusive)": "zwróć sumę wszystkich liczb całkowitych pomiędzy 1 (włącznie) i sumto (włącznie)", "return the value 5 back to the caller": "zwróć wartość 5 z powrotem do wywołującego", "return the value of input back to the caller": "zwróć wartość wprowadzoną z powrotem do wywołującego", "return the value the user entered back to the caller": "zwróć wartość wprowadzoną przez użytkownika z powrotem do wywołującego", "return to decimal": "powróć do dziesiętnej", "return type is int": "zwróć wartość typu int", "return value isn't known until runtime": "zwróć wartość nie jest znana do czasu wykonania", "return will cause the function to immediately return to the caller (in this case, main())": "return spowoduje natychmiastowy powrót funkcji do wywołującego (w tym przypadku main())", "return5() is an rvalue expression (since the result is returned by value)": "return5() jest wyrażeniem wartości (ponieważ wynik jest zwracany przez wartość)", "returns 0 for negative numbers": "zwraca 0 dla liczb ujemnych", "returns a const reference": "zwraca stałe odniesienie", "returns a const reference to an existing std::string (cheap)": "zwraca stałe odniesienie do istniejący std::string (tani)", "returns a copy of a std::string (expensive)": "zwraca kopię std::string (drogi)", "returns a non-const reference (don't do this)": "zwraca odwołanie inne niż stałe (nie rób tego)", "returns a reference to an existing std::string (cheap)": "zwraca odwołanie do istniejącego std::string (tani)", "returns an iterator": "zwraca iterator", "returns const reference to temporary object": "zwraca stałą referencję do obiektu tymczasowego", "returns false if can't afford, true if purchased": "zwraca false, jeśli nie stać, true, jeśli zakupiono", "returns int between 1 and 6": "zwraca wartość int pomiędzy 1 a 6", "returns joe.m_name by reference": "zwraca joe.m_name przez odniesienie", "returns length as type `size_type` (alias for `std::size_t`)": "zwraca długość jako typ `size_type` (alias dla `std::size_t`)", "returns std::size_t between 1 and 6": "zwraca std::size_t od 1 do 6", "returns temporary object (initialized using another temporary object)": "zwraca obiekt tymczasowy (zainicjowany przy użyciu innego obiektu tymczasowego)", "returns temporary object (initialized using p)": "zwraca obiekt tymczasowy (zainicjowany przy użyciu p)", "returns the absolute value of x": "zwraca wartość bezwzględną x", "returns the common type of T and U": "zwraca typowy typ T i U", "returns the number of the test that failed, or 0 if all tests passed": "zwraca numer testu, który się nie powiódł, lub 0, jeśli wszystkie testy zakończyły się sukcesem", "returns the value base ^ exponent -- watch out for overflow!": "zwraca wykładnik podstawy wartości ^ -- uważaj na przepełnienie!", "returns true if extraction failed, false otherwise": "zwraca wartość true, jeśli ekstrakcja się nie powiodła, w przeciwnym razie false", "returns true if std::cin has unextracted input on the current line, false otherwise": "zwraca wartość true, jeśli std::cin ma niewyodrębnione dane wejściowe w bieżącej linii, false w przeciwnym razie", "returns true if the user won, false if they lost": "zwraca wartość true jeśli użytkownik wygrał, false, jeśli przegrał", "returns true if user moved successfully": "zwraca wartość true, jeśli użytkownik przeniósł się pomyślnie", "returns true if x and y are equal, false otherwise": "zwraca wartość true, jeśli x i y są równe, false w przeciwnym razie", "returns unsigned int between 1 and 6": "zwraca wartość int bez znaku pomiędzy 1 a 6", "returns value of that variable": "zwraca wartość tej zmiennej", "revalidate sv: sv is now viewing s again": "popraw poprawność sv: sv ponownie przegląda s", "reverse the vector": "odwróć wektor", "rightmost dimension must be constexpr": "najbardziej prawy wymiar musi być constexpr", "risk of collision with some other global variable named gravity": "ryzyko kolizji z inną zmienną globalną o nazwie grawitacja", "rref (and the temporary Fraction) goes out of scope here": "rref (i tymczasowa frakcja) wykracza tutaj poza zakres", "runtime expression (even though the return expression is a constant expression)": "wyrażenie wykonawcze (nawet jeśli wyrażenie zwrotne jest wyrażeniem stałym)", "s is a string symbolic constant": "s jest symboliczną stałą ciągu znaków", "s is an in parameter": "s jest parametrem in", "s is destroyed here, so sv is now viewing an invalid string": "s jest tutaj niszczony, więc sv przegląda teraz nieprawidłowy ciąg", "s makes a copy of its initializer": "s tworzy kopię swojego inicjatora", "s suffix is a std::string literal": "s sufiks jest std::string literał", "s will be replaced with \"Hello, world!\" at compile-time": "s zostanie zastąpiony przez „Witajcie, world!” w czasie kompilacji", "s will be type const char*, not std::string": "s będzie typu const char*, a nie std::string", "s1.x is uninitialized, s1.y is 0, and s1.z is 2": "s1.x jest niezainicjowany, s1.y wynosi 0, a s1.z wynosi 2", "s_member is qualified by class C": "s_member jest kwalifikowany przez klasę C", "s_value is not destroyed here, but becomes inaccessible because it goes out of scope": "s_value nie jest tu niszczone, ale staje się niedostępne, ponieważ wychodzi z zakres", "s_value is public, we can access it directly": "wartość_s jest publiczna, możemy uzyskać do niej bezpośredni dostęp", "save the user's game (even if catch-all handler was hit)": "zapisać grę użytkownika (nawet jeśli został uruchomiony moduł obsługi catch-all)", "sayName is the lambda returned by makeWalrus.": "sayName to lambda zwrócona przez makeWalrus.", "second call to getValueFromUser": "drugie wywołanie getValueFromUser", "second negative, no decimal overflow": "drugie ujemne, brak przepełnienia dziesiętnego", "second negative, possible decimal overflow": "drugie ujemne, możliwe przepełnienie dziesiętne", "second will always have type int, regardless of what type T is": "sekunda zawsze będzie miała typ int, niezależnie od typu T", "seek to current file position": "szukanie do bieżącego pliku position", "selection must be declared outside of the do-while-loop, so we can use it later": "wybór musi zostać zadeklarowany poza pętlą do-while, abyśmy mogli go później użyć", "selection must be declared outside while-loop, so we can use it later": "wybór musi zostać zadeklarowany poza pętlą while, abyśmy mogli go później użyć", "set a value": "ustaw wartość", "set array[9,4] to 3 using our flattened array": "ustaw tablicę[9,4] na 3, używając naszej spłaszczonej tablicy", "set base reference to object": "ustaw bazowe odniesienie do obiektu", "set element 0 to value 5": "ustaw element 0 na wartość 5", "set failure mode manually": "ustaw ręcznie tryb awarii", "set ptr to be a null pointer": "ustaw ptr jako wskaźnik zerowy", "set the global g_mode variable to 2": "ustaw globalną zmienną g_mode na 2", "set the rightmost bit to a 1": "ustaw skrajny prawy bit na 1", "set the stringstream buffer to \"en garde!\"": "ustaw bufor strumienia stringów na „en garde!”", "set to invalid option so we don't match below": "ustaw nieprawidłową opcję, więc nie pasujemy poniżej", "set up a stringstream variable named convert, initialized with the input from argv[1]": "ustaw zmienną strumienia o nazwie Convert, zainicjowaną danymi wejściowymi z argv[1]", "sets the greater of a or b to 7": "ustawia większą z a lub b na 7", "setter for day": "setter na dzień", "setter for month": "setter na miesiąc", "setter for year": "setter na rok", "shares same value as horse": "ma tę samą wartość co koń", "shirt actually stores integral value 2": "koszula faktycznie przechowywana wartość całkowita 2", "should always hold first character of `name` (or `0`)": "powinna zawsze zawierać pierwszy znak `nazwy` (lub `0`)", "should be stored with base -107 and decimal 0": "powinna być przechowywana z podstawą -107 i dziesiętną 0", "should be stored with base 107 and decimal 0": "powinna być zapisana z podstawą 107 i dziesiętną 0", "should fail to compile": "nie powinna się kompilować", "should match first initial of name": "powinna pasować do pierwszego inicjału nazwa", "should not be called": "nie powinna być wywoływana", "should print 5 7": "powinna wypisywać 5 7", "should print 7 5": "powinna wypisywać 7 5", "should produce 8, but produces 2": "powinna wygenerować 8, ale daje 2", "should sum to 1.0": "powinna sumować się do 1.0", "show that we modified arr[1] and y, prints 55": "pokazać, że zmodyfikowaliśmy arr[1] i y, wypisuje 55", "show us the name of the type for d": "pokaż nam nazwę typu dla d", "show us the name of the type for i": "pokaż nam nazwę typu dla i", "show us the type of a + b": "pokaż nam typ a + b", "show us the type of i + d": "pokaż nam typ i + d", "signature print(int)": "podpis print(int)", "signature print(int, double)": "podpis print(int, double)", "signature print(int, int)": "podpis print(int, int)", "simple goes out of scope here": "simple wykracza poza zakres", "simple1 dies here": "simple1 umiera tutaj", "simple2 dies here": "simple2 umiera tutaj", "sin() and cos() take radians, not degrees, so we need to convert": "sin() i cos() przyjmują radiany, a nie stopnie, więc musimy przekonwertować", "sinOut and cosOut are out parameters": "sinOut i cosOut są wyłączone parametry", "since return type is a Cents, this does an implicit conversion from int to Cents using the Cents(int) constructor": "ponieważ zwracany typ to Centy, powoduje to niejawną konwersję z int na Centy przy użyciu konstruktora Cents(int)", "size is a template non-type parameter": "size to parametr nietypowy szablonu", "size is an integral non-type parameter": "size to całkowy parametr nietypowy", "size is still a template non-type parameter": "size jest nadal parametrem innym niż typ szablonu", "size is the expression parameter": "size to parametr wyrażenia", "sizeof returns a value of type std::size_t, so that should be the type of s": "sizeof zwraca wartość typu std::size_t, więc powinien to być typ s", "skipped over": "pominięty", "skips leading whitespace (the space), extracts b, leaves \"\\n\" in stream": "pomija początkowe białe znaki (spację), wyodrębnia b, pozostawia \"\\n\" w strumieniu", "smaller and larger die here": "mniejsza i większa kość tutaj", "smallest 2-byte unsigned value possible": "najmniejsza możliwa 2-bajtowa wartość bez znaku", "smallestIndex is now the index of the smallest element in the remaining array": "smallestIndex jest teraz indeks najmniejszego elementu pozostałej tablicy", "smallestIndex is now the smallest element in the remaining array": "smallestIndex jest teraz najmniejszym elementem pozostałej tablicy", "smallestIndex is the index of the smallest element we've encountered so far.": "smallestIndex to indeks najmniejszego elementu, jaki do tej pory napotkaliśmy.", "smallestIndex is the index of the smallest element we’ve encountered this iteration": "smallestIndex to indeks najmniejszego elementu, jaki napotkaliśmy w tej iteracji", "so changing it here will change the original argument!": "więc zmiana go tutaj spowoduje zmianę pierwotnego argumentu!", "so changing it here won't change the value of the argument": "więc zmiana to tutaj nie zmieni wartości argumentu", "so each of these lines will cause a compile error!": "więc każda z tych linii spowoduje błąd kompilacji!", "so execution continues here": "więc wykonywanie jest kontynuowane tutaj", "so execution starts here": "więc wykonywanie zaczyna się tutaj", "so it will implicitly convert the right hand side of each assignment to a House": "więc niejawnie konwertuje prawą stronę każdego przypisania na House", "so iterator \"it\" is now invalidated": "więc iterator „it” jest teraz unieważniany", "so no more testing or nesting required": "więc nie trzeba już testować ani wymagane zagnieżdżanie", "so no std:: prefix is needed here": "więc nie jest tu potrzebny przedrostek std::", "so no std:: prefix is needed here!": "więc nie jest tu potrzebny przedrostek std::!", "so none of this content gets included": "aby żadna treść nie została uwzględniona", "so our array \"ends\" one element sooner": "aby nasza tablica „kończyła” jeden element wcześniej", "so red is put into the global namespace": "więc kolor czerwony został umieszczony w globalnej przestrzeni nazw", "so that it's clearer what the argument represents here": "aby było jaśniejsze, co reprezentuje argument tutaj", "so that only one board appears at a time": "aby na raz pojawiała się tylko jedna tablica", "so that we can use it here": "abyśmy mogli z niej tutaj skorzystać", "so the function can access the private members of FixedPoint2": "aby funkcja mogła uzyskać dostęp do prywatnych elementów StałegoPoint2", "so this line will repeatedly execute": "więc ta linia będzie wielokrotnie wykonywana", "so this means std::cout": "co oznacza std::cout", "so this never executes": "więc to nigdy się nie wykona", "so this will always execute since it's not part of the if-statement": "więc to będzie zawsze wykonane, ponieważ nie jest częścią instrukcji if", "so we can call the const version of operator[]": "więc możemy wywołać stałą wersję operator[]", "so we can use Vector3d here": "abyśmy mogli tutaj użyć Vector3d", "so we can use name here": "abyśmy mogli tutaj użyć name", "so we can't print m_name and m_id directly": "abyśmy nie mogli wydrukować bezpośrednio m_name i m_id", "so we don't need to do so here again": "więc nie musimy tego robić tutaj ponownie", "so we have to use if-statements here": "więc musimy tutaj użyć instrukcji if", "so we will set input stream to fail state": "więc ustawimy strumień wejściowy na niepowodzenie stan", "some class": "jakaś klasa", "some code here": "tutaj jakiś kod", "some compilers (gcc) warn if you have pointer members but no declared copy constructor": "niektóre kompilatory (gcc) ostrzegają, jeśli masz elementy wskaźnikowe, ale nie zadeklarowano konstruktora kopiującego", "some function that returns a const reference": "jakaś funkcja, która zwraca odwołanie do stałej", "some function that returns a pointer": "jakaś funkcja, która zwraca wskaźnik", "some function that returns a reference": "jakaś funkcja, która zwraca referencję", "some function that returns a reference to const": "jakaś funkcja, która zwraca referencję const", "some function that returns a std::string_view": "jakaś funkcja, która zwraca std::string_view", "somewhere later in your code": "gdzieś później w kodzie", "sort accepts a comparison function": "sort akceptuje funkcję porównania", "sort data in backwards alphabetical order": "sortowanie danych w kolejności alfabetycznej wstecz", "sort data in forwards alphabetical order": "sortowanie danych w kolejności alfabetycznej w przód", "sort the array.": "sortowanie tablicy.", "sort the vector": "sortowanie wektor", "sort them in alphabetical order": "sortowanie w kolejności alfabetycznej", "sorted in alphabetical order": "sortowanie w kolejności alfabetycznej", "specialized for type double": "specjalizacja dla typu double", "specifying we want to call max<int>": "określanie, że chcemy wywołać max<int>", "square.h included from main.cpp": "square.h zawarte z main.cpp", "square.h included from wave.h, SQUARE_H is already defined from above": "square.h zawarte z wave.h, SQUARE_H jest już zdefiniowane powyżej", "square.h is also included once here": "kwadrat.h jest również uwzględniony raz tutaj", "square.h is included once here": "kwadrat.h jest uwzględniony raz tutaj", "squares decays to a pointer": "kwadraty zanikają do wskaźnika", "squares decays to an const int* pointer": "kwadraty zanikają do stałej int* wskaźnik", "standalone \\n goes in single quotes": "samodzielny \\n jest ujęty w pojedynczy cudzysłów", "start at index 7 and return 5 characters": "zacznij od indeksu 7 i zwróć 5 znaki", "start of another nested block": "początek kolejnego zagnieżdżonego bloku", "statement labels must be associated with a statement": "etykiety instrukcji muszą być powiązane z instrukcją", "statements here": "tutaj instrukcje", "statements that do task A": "instrukcje wykonujące zadanie A", "statements that do task B": "instrukcje wykonujące zadanie B", "static cast x to a double so we get floating point division": "statyczne rzutowanie x na wartość podwójną, dzięki czemu otrzymamy zmiennoprzecinkowy czas trwania", "static duration via static keyword.  This initializer is only executed once.": "statyczny czas trwania za pomocą statycznego słowa kluczowego. Ten inicjator jest wykonywany tylko raz.", "static member function": "statyczna funkcja składowa", "static_assert because T is a nullptr": "static_assert, ponieważ T jest nullptr", "static_assert because T is a pointer": "static_assert, ponieważ T jest wskaźnikiem", "static_cast Derived to a Base object, so we call the right version of operator<<": "static_cast Pochodzi z obiektu Base, więc wywołujemy właściwą wersję operatora<<", "static_cast our integer to a Pet": "static_cast naszą liczbę całkowitą do Pet", "static_cast return value to int": "static_cast zwraca wartość do int", "static_cast returns a temporary int direct-initialized with value of c": "static_cast zwraca tymczasową int bezpośrednio zainicjowaną wartością c", "static_cast<int> converts double to int, initializes i with int result": "static_cast<int> konwertuje double na int, inicjuje i z int wynik", "std::array<int, 30> arr{}; // For comparison, here's a std::array of 30 value-initialized int elements (requires #including <array>)": "std::array<int, 30> arr{}; // Dla porównania oto std::array składający się z 30 elementów int z inicjowaną wartością (wymaga #włączania <array>)", "std::bitset<8> means we want to store 8 bits": "std::bitset<8> oznacza, że ​​chcemy przechowywać 8 bitów", "std::cin uses operator >>, not operator <<!": "std::cin używa operatora >>, a nie operatora <<!", "std::cout << *voidPtr << '\\n'; // illegal: dereference of void pointer": "std::cout << *voidPtr << '\\n'; // nielegalne: dereferencja wskaźnika pustki", "std::cout << cents;                   // no longer works because cents won't implicit convert to an int": "std::cout << cents; // już nie działa, ponieważ centy nie będą domyślnie konwertowane na int", "std::cout lives in the iostream library": "std::cout znajduje się w bibliotece iostream", "std::cout will treat char* as a C-style string": "std::cout będzie traktował znak* jako ciąg w stylu C", "std::endl will cause the cursor to move to the next line": "std::endl spowoduje przejście kursora do następnej linii", "std::exception::what() returns a const char*, so we must as well": "std::exception::what() zwraca stały znak*, więc też musimy", "std::find returns an iterator pointing to the found element (or the end of the container)": "std::find zwraca iterator wskazujący na znaleziony element (lub koniec kontenera)", "std::function": "std::funkcja", "std::function method that returns a bool and takes two int parameters": "std::function Metoda, która zwraca wartość bool i przyjmuje dwa parametry int", "std::hex allows us to read in a hex value": "std::hex pozwala nam czytać wartość szesnastkową", "std::lock_guard, we don't know that, but it's some type. We know what types are!": "std::lock_guard, tego nie wiemy, ale jest to pewne wpisz. Wiemy jakie są typy!", "std::map can be initialized": "std::map można zainicjować", "std::mdspan calls these extents": "std::mdspan wywołuje te zakresy", "std::min_element and std::max_element": "std::min_element i std::max_element", "std::next returns a pointer to the next element, just like (startElement + 1) would.": "std::next zwraca wskaźnik do następnego elementu, tak jak zrobiłby to (startElement + 1).", "std::next returns the next iterator after sameLetter": "std::next zwraca następny iterator po tej samej literze", "std::optional<int> returns either an int or nothing": "std::opcjonalne<int> zwraca wartość typu int lub nic", "std::ostream is the type for object std::cout": "std::ostream jest typem obiektu std::cout", "std::ostream is the type of std::cout": "std::ostream jest typem std::cout", "std::pair moved_pair{ std::move_if_noexcept(my_pair) }; // We'll uncomment this later": "std::pair przeniesiona_para{ std::move_if_noexcept(moja_para) }; // Odkomentujemy to później", "std::pair moved_pair{std::move(my_pair)}; // comment out this line now": "std::pair przeniesiony_pair{std::move(my_pair)}; // skomentuj teraz tę linię", "std::ref(count) ensures count is treated like a reference": "std::ref(count) gwarantuje, że liczba będzie traktowana jak referencja", "std::runtime_error takes either a null-terminated const char* or a const std::string&.": "std::runtime_error pobiera albo const char* zakończony znakiem null, albo const std::string&.", "std::runtime_error will handle the string": "std::runtime_error obsłuży string", "std::setprecision defined in iomanip header": "std::setprecision zdefiniowany w nagłówku iomanip", "std::size(arr) returns the number of rows": "std::size(arr) zwraca liczbę wierszy", "std::size(arr[0]) returns the number of columns": "std::size(arr[0]) zwraca liczbę kolumn", "std::ssize introduced in C++20": "std::ssize wprowadzony w C++20", "std::string (because we dereferenced getPtr())": "std::string (ponieważ my dereferencja getPtr())", "std::string (reference and top-level const dropped)": "std::string (usunięto odwołanie i stałą najwyższego poziomu)", "std::string (reference dropped)": "std::string (usunięto odwołanie)", "std::string (reference dropped, then top-level const dropped from result)": "std::string (usunięto odwołanie, następnie usunięto stałą najwyższego poziomu z wyniku)", "std::string is an owner": "std::string jest właściciel", "std::string is move capable": "std::string może przenosić", "std::string& (reference dropped, reference reapplied)": "std::string& (odniesienie usunięte, odniesienie ponownie zastosowane)", "std::string* const": "std::string* stała", "std::string_view (reference dropped and top-level const dropped)": "std::string_view (odniesienie usunięte i usunięto stałą najwyższego poziomu)", "std::string_view is a viewer": "std::string_view to przeglądarka", "std::string_view requires C++17": "std::string_view wymaga C++17", "std::string_view used here": "std::string_view użyta tutaj", "std::string_view::find returns std::string_view::npos if it doesn't find": "std::string_view::find zwraca std::string_view::npos, jeśli nie znajdź", "step through each letter of word": "przejdź przez każdą literę słowa", "still works": "nadal działa", "stored as -5.0099999... so we'll need to round this": "zapisaną jako -5,0099999... więc będziemy musieli zaokrąglić to", "stored as 5.0099999... so we'll need to round this": "zapisane jako 5,0099999... więc będziemy musieli zaokrąglić to", "stores x + y in a variable": "zapisuje x + y w zmiennej", "str makes a copy of its initializer": "str tworzy kopię swojego inicjatora", "str provides read-only access to whatever argument is passed in": "str zapewnia dostęp tylko do odczytu do dowolnego argumentu przekazanego", "str will point to the first letter of the C-style string.": "str wskaże pierwszą literę ciągu w stylu C.", "strangely, std::sqrt isn't a constexpr function (until C++26)": "co dziwne, std::sqrt nie jest funkcją constexpr (do C++26)", "strings are a container for characters": "stringi są kontenerem na znaki", "struct members are public by default, can be accessed by anyone": "elementy struct są publiczne domyślnie może uzyskać do niego dostęp każdy", "subscript decayed array to get element 2, prints 5": "tablica z indeksem dolnym, aby uzyskać element 2, wypisuje 5", "subscript ptr to get element 2, prints 5": "ptr z indeksem dolnym, aby uzyskać element 2, wypisuje 5", "subtract Cents - Cents using a friend function": "odejmij centy - centy używając funkcji znajomego", "success ends the encounter": "sukces kończy spotkanie", "such as a switch statement": "takie jak instrukcja switch", "sum can be initialized with intended value": "suma może być zainicjowany zamierzoną wartością", "sum up all the elements": "podsumuj wszystkie elementy", "surprising result: -1 converted to unsigned int, result out of range": "zaskakujący wynik: -1 skonwertowany na unsigned int, wynik poza zakresem", "sv is now viewing \"John\" (does not change name)": "sv przegląda teraz „John” (nie zmienia imienia)", "sv is now viewing name": "sv teraz przegląda nazwę", "sv is now viewing s": "sv przegląda teraz sufiks s", "sv suffix is a std::string_view literal": "Sufiks sv jest literałem std::string_view", "swap if the first element is greater than the second": "zamiana, jeśli pierwszy element jest większy niż drugi", "swap if the second element is greater than the first": "zamiana, jeśli drugi element jest większy niż pierwszy", "swap our start element with our smallest element (this sorts it into the correct place)": "zamień nasz element początkowy z naszym najmniejszym elementem (to sortuje go do prawidłowego miejsce)", "swap the values of x and y": "zamień wartości x i y", "swap values of smaller and larger": "zamień wartości mniejsze i większe", "syntactically acceptable, but avoid this because it's hard to see the decimal point (prefer 0.0)": "składniczo akceptowalne, ale unikaj tego, ponieważ trudno zobaczyć przecinek dziesiętny (preferowane 0,0)", "t and f are destroyed at the end of the function": "t i f są niszczone na końcu funkcji", "tabbed in one tab (4 spaces)": "tabowane w jednej zakładce (4 spacje)", "takeOwnership(ptr); // This doesn't work, need to use move semantics": "takeOwnership(ptr); // To nie działa, należy użyć semantyki przenoszenia", "takes two integers by non-const reference, and returns the greater by reference": "pobiera dwie liczby całkowite przez odniesienie inne niż stałe i zwraca większą przez odniesienie", "target is the value we're trying to determine exists or not.": "cel to wartość, którą próbujemy określić, czy istnieje, czy nie.", "tell compiler to return to the caller -- this is redundant since the return will happen at the end of the function anyway!": "powiedz kompilatorowi, aby wrócił do wywołującego - jest to zbędne, ponieważ powrót i tak nastąpi na końcu funkcji!", "tell the compiler that cout means std::cout": "powiedz kompilatorowi, że cout oznacza std::cout", "tell the compiler we mean std::cout": "powiedz kompilatorowi, że mamy na myśli std::cout", "tells the compiler about a function named \"add\" that takes two int parameters and returns an int.  No body!": "informuje kompilator o funkcji o nazwie „add”, która przyjmuje dwa parametry int i zwraca liczbę int. Żadnej treści!", "tells the compiler about an integer variable named x": "informuje kompilator o zmiennej całkowitej o nazwie x", "tells the compiler this is a template type with no template parameters": "mówi kompilatorowi, że jest to typ szablonu bez parametrów szablonu", "temp dies here": "tymczas umiera tutaj", "template parameter declaration containing no template parameters": "deklaracja parametrów szablonu nie zawierająca parametrów szablonu", "templated operator[] function defined below": "operator szablonowy[] funkcja zdefiniowana poniżej", "temporary Foo, direct-initialized with (1, 2) (similar to `Foo { 1, 2 }`)": "tymczasowe Foo, inicjowane bezpośrednio za pomocą (1, 2) (podobnie do `Foo { 1, 2 }`)", "temporary Foo, value-initialized (identical to `Foo {}`)": "tymczasowe Foo, inicjowane wartością (identyczne z `Foo {}`)", "temporary double initialized with value 5, r1 binds to temporary": "tymczasowe double inicjalizowane wartością 5, r1 łączy się z tymczasowym", "temporary int initialized with value 'a', r2 binds to temporary": "tymczasowym int inicjalizowanym wartością 'a', r2 łączy się z tymczasowy", "temporary test code, should produce 0": "tymczasowy kod testowy, powinien wygenerować 0", "temporary test code, should produce 1": "tymczasowy kod testowy, powinien wygenerować 1", "terminate and return status code 0 to operating system": "zakończ i zwróć kod stanu 0 do systemu operacyjnego", "terminate program if isPrime(0) is true": "zakończ program, jeśli isPrime(0) ma wartość true", "terminate program if isPrime(2) is false": "zakończ program, jeśli isPrime(2) ma wartość false", "text aligned with the previous line for continuation line": "tekst wyrównany do poprzedniej linii dla linii kontynuacji", "the Derived object gets sliced here": "obiekt pochodny zostaje tutaj podzielony", "the Monster should be an owner of its name": "potwór powinien być właścicielem swojej nazwy", "the Resource is destroyed here": "zasób jest tutaj niszczony", "the assignment operator has side effect of changing value of x": "operator przypisania ma efekt uboczny w postaci zmiany wartości x", "the block here ensures block scope for i": "blok tutaj zapewnia zakres bloku dla i", "the cents parameter in the friend version is now the implicit *this parameter": "parametr centów w wersji znajomego jest teraz ukryty *this parametr", "the comparison function is used to check if the current element should be ordered": "funkcja porównania służy do sprawdzenia, czy bieżący element powinien zostać uporządkowany", "the compiler has only seen a forward declaration at this point": "kompilator widział w tym momencie tylko deklarację forward", "the compiler will deduce prime to have length 5": "kompilator wywnioskuje, że liczba pierwsza ma długość 5", "the compiler will error out because it can't deduce a type for y": "kompilator wyświetli błąd, ponieważ nie może wydedukować typu dla y", "the compiler will implicitly convert username to `std::string_view` to match the parameter type.": "kompilator niejawnie skonwertuje nazwę użytkownika na `std::string_view`, aby dopasować typ parametru.", "the constant e is also part of namespace BasicMath": "stała e jest również częścią przestrzeni nazw BasicMath", "the constructor we delegate to": "konstruktor, do którego delegujemy", "the count of numbers we've seen so far": "liczba liczb, które widzieliśmy do tej pory", "the current exception will be implicitly rethrown": "bieżący wyjątek zostanie niejawnie ponownie zgłoszony", "the enum definition must end with a semicolon": "definicja wyliczenia musi kończyć się znakiem średnik", "the following is a template class with no templated parameters": "poniżej znajduje się klasa szablonowa bez parametrów z szablonu", "the function returns early": "funkcja zwraca wcześniej", "the function returns early, and ptr won’t be deleted!": "funkcja wraca wcześniej, a ptr nie zostanie usunięty!", "the function will always return to the caller here": "funkcja zawsze zwróci do wywołującego tutaj", "the generated function max<double>(double, double)": "wygenerowana funkcja max<double>(double, double)", "the generated function max<int>(int, int)": "wygenerowana funkcja max<int>(int, int)", "the int argument will be converted to a double": "argument int zostanie przekonwertowany na podwójny", "the iterator (since we don't care)": "iterator (ponieważ nas to nie obchodzi)", "the left const is low-level, the right const is top-level": "lewa const jest na niskim poziomie, prawa const jest na najwyższym poziomie", "the literal can be negative": "literał może być ujemny", "the matching asterisks to the left": "pasujące gwiazdki po lewej stronie", "the members of std::pair have predefined names `first` and `second`": "elementy std::pair mają predefiniowane nazwy `pierwszy` i `drugi`", "the missing tile": "brakująca płytka", "the number 2 is the only even prime": "liczba 2 jest jedyną parzystą liczbą pierwszą", "the object being referenced (x) now has value 7": "obiekt będący przedmiotem odnośnik (x) ma teraz wartość 7", "the only difference is the type information": "jedyną różnicą jest informacja o typie", "the outer block apples is temporarily hidden": "zewnętrzny blok jabłek jest tymczasowo ukryty", "the preprocessor will replace all subsequent occurrences of gravity in the rest of the file": "preprocesor zastąpi wszystkie kolejne wystąpienia grawitacji w pozostałej części pliku", "the program has a dependency on std::cout here": "program jest tutaj zależny od std::cout", "the result of static casting d to an int is an rvalue expression": "wynikiem statycznego rzutowania d na int jest wartością wyrażenie", "the return statement provides the value that will be returned": "instrukcja return podaje wartość, która zostanie zwrócona", "the return value of generate() dies at the end of the expression": "wartość zwracana przez generate() umiera na końcu wyrażenia", "the semicolon acts as a null statement": "średnik pełni funkcję instrukcji zerowej", "the size of two memory addresses": "rozmiar dwóch adresów pamięci", "the substring. Otherwise it returns the index where the substring occurs": "podciąg. W przeciwnym razie zwraca indeks, w którym występuje podciąg", "the sum of all numbers we've seen so far": "suma wszystkich liczb, które do tej pory widzieliśmy", "the teacher to it.": "nauczyciel do niego.", "the template parameter declaration belonging to the class applies": "obowiązuje szablonowa deklaracja parametrów należących do klasy", "the user has this many guesses": "użytkownik ma tyle domysłów", "the using declaration expires at the end of the current scope": "deklaracja using wygasa na końcu bieżącego zakresu", "the using-directive ends at the end of the current scope": "dyrektywa using kończy się na końcu bieżącego zakresu", "the value of pi": "wartość pi", "then const_cast to discard the const on the returned reference": "następnie const_cast, aby odrzucić stałą ze zwróconego odniesienia", "then keep track of it": "następnie ją śledź", "then pass to function to assign the desired value": "następnie przejdź do funkcji, aby przypisać żądane wartość", "then print the value of that variable here": "następnie wypisz tutaj wartość tej zmiennej", "then right shift the value into the lower 8 bits": "następnie przesuń wartość w prawo do 8 niższych bitów", "then the digit is prime": "wtedy cyfra jest liczbą pierwszą", "then this number isn't prime": "wtedy ta liczba nie jest liczbą pierwszą", "then transfer our dumb pointer from the source to the local object": "następnie przenieś nasz głupi wskaźnik ze źródła do obiektu lokalnego", "then we can dereference the result": "wtedy możemy wyrejestrować wynik", "then we know exactly what version the compiler is running": "wtedy wiemy dokładnie, jaka wersja kompilatora jest uruchomiona", "then we use the new state to generate the next number in the sequence": "następnie używamy nowego stanu do wygenerowania kolejnej liczby w sekwencji", "there is no V2 in this example, so we can't use V2:: as a namespace prefix": "w tym przykładzie nie ma V2, więc nie możemy użyć V2:: jako przedrostka przestrzeni nazw", "there is no deterministic way to solve these equations.": "nie ma deterministycznego sposobu rozwiązania tych równań.", "there is no short literal suffix, so we'll use a variable for this one": "nie ma krótkiego dosłowny przyrostek, więc użyjemy dla tego zmiennej", "there's also no way to replace \"using namespace Foo\" with a different using statement": "nie ma też możliwości zastąpienia „ using namespace Foo” inną instrukcją using", "there's no way to cancel the \"using namespace Foo\" here!": "nie ma tutaj możliwości anulowania „ using namespace Foo”!", "these are our columns": "to są nasze kolumny", "these comments are easier to read": "te komentarze są łatwiejsze do odczytania", "these comments make the code hard to read": "te komentarze sprawiają, że kod trudny do odczytania", "these strings are stored by reference, not value": "te ciągi znaków są przechowywane przez odniesienie, a nie wartość", "this 3d rendering better not have more than 30,000 polygons!": "to renderowanie 3D lepiej nie mieć więcej niż 30 000 wielokątów!", "this = &a inside member function setID()": "this = &a wewnętrzna funkcja składowa setID()", "this = &a inside the Simple constructor": "this = &a wewnątrz prostego konstruktora", "this = &b inside member function setID()": "this = &b wewnętrzna funkcja składowa setID()", "this = &b inside the Simple constructor": "this = &b wewnątrz prostego konstruktora", "this Color to Color comparison is okay": "to porównanie kolorów do kolorów jest w porządku", "this actually creates a Fraction object named f": "w rzeczywistości tworzy to obiekt Fraction o nazwie f", "this actually instantiates a Fraction object named f": "to faktycznie tworzy instancję obiektu Fraction o nazwie f", "this applies to outer block apples": "dotyczy to jabłek z zewnętrznych bloków", "this assignment will invoke the copy assignment": "to przypisanie wywoła kopię przypisanie", "this assignment will invoke the move assignment": "to przypisanie wywoła przypisanie ruchu", "this assigns value 10 to nested block apples, not outer block apples": "to przypisuje wartość 10 do zagnieżdżonych jabłek blokowych, a nie zewnętrznych jabłek blokowych", "this call has no arguments": "to wywołanie nie ma argumentów", "this class is no longer abstract because we defined this function": "ta klasa nie jest już abstrakcyjna, ponieważ zdefiniowaliśmy tę funkcję", "this condition will never be false": "ten warunek nigdy nie będzie fałszywy", "this const applies to ptr, so it is top-level": "ta stała dotyczy ptr, więc tak jest najwyższego poziomu", "this const applies to the object being pointed to, so it is low-level": "ta stała dotyczy obiektu, na który wskazuje, więc jest niskiego poziomu", "this const applies to the object being referenced, so it is low-level": "ta stała dotyczy obiektu, do którego się odwołuje, więc jest niskiego poziomu", "this const applies to x, so it is top-level": "ta stała dotyczy x, więc jest najwyższego poziomu", "this constructor initializes m_isManager": "ten konstruktor inicjuje m_isManager", "this constructor initializes name and id": "ten konstruktor inicjuje nazwę i id", "this declaration of x refers to a different object than the previous x": "ta deklaracja x odnosi się do innego obiektu niż poprzednie x", "this defines a new type called X": "to definiuje nowy typ o nazwie X", "this doesn't work as expected!": "to nie działa zgodnie z oczekiwaniami!", "this even works for classes that support constexpr initialization": "działa to nawet dla klas obsługujących inicjalizację constexpr", "this extern gives g_y external linkage": "to extern daje g_y zewnętrzne powiązanie", "this extern is a forward declaration of a const variable named g_y that is defined somewhere else": "to extern jest deklaracją w przód zmiennej const o nazwie g_y, która jest zdefiniowana gdzie indziej", "this extern is a forward declaration of a variable named g_x that is defined somewhere else": "to extern jest deklaracją w przód zmiennej o nazwie g_x, która jest zdefiniowana gdzie indziej", "this function accepts an integer": "ta funkcja akceptuje liczbę całkowitą", "this function accepts an integer pointer": "ta funkcja akceptuje wskaźnik liczby całkowitej", "this function added": "ta funkcja została dodana", "this function has external linkage, and can be seen by other files": "to funkcja ma zewnętrzne powiązanie i może być widoczna w innych plikach", "this function is specified as non-throwing": "ta funkcja jest określona jako nie rzucająca", "this function is supposed to perform addition": "ta funkcja ma wykonywać dodawanie", "this function now returns an integer value": "ta funkcja zwraca teraz wartość całkowitą", "this function returns an integer value": "ta funkcja zwraca wartość całkowitą", "this gets created and seeded every time the function is called": "jest ona tworzona i zaszczepiana przy każdym wywołaniu funkcji", "this initialized variable is still in scope at statement label 'skip'": "ta zainicjalizowana zmienna jest nadal w zakresie na etykiecie instrukcji „skip”", "this internal g_x is only accessible within a.cpp": "ten wewnętrzny g_x jest dostępny tylko w pliku a.cpp", "this is a constexpr function": "to jest funkcja constexpr", "this is a definition for function foo": "to jest definicja funkcji foo", "this is a definition for variable x": "to jest definicja zmiennej x", "this is a lambda that captures name from the surrounding scope": "to jest lambda, która przechwytuje nazwę z otaczającego zakresu", "this is a member function, so we can access members directly": "to jest funkcja składowa, więc możemy uzyskać bezpośredni dostęp do elementów", "this is a non-constexpr function": "to jest funkcja inna niż constexpr", "this is a null statement": "to jest instrukcja null", "this is a statement label": "to jest etykieta instrukcji", "this is a using-directive that allows us to access names in the std namespace with no namespace prefix": "to jest dyrektywa użycia, która pozwala nam uzyskać dostęp do nazw w przestrzeni nazw std bez przestrzeni nazw prefiks", "this is an infinite loop": "to jest nieskończona pętla", "this is initialization, not a block": "to jest inicjalizacja, a nie blok", "this is much easier to read": "to jest znacznie łatwiejsze do odczytania", "this is no longer associated with the while loop": "to nie jest już powiązane z pętlą while", "this is part of the switch scope, not an implicit block to case 1": "to jest część zakresu przełącznika, a nie ukryty blok dla przypadku 1", "this is the goto statement": "to jest instrukcja goto", "this is the number the user needs to guess": "to jest liczba, którą użytkownik musi odgadnąć", "this is the outermost invocation": "to jest najbardziej zewnętrzne wywołanie", "this is the template parameter declaration": "to jest deklaracja parametru szablonu", "this is the template parameter declaration defining T as a type template parameter": "to jest deklaracja parametru szablonu definiująca T jako parametr szablonu typu", "this line doesn't compile": "ta linia się nie kompiluje", "this line implicitly considered to be inside a block": "ta linia domyślnie uważana za znajdującą się wewnątrz a blok", "this line is ambiguous": "ta linia jest niejednoznaczna", "this line is now unambiguous": "ta linia jest teraz jednoznaczna", "this line is problematic": "ta linia jest problematyczna", "this line is required to create Printer objects, but ignored in this case": "ta linia jest wymagana do tworzenia obiektów Drukarki, ale w tym przypadku ignorowana", "this line is required to create Scanner objects, but ignored in this case": "ta linia jest wymagana do tworzenia obiektów Skanera, ale w tym przypadku ignorowana", "this line will never execute": "ta linia nigdy nie będzie wykonaj", "this loop will execute forever": "ta pętla będzie wykonywana w nieskończoność", "this modifies the actual object x": "to modyfikuje rzeczywisty obiekt x", "this modifies the copy of x, not the actual object x": "to modyfikuje kopię x, a nie rzeczywisty obiekt x", "this must be a preview / experimental support for the next upcoming version.": "to musi być podgląd/eksperymentalne wsparcie dla następnej nadchodzącej wersji.", "this needs to be done last": "należy to zrobić na końcu", "this print() lives in the Foo namespace": "to print() żyje w Foo przestrzeń nazw", "this print() lives in the global namespace": "to print() znajduje się w globalnej przestrzeni nazw", "this refers to template parameter Pair, not class type Pair": "to odnosi się do parametru szablonu Para, a nie typ klasy Para", "this return expression is a constant expression": "to wyrażenie zwrotne jest wyrażeniem stałym", "this return expression is a runtime expression": "to wyrażenie zwrotne jest wyrażeniem wykonawczym", "this return value will invoke the copy constructor": "ta wartość zwracana wywoła konstruktor kopiujący", "this return value will invoke the move constructor": "ta wartość zwracana wywoła przeniesienie konstruktor", "this separate internal g_x is only accessible within main.cpp": "ten oddzielny wewnętrzny g_x jest dostępny tylko w pliku main.cpp", "this statement could do any of the following:": "ta instrukcja może wykonać dowolną z następujących czynności:", "this statement executes": "ta instrukcja jest wykonywana", "this statement is never executed after count reaches 5": "ta instrukcja nigdy nie jest wykonywana, gdy liczba osiągnie 5", "this using declaration tells the compiler that cout should resolve to std::cout": "ta deklaracja użycia informuje kompilator, że cout powinien zostać rozstrzygnięty na std::cout", "this variable is uninitialized": "ta zmienna jest niezainicjowana", "this variable is uninitialized because we haven't given it a value": "ta zmienna jest niezainicjowana, ponieważ nie nadaliśmy jej wartości", "this will have undefined behavior": "będzie miała niezdefiniowane zachowanie", "this will never be printed": "to nigdy nie zostanie wydrukowane", "this won't work as expected since std::cin breaks on whitespace": "to nie będzie działać zgodnie z oczekiwaniami, ponieważ std::cin przerywa białe znaki", "this works because we forward declared add() above": "to działa, ponieważ przekazujemy zadeklarowaną metodę add() powyżej", "this->data is the member, data is the local parameter": "to->dane są element, dane są parametrem lokalnym", "through here": "tutaj", "throw a double variable that was previously defined": "wrzuć podwójną zmienną, która została wcześniej zdefiniowana", "throw a literal C-style (const char*) string": "wrzuć dosłowny ciąg znaków w stylu C (const char*)", "throw a literal integer value": "wrzuć dosłowną wartość całkowitą", "throw an enum value": "wrzuć wartość wyliczeniową", "throw an int exception": "wyrzuć liczbę całkowitą wyjątek", "throw exception of type const char*": "zrzuć wyjątek typu const char*", "throw exception of type double": "zrzuć wyjątek typu double", "throws Derived exception on failure": "zgłasza wyjątek pochodny w przypadku niepowodzenia", "throws int exception on failure": "zgłasza wyjątek int w przypadku niepowodzenia", "thus, anything that tries to copy count will actually copy the reference": "w ten sposób wszystko, co spróbuje skopiować liczbę, w rzeczywistości skopiuje odwołanie", "to avoid shallow copies": "aby uniknąć płytkich kopii", "to directly access the private members of Point3d parameter p": "aby uzyskać bezpośredni dostęp do prywatnego elementy parametru Point3d p", "to get() will perform correctly.  We'll seekg() to the current": "to get() będą działać poprawnie. Będziemy szukać() do bieżącego", "to make it easy to see how many spaces are in the next line": "aby ułatwić sprawdzenie, ile spacji znajduje się w następnym wierszu", "to show 9 digits in f": "aby wyświetlić 9 cyfr w f", "to the same address as the new array we dynamically allocated.  Because": "pod tym samym adresem, co nowa tablica, którą dynamicznie przydzieliliśmy. Ponieważ", "tooLarge is true if x > 100": "tooLarge jest prawdziwe, jeśli x > 100", "towerHeight can only be const (not constexpr) because its initializer is not a constant expression": "towerHeight może być tylko const (nie constexpr), ponieważ jego inicjator nie jest wyrażeniem stałym.", "trailing comma optional but recommended": "przecinek końcowy jest opcjonalny, ale zalecany", "transfer our dumb pointer from the source to our local object": "przenieś nasz głupi wskaźnik ze źródła do naszego obiektu lokalnego", "treated the same as const int*": "traktowany tak samo jak const int*", "true": "PRAWDA", "true evaluates to 1": "true zwraca 1", "true if arr is zero-length": "true jeśli arr ma długość zerową", "true is a boolean literal": "true jest literałem boolowskim", "true; a struct's default constructor is noexcept by default": "true; Domyślnym konstruktorem struktury jest noexcept domyślnie", "true; ints are non-throwing": "true; int nie są rzucane", "try to read a double from the file": "spróbuj odczytać liczbę podwójną z pliku", "try to read a float from the file": "spróbuj odczytać liczbę zmiennoprzecinkową z pliku", "try to read an integer from the file": "spróbuj odczytać liczbę całkowitą z pliku", "try to turn on hex output": "spróbuj włączyć wyjście szesnastkowe", "trying to deallocate the memory again will also lead to undefined behavior.": "ponowna próba zwolnienia pamięci również doprowadzi do niezdefiniowanego zachowania.", "turn bits 4 and 5 off at the same time": "włącz bity 4 i 5 wyłącz jednocześnie", "turn bits 4 and 5 on at the same time": "włącz jednocześnie bity 4 i 5", "turn off the std::ios::showpos flag": "wyłącz flagę std::ios::showpos", "turn on the std::ios::showpos and std::ios::uppercase flag": "włącz flagę std::ios::showpos i std::ios::uppercase", "turn on the std::ios::showpos flag": "włącz flagę std::ios::showpos flag", "turn options 4 and 5 off": "wyłącz opcje 4 i 5", "turn options 4 and 5 on.": "włącz opcje 4 i 5.", "two parameters of the same type": "dwa parametry tego samego typu", "type alias to raw function pointer": "wpisz alias do surowego wskaźnika funkcji", "type alias to std::function": "wpisz alias do std::function", "type changed to std::string&": "typ zmieniony na std::string&", "type deduced as const char(&)[5]": "typ wydedukowany jako const char(&)[5]", "type deduced as const char*": "typ wydedukowany jako const char*", "type deduced as int prime[5]": "typ wydedukowany jako int prime[5]", "type template parameter will match anything": "parametr szablonu typu będzie pasował do wszystkiego", "typename keyword prefix required for dependent type": "przedrostek słowa kluczowego typename wymagany dla zależności przyrostek type", "u suffix causes b to be deduced to unsigned int": "u powoduje wydedukowanie b jako unsigned int", "uh oh!  Which cout do we want here?  The one in the std namespace or the one we defined above?": "uh och! Którego cout tu chcemy? Ta w standardowej przestrzeni nazw czy ta, którą zdefiniowaliśmy powyżej?", "uh oh, we have a narrowing conversion problem here": "uch, mamy tutaj problem zawężającej konwersji", "unconventional (see your psychiatrist) ;)": "niekonwencjonalna (skontaktuj się ze swoim psychiatrą) ;)", "unconventional (should start with lower case letter and be in all lower case)": "niekonwencjonalna (powinna zaczynać się od małej litery i być pisana małymi literami case)", "unconventional (should start with lower case letter)": "niekonwencjonalne (powinno zaczynać się od małej litery)", "undefined behavior due to invalid index": "niezdefiniowane zachowanie z powodu nieprawidłowego indeksu", "undefined behavior from dereferencing a dangling pointer": "niezdefiniowane zachowanie w wyniku wyłuskiwania wiszącego wskaźnika", "undefined behavior: is this 5 + 6, or 6 + 6?": "niezdefiniowane zachowanie: czy to 5 + 6 czy 6 + 6?", "undefined behavior: m_bad1 initialized before m_data": "niezdefiniowane zachowanie: m_bad1 zainicjowany wcześniej m_data", "undefined behavior: m_bad2 initialized before m_data (accessed through fcn())": "niezdefiniowane zachowanie: m_bad2 zainicjowane przed m_data (dostęp poprzez fcn())", "until this point": "aż do tego momentu", "upJohn now owns john": "upJohn jest teraz właścicielem John", "update our object to the extracted values": "zaktualizuj nasz obiekt do wyodrębnionych wartości", "use 'f' suffix so the literal is a float and matches variable type of float": "użyj przyrostka „f”, aby literał był zmiennoprzecinkowy i pasował do zmiennej typu float", "use Animal's default implementation": "użyj domyślnej implementacji Animala", "use Base(int) constructor": "użyj konstruktora Base(int)", "use Bitwise AND to isolate the pixels for our given color,": "użyj Bitwise AND, aby wyizolować piksele dla danego koloru,", "use CTAD to deduce template arguments <House, 3>": "użyj CTAD, aby wydedukować argumenty szablonu <House, 3>", "use CTAD to infer std::array<double, 5>": "użyj CTAD, aby wywnioskować std::array<double, 5>", "use CTAD to infer std::array<int, 5>": "użyj CTAD do wywnioskowania std::array<int, 5>", "use CTAD to infer std::array<int, 6>": "użyj CTAD do wywnioskowania std::array<int, 6>", "use Derived(double) constructor": "użyj konstruktora Derived(double)", "use Derived(double, int) constructor": "użyj konstruktora Derived(double, int)", "use VectPairSI in a function parameter": "użyj VectPairSI w funkcji parametr", "use `this` pointer to access the implicit object and operator-> to select member m_id": "użyj wskaźnika `this`, aby uzyskać dostęp do ukrytego obiektu i operatora->, aby wybrać element m_id", "use access function instead of direct access": "użyj funkcji dostępu zamiast bezpośredniego dostępu", "use address-of operator (&) to get pointer holding address of str": "użyj operatora adresu (&), aby uzyskać wskaźnik przechowujący adres str", "use an expression to multiply num * 2 at the point where we are going to print it": "użyj wyrażenia, aby pomnożyć liczbę * 2 w miejscu, w którym zamierzamy to wydrukować", "use array delete to deallocate array": "użyj usuwania tablicy zwolnij tablicę", "use array new.  Note that length does not need to be constant!": "użyj nowej tablicy. Zauważ, że długość nie musi być stała!", "use auto to deduce signed type, as returned by std::ssize()": "użyj auto, aby wydedukować typ ze znakiem, zwrócony przez std::ssize()", "use bitwise-or to turn that bit on": "użyj bitwise-lub, aby włączyć ten bit", "use data() to avoid sign conversion warning": "użyj data(), aby uniknąć ostrzeżenia o konwersji znaku", "use default constructor to set to (0.0, 0.0, 0.0)": "użyj domyślnego konstruktora, aby ustawić na (0.0, 0.0, 0.0)", "use default copy constructor": "użyj domyślny konstruktor kopiujący", "use default cout precision of 6": "użyj domyślnej precyzji cout wynoszącej 6", "use delegating constructor to set up initial array": "użyj konstruktora delegującego, aby ustawić tablicę początkową", "use dereference operator to print the value at the address that ptr is holding (which is x's address)": "użyj operatora dereferencji, aby wydrukować wartość pod adresem, który przechowuje ptr (który jest adresem x)", "use dereference operator to print the value of the object at the address that ptr is holding (which is x's address)": "użyj operatora dereferencji, aby wydrukować wartość obiektu pod adresem trzymanym przez ptr (który jest adresem x) adres)", "use direct initialization": "użyj bezpośredniej inicjalizacji", "use dynamic cast to convert Base pointer into Derived pointer": "użyj dynamicznego rzutowania, aby przekonwertować wskaźnik bazowy na wskaźnik pochodny", "use explicit initializers for s2.x, s2.y, and s2.z (no default values are used)": "użyj jawnych inicjatorów dla s2.x, s2.y i s2.z (nie są używane żadne wartości domyślne)", "use function template to print array": "użyj szablonu funkcji do wydrukowania tablicy", "use implicit cast to bool to ensure res contains a Resource": "użyj niejawnego rzutowania na bool, aby upewnić się, że res zawiera Zasób", "use implicit conversion to bool to check if o2 has a value": "użyj niejawnej konwersji na bool, aby sprawdzić, czy o2 ma wartość", "use initializer list to initialize the fixed array": "użyj listy inicjatorów, aby zainicjować stałą tablicę", "use lock() to convert weak_ptr to shared_ptr": "użyj lock() do konwersji słabe_ptr na wspólna_ptr", "use member selection operator (.) to select the age member of variable joe": "użyj operatora wyboru elementu (.), aby wybrać element wieku zmiennej joe", "use normal constructor to set size of array appropriately": "użyj normalnego konstruktora, aby odpowiednio ustawić rozmiar tablicy", "use operator<< for left shift": "użyj operator<< dla lewego przesunięcia", "use operator<< for output": "użyj operatora<< dla wyjścia", "use pre-increment to increment Joe's age by 1": "użyj wstępnego inkrementacji, aby zwiększyć wiek Joego o 1", "use std::as_const to get a const version of `this` (as a reference)": "użyj std::as_const, aby uzyskać stałą wersję `this` (jako odniesienie)", "use std::greater to sort in descending order": "użyj std::większy, aby posortować w porządku malejącym", "use std::string::front() to get first letter of `m_name`": "użyj std::string::front() aby uzyskać pierwszą literę `m_name`", "use std::string::front() to get first letter of `name`": "użyj std::string::front() aby uzyskać pierwszą literę `name`", "use std::unique_ptr to automatically deallocate when Storage is destroyed": "użyj std::unique_ptr, aby automatycznie zwolnić alokację w przypadku zniszczenia pamięci", "use std::weak_ptr so m_ptr doesn't keep the Resource alive": "użyj std::weak_ptr, aby m_ptr nie zachowywał zasobu żywy", "use subscript operator to index array element 1": "użyj operatora indeksu dolnego do indeksowania elementu tablicy 1", "use sv suffix so std::array will infer type as std::string_view": "użyj przyrostka sv, aby std::array wywnioskował typ jako std::string_view", "use the Cents constructor and operator+(int, int)": "użyj konstruktora Cents i operatora+(int, int)", "use the Cents constructor and operator-(int, int)": "użyj konstruktora Cents i operatora-(int, int)", "use the doSomething() that exists in namespace Foo": "użyj doSomething() istniejąca w przestrzeni nazw Foo", "use the doSomething() that exists in namespace Goo": "użyj funkcji doSomething() istniejącej w przestrzeni nazw Goo", "use the getName() function we've acquired from the Person base class": "użyj funkcji getName(), którą pozyskaliśmy z klasy bazowej Person", "use the pointer to change the value of x": "użyj wskaźnika, aby zmienić wartość x", "use the pointer to print x's value (5)": "użyj wskaźnika, aby wydrukować wartość x (5)", "use the pointer to print x's value (6)": "użyj wskaźnika, aby wydrukować wartość x (6)", "use the pointer to print x's value (7)": "użyj wskaźnika, aby wydrukować wartość x (7)", "use the reference to change the value of x": "użyj odnośnika, aby zmienić wartość x", "use the reference to print x's value (5)": "użyj odnośnika, aby wydrukować wartość x (5)", "use the reference to print x's value (6)": "użyj odnośnika, aby wydrukować wartość x (6)", "use the reference to print x's value (7)": "użyj odnośnika, aby wydrukować wartość x (7)", "use the standard library greater comparison": "użyj standardowej biblioteki większego porównania", "use toUZ() to avoid sign conversion warning": "użyj toUZ(), aby uniknąć ostrzeżenia o konwersji znaku", "use uniform initialization": "użyj jednolitej inicjalizacji", "use value of N here": "użyj tutaj wartości N", "used in compound expression, condition contains no operators (function call operator excluded)": "użytej w wyrażeniu złożonym, warunek nie zawiera operatorów (z wyłączeniem operatora wywołania funkcji)", "used in compound expression, condition contains operators": "użytego w wyrażeniu złożonym, warunek zawiera operatory", "used to calculate a letter grade.": "używane do obliczania oceny literowej.", "user is expecting this to print 5": "użytkownik oczekuje, że to zostanie wydrukowane 5", "uses !=, infinite loop": "używa !=, nieskończona pętla", "uses <, still terminates": "używa <, nadal kończy", "uses CTAD to infer type Pair<int>": "używa CTAD do wywnioskowania typu Pair<int>", "uses IntArray(int), allocates an array of size 5": "używa IntArray(int), przydziela tablicę rozmiaru 5", "uses IntArray<std::initializer_list<int>, allocates array of size 1": "używa IntArray<std::initializer_list<int>, przydziela tablicę o rozmiarze 1", "uses `auto` to deduce return type from m_name": "używa `auto` do wydedukowania typu zwracanego z m_name", "uses an array of 3 values": "używa tablicy 3 wartości", "uses assignment operator instead of equality operator": "używa operatora przypisania zamiast operatora równości", "using a non-const variable": "używając wartości innej niż stała zmienna", "using enum class Pet from prior example": "używając klasy wyliczeniowej Pet z poprzedniego przykładu", "using namespace Foo ends here": "używając przestrzeni nazw Foo kończy się tutaj", "using namespace Foo expires": "używając przestrzeni nazw Foo wygasa", "using namespace Goo expires": "używając przestrzeni nazw Goo wygasa", "using operator+ to pass the sum of x and y to writeAnswer()": "używając operatora+ do przekazania sumy x i y do writeAnswer()", "val is a function parameter": "val jest parametrem funkcji", "val is a local variable": "val jest zmienną lokalną", "valid (because the parameter is a const reference)": "poprawna (ponieważ parametr jest odniesieniem do stałej)", "valid (but makes a copy)": "poprawna (ale tworzy kopię)", "valid function declaration": "poprawna deklaracja funkcji", "valid: we can assign 5 to x": "poprawna: możemy przypisać 5 do x", "valid: x is a modifiable lvalue expression and 5 is an rvalue expression": "poprawna: x to modyfikowalne wyrażenie lwartości, a 5 to wyrażenie wartości", "value could be 11 or 12, depending on how the above line evaluates!": "wartość może być 11 lub 12, w zależności od oceny powyższej linii!", "value initialization": "inicjalizacja wartości", "value initialization (preferred)": "inicjalizacja wartości (preferowana)", "value initialization, calls Foo() default constructor": "inicjalizacja wartości, wywołuje domyślny konstruktor Foo()", "value initialize a new object and overwrite the implicit object": "value zainicjuj nowy obiekt i zastąp ukryty obiekt", "value initialize s3.x, use default values for s3.y and s3.z": "wartość inicjuje s3.x, używa wartości domyślnych dla s3.y i s3.z", "value initialized (resulting in zero-initialization)": "wartość zainicjowana (w wyniku inicjalizacji zerowej)", "value initialized to 0": "wartość zainicjowana na 0", "value is a copy of the argument": "wartość jest kopią argumentu", "value is destroyed here": "wartość jest tutaj niszczona", "value is not shadowed here, so this refers to the global value": "wartość nie jest tutaj cieniowana, więc odnosi się to do wartości globalnej", "value will be set to a null pointer if the integer allocation fails": "wartość zostanie ustawiona na wskaźnik zerowy, jeśli alokacja liczb całkowitych się nie powiedzie", "value-initialization": "inicjalizacja wartości", "value-initialization (empty braces)": "inicjalizacja wartości (puste nawiasy klamrowe)", "value-initialization / zero-initialization to value 0": "inicjalizacja-wartości / inicjalizacja zera do wartości 0", "value-initialization zero-initializes a to value 0": "inicjalizacja-wartości zero-inicjuje a do wartości 0", "value-initialize all members": "wartość-inicjalizacja wszystkich elementów", "value-initialized by default": "wartość-inicjowana domyślnie", "values can be negative": "wartości mogą być ujemne", "variable name can't start with number": "nazwa zmiennej nie może zaczynać się od liczba", "variable now used somewhere": "zmienna teraz gdzieś używana", "variable width now has value 5": "szerokość zmiennej ma teraz wartość 5", "vector containing 10 int elements, value-initialized to 0": "wektor zawierający 10 elementów int, wartość zainicjowana na 0", "vector containing 10 int values": "wektor zawierający 10 wartości int", "vector containing 4 int elements with values 2, 3, 5, and 7": "wektor zawierający 4 elementy int o wartościach 2, 3, 5 i 7", "vector containing 5 char elements with values 'a', 'e', 'i', 'o', and 'u'.  Uses CTAD (C++17) to deduce element type char (preferred).": "wektor zawierający 5 elementów znakowych o wartościach „a”, „e”, „i”, „o” i „u”. Używa CTAD (C++17) do wywnioskowania typu elementu char (preferowany).", "via (static_cast<T*>(this))": "poprzez (static_cast<T*>(this))", "violation of ODR, we've already defined function add(int, int)": "naruszenie ODR, zdefiniowaliśmy już funkcję add(int, int)", "violation of ODR, we've already defined x": "naruszenie ODR, zdefiniowaliśmy już x", "void here means no parameters": "void tutaj oznacza nie parametry", "void here means no return value": "void tutaj oznacza brak wartości zwracanej", "void means the function does not return a value to the caller": "void oznacza, że funkcja nie zwraca wartości wywołującemu", "warning: 4.1 is a double literal, not a float literal": "ostrzeżenie: 4.1 to literał podwójny, a nie literał zmiennoprzecinkowy", "warning: we're passing in a double value": "ostrzeżenie: przekazujemy podwójną wartość", "wave.h included from main.cpp": "wave.h zawarte w main.cpp", "we added this line": "dodaliśmy to linia", "we are now updating the test score belonging to stan": "aktualnie aktualizujemy wynik testu należący do stan", "we call it here": "nazywamy to tutaj", "we can access Derived::getName through d": "możemy uzyskać dostęp do Derived::getName przez d", "we can access m_cents directly because this is a friend function": "możemy uzyskać bezpośredni dostęp do m_cents, ponieważ jest to funkcja znajomego", "we can access private members e.m_name and e.m_id directly": "możemy uzyskać bezpośredni dostęp do prywatnych członków e.m_name i e.m_id", "we can also pass an rvalue": "możemy również przekazać rvalue", "we can also pass nullptr to a function that has a pointer parameter": "możemy także przekazać nullptr do funkcji, która ma parametr wskaźnika", "we can assume the array length is greater than 3 beyond this point": "możemy założyć, że długość tablicy jest większa niż 3 poza tym punktem", "we can call doSomething() without a namespace prefix": "możemy wywołać doSomething() bez prefiksu przestrzeni nazw", "we can change the value at the address being held": "możemy zmienić wartość pod przechowywanym adresem", "we can do this because m_name is public": "możemy to zrobić, ponieważ m_name to public", "we can even pass rvalues": "możemy nawet przekazywać wartości", "we can instantiate non-const local variables": "możemy tworzyć instancje zmiennych lokalnych innych niż stałe", "we can modify the value of non-const function parameters": "możemy modyfikować wartość parametrów funkcji innych niż stałe", "we can point at another value": "możemy wskazać inną wartość", "we can use 'length' here since we defined it above": "możemy użyć tutaj „długości”, ponieważ zdefiniowaliśmy ją powyżej", "we can use an explicit cast instead": "możemy użyć jawnego rzutowania zamiast", "we can use it here": "możemy go tutaj użyć", "we can use midpoint + 1 as the lower index, since we don't need to retest the midpoint next iteration": "możemy użyć punktu środkowego + 1 jako dolnego indeksu, ponieważ nie musimy ponownie testować punktu środkowego w następnej iteracji", "we can use midpoint - 1 as the upper index, since we don't need to retest the midpoint next iteration": "możemy użyć punktu środkowego - 1 jako górnego indeksu, ponieważ nie musimy ponownie testować punktu środkowego w następnej iteracji", "we changed struct to class": "zmieniliśmy strukturę na klasę", "we could also assign a list of 3 elements here": "możemy również przypisać lista 3 elementów tutaj", "we don't know the Employee yet": "nie znamy jeszcze pracownika", "we don't know the user's ID yet": "nie znamy jeszcze ID użytkownika", "we don't need direct access to private members here": "nie potrzebujemy tutaj bezpośredniego dostępu do prywatnych członków", "we don't need to set array to nullptr/0 here because it's going out of scope immediately after this anyway": "nie musimy tutaj ustawiać tablicy na nullptr/0, ponieważ i tak natychmiast po tym wyjdzie poza zakres", "we don't need to set m_data to null or m_length to 0 here, since the object will be destroyed immediately after this function anyway": "nie musimy ustawiać m_data na null lub m_length na 0, ponieważ obiekt i tak zostanie zniszczony natychmiast po wykonaniu tej funkcji", "we don't need to set names to nullptr/0 here because it's going to go out": "nie musimy tutaj ustawiać nazw na nullptr/0, ponieważ to wyjdzie", "we don't want people creating Animal objects directly,": "nie chcemy, aby ludzie tworzyli bezpośrednio obiekty Animal,", "we know the Employee's ID now": "znamy teraz identyfikator pracownika", "we know the user is 34": "wiemy, że użytkownik jest 34", "we know the user's ID now": "znamy już identyfikator użytkownika", "we meant to call foo(), but instead we're printing foo itself!": "chcieliśmy wywołać foo(), ale zamiast tego wypisujemy samo foo!", "we mention House here": "tutaj wspominamy o House", "we moved the using-statement here, before the #include directive": "przenieśliśmy tutaj instrukcję using, przed dyrektywą #include", "we must explicitly specify <int, 5> here": "musimy jawnie określić <int, 5> tutaj", "we must explicitly specify <int> here": "musimy jawnie podaj tutaj <int>", "we must now pass in a bool value to see if the call was successful": "musimy teraz przekazać wartość bool, aby sprawdzić, czy wywołanie się powiodło", "we need iostream here too since we use it in this file as well": "tutaj też potrzebujemy iostream, ponieważ używamy go również w tym pliku", "we need iostream since we use it in this file": "potrzebujemy iostream, ponieważ używamy go w tym pliku", "we need to modify this": "musimy to zmodyfikować", "we need to resupply a template parameter declaration": "musimy ponownie dostarczyć deklarację parametrów szablonu", "we only have access to arr2": "mamy dostęp tylko do arr2", "we only recurse if n > 1, so this is our termination case for n == 0": "rekursujemy tylko jeśli n > 1, więc to jest nasz przypadek zakończenia dla n == 0", "we should use { 0 } here, but for the sake of example we'll use value initialization instead": "powinniśmy użyć { 0 } tutaj, ale dla przykładu zamiast tego użyjemy inicjalizacji wartości", "we static_cast to int to ensure it prints as an integer": "rzucamy static_cast na int, aby upewnić się, że zostanie wydrukowana jako liczba całkowita", "we still have a type template parameter": "nadal mamy parametr szablonu typu", "we use .get() to get our element out of the std::reference_wrapper": "używamy .get(), aby wyciągnąć nasz element z std::reference_wrapper", "we used a forward slash instead of a backslash here": "użyliśmy ukośnika zamiast ukośnika odwrotnego tutaj", "we'll consider this input to be invalid": "uznamy to wejście za nieprawidłowe", "we'll handle error messaging if extraction failed below": "w przypadku niepowodzenia ekstrakcji zajmiemy się komunikatem o błędzie poniżej", "we'll store it in a variable, using type inference to deduce the type of": "przechowamy to w zmiennej, używając wnioskowania o typie, aby wydedukować typ", "we'll talk more about this line below": "więcej o tej linii porozmawiamy poniżej", "we'll use a reference since we don't know if T is expensive to copy": "użyjemy odniesienia, ponieważ nie wiemy, czy T jest drogie copy", "we'll use stack[0] here so the compiler won't optimize the array away": "użyjemy tutaj stosu [0], aby kompilator nie zoptymalizował tablicy", "we're associated with the Car by ID rather than pointer": "jesteśmy powiązani z samochodem przez identyfikator, a nie wskaźnik", "we're breaking best practices here, but only in this one place": "tutaj łamiemy najlepsze praktyki, ale tylko w tym jednym miejscu", "we're declaring y here because we need it in this outer block later": "deklarujemy y tutaj, ponieważ potrzebujemy go później w tym zewnętrznym bloku", "we're explicitly defining type char here": "jawnie definiujemy typ char tutaj", "we're going to do this character by character": "zrobimy ten znak po znaku", "we're immediately replacing that value so an explicit 0 would be meaningless": "od razu zastępujemy tę wartość, więc jawne 0 nie miałoby sensu", "we're on earth": "jesteśmy na ziemi", "we're passing the address of x to the function": "przekazujemy adres x do funkcji", "we're specializing Storage8 for bool": "specjalizujemy się w Storage8 dla bool", "we're still in hex": "nadal jesteśmy hex", "we're supplying an int argument": "podajemy argument typu int", "we're supplying an string literal argument": "podajemy argument w postaci dosłownego ciągu znaków", "we're telling the compiler that each element is a House": "mówimy kompilatorowi, że każdy element jest domem", "we're using that 0 value here": "używamy tutaj tej wartości 0", "we're using this reference to avoid compiler self-assignment errors": "używamy tego odniesienia, aby uniknąć błędów przy samodzielnym przypisaniu kompilatora", "we've defined the element type as int": "zdefiniowaliśmy element wpisz jako int", "we've explicitly specified type double, so the compiler won't use template argument deduction": "jawnie określiliśmy typ double, więc kompilator nie będzie korzystał z odliczenia argumentów szablonu", "we've specified a base": "podaliśmy bazę", "what do we do here?": "co tutaj robimy?", "what does this do?": "co to robi?", "what happens here?": "co się tutaj dzieje?", "what happens when we pass an int value?": "co się stanie, gdy przekażemy int wartość?", "what will this print?": "co to wyświetli?", "what would this do?": "co by to dało?", "what would this even evaluate to if x wasn't initialized?": "co by to w ogóle dało, gdyby x nie zostało zainicjowane?", "when separated by whitespace": "kiedy oddzielono białymi znakami", "when this invalidates the iterators of v, undefined behavior will result": "kiedy to unieważniło iteratory v, wystąpi niezdefiniowane zachowanie", "when upJohn goes out of scope, it will delete john": "kiedy upJohn wyjdzie poza zakres, zostanie usunięty john", "when we say cout, we mean the cout defined in the std namespace": "kiedy mówimy cout, mamy na myśli cout zdefiniowany w przestrzeni nazw std", "where does the returned value get stored?": "gdzie przechowywana jest zwrócona wartość?", "which doSomething will we get?": "co doSomething otrzymamy?", "which does not match to any case labels": "co nie pasuje do żadnej etykiety przypadków", "which if statement does this else belong to?": "do której instrukcji if należy to jeszcze?", "which matches the case statement here": "która pasuje do instrukcji case tutaj", "which we can do via the data() member function of std::array or std::vector": "co możemy zrobić za pomocą funkcji składowej data() std::array lub std::vector", "which we can then index": "którą możemy następnie zaindeksować", "while it hasn't reach the end": "dopóki nie doszło do końca", "while-loop with explicit index": "pętla while z jawnym indeksem", "who does this represent?": "kogo to reprezentuje?", "who knows what we'll get, because x is uninitialized": "kto wie, co zrobimy get, ponieważ x jest niezainicjowany", "whose body is a null statement": "którego ciało jest instrukcją zerową", "will accept any type of object that has an overloaded operator[]": "zaakceptuje dowolny typ obiektu, który ma przeciążony operator[]", "will always be executed": "będzie zawsze wykonywany", "will always call A::getName": "zawsze wywoła A::getName", "will always call C::getName": "zawsze wywoła C::getName", "will always execute at compile-time and return 6": "będzie zawsze wykonywany w czasie kompilacji i powrotu 6", "will always print 65": "będzie zawsze drukowane 65", "will be compiled since PRINT_JOE is defined": "będzie kompilowane, ponieważ zdefiniowano PRINT_JOE", "will be evaluated at runtime": "będzie oceniane w czasie wykonywania", "will be excluded since PRINT_BOB is not defined": "zostaną wykluczone, ponieważ PRINT_BOB nie jest zdefiniowane", "will call Derived::print()": "wywoła Derived::print()", "will call foo(unsigned int)": "wywoła foo(unsigned int)", "will call foo(unsigned int) since 'u' suffix is unsigned int, so this is now an exact match": "wywoła foo(unsigned int), ponieważ sufiks „u” jest int bez znaku, więc jest to teraz dokładne dopasowanie", "will cause Storage<double> to be implicitly instantiated": "spowoduje niejawne utworzenie instancji Storage<double>", "will default capture width and height by value": "domyślne przechwytywanie szerokości i wysokości według wartości", "will do an implicit conversion of result to double": "wykona niejawną konwersję wyniku na double", "will execute at compile-time": "zostanie wykonany w czasie kompilacji", "will execute at runtime and return 5": "zostanie wykonany w czasie wykonywania i zwróci 5", "will get Fraction 0/1": "otrzyma ułamek 0/1", "will have 2 bytes of padding after a": "będzie miał 2 bajty dopełnienia po a", "will have 2 bytes of padding after c": "będzie miał 2 bajty dopełnienia po c", "will include a copy of pi() here": "będzie zawierać tutaj kopię pi().", "will keep calling this function until it returns false": "będzie wywoływał tę funkcję, dopóki nie zwróci wartości false", "will never be executed": "nigdy nie zostanie wykonany", "will not collide with other global variables named gravity": "nie będzie kolidować z innymi zmiennymi globalnymi zwanymi grawitacją", "will now allocate 6 elements": "przydzieli teraz 6 elementów", "will only compile if type has first and second members": "zostanie skompilowany tylko wtedy, gdy typ ma pierwszego i drugiego członka", "will print the length of the array": "wydrukuje długość tablicy", "will print the size of the array multiplied by the size of an int": "wypisze rozmiar tablicy pomnożony przez rozmiar int", "will resolve to print(int, double)": "zdecyduje się wydrukować (int, double)", "will resolve to print(int, int)": "zdecyduje się wydrukować (int, int)", "will return a const reference": "zwróci stałą referencję", "will return true or false": "zwróci wartość true lub false", "will trigger a std::length_error or allocation exception": "wywoła std::length_error lub wyjątek alokacji", "without the prototype in Cents.h, this would fail to compile": "bez prototypu w Cents.h nie udałoby się tego skompilować", "won't compile because we haven't defined T": "nie zostanie skompilowany, ponieważ nie zdefiniowaliśmy T", "won't do implicit conversions, so we need to make sure `username` has the expected type.": "nie dokona niejawnych konwersji, więc musimy się upewnić, że `nazwa użytkownika` ma oczekiwany typ.", "won't trigger since asserts have been disabled in this translation unit": "nie zostanie wywołane, ponieważ w tej jednostce tłumaczeniowej wyłączono asercje", "won't work, because there's no implicit conversion to int": "nie zadziała, ponieważ nie ma ukrytej konwersji na int", "won't work, missing template arguments": "nie zadziała, brakuje argumentów szablonu", "won't work, variables can't be defined with incomplete type void": "nie będzie działać, nie można zdefiniować zmiennych z niekompletnym typem void", "word is now a const reference": "słowo jest teraz stałym odniesieniem", "works as follows: First we are going to allocate a new array.  Then we": "działa w następujący sposób: Najpierw przydzielimy nową tablicę. Potem my", "works but not great, as we have to define": "działa, ale nie świetnie, jak musimy zdefiniować", "works, but requires us to instantiate an object to call getValue()": "działa, ale wymaga od nas utworzenia instancji obiektu w celu wywołania metody getValue()", "write this function": "napisz tę funkcję", "write this function using a for loop": "napisz tę funkcję za pomocą pętli for", "write your add function template here": "wpisz tutaj szablon funkcji dodawania", "write your mult function template here": "wpisz tutaj swój wielofunkcyjny szablon", "write your sub function template here": "wpisz tutaj szablon swojej funkcji podrzędnej", "wrong -- fcnPtr1 has no parameters, but hoo() does": "źle - fcnPtr1 nie ma parametrów, ale hoo() ma", "wrong -- return types don't match!": "źle - typy zwracane nie pasują!", "wrong: a doesn't have its own initializer": "źle: a nie ma własnego inicjatora", "wrong: a is not initialized to 5!": "źle: a nie jest inicjowane na 5!", "x + 1 is an rvalue expression": "x + 1 jest wyrażeniem wartości", "x + y may evaluate at runtime or compile-time": "x + y mogą być oceniane w czasie wykonywania lub kompilacji", "x = 5 has side effect of assigning 5 to x, evaluates to x": "x = 5 ma efekt uboczny polegający na przypisaniu 5 do x, daje w wyniku x", "x and ref die here": "x i ref umierają tutaj", "x and y are both in scope here": "Zarówno x, jak i y są tutaj objęte zakresem", "x and y are created and enter scope here": "Tworzone są x i y i wprowadź tutaj zakres", "x and y are usable only within add()": "x i y można używać tylko w ramach add()", "x and y created and initialized here": "x i y utworzone i zainicjowane tutaj", "x and y enter scope here": "x i y wprowadzają tutaj zakres", "x can not be used here because it's not in scope yet": "x nie można tutaj użyć, ponieważ nie jest jeszcze objęty zakresem", "x can resolve to type T, and y can resolve to type U": "x może rozwiązać typ T, a y może rozwiązać typ U", "x defined here": "x zdefiniowano tutaj", "x destroyed here": "x zniszczone tutaj", "x enters scope and is created here": "x wchodzi w zakres i jest tutaj tworzony", "x enters scope here and can now be used within this function": "x wchodzi tutaj w zakres i może być teraz używane w ramach tej funkcji", "x evaluates to 3": "x ma wartość 3", "x goes out of scope and is destroyed here": "x wykracza poza zakres i zostaje tutaj zniszczony", "x goes out of scope here": "x wykracza tutaj poza zakres", "x goes out of scope here and can no longer be used": "x wykracza tutaj poza zakres i nie można go już używać", "x has not been modified": "x nie został zmodyfikowany", "x is 16 bits, holds from -32768 to 32767": "x ma 16 bitów i mieści się w zakresie od -32768 do 32767", "x is a modifiable lvalue": "x jest modyfikowalną wartością", "x is a modifiable lvalue expression": "x jest modyfikowalnym wyrażeniem wartości", "x is a non-constant variable": "x jest zmienną nie stałą", "x is a non-modifiable (const) lvalue": "x to niemodyfikowalna (stała) wartość", "x is a non-modifiable lvalue": "x jest niemodyfikowalną wartością", "x is a normal integer variable": "x jest normalną zmienną całkowitą", "x is a runtime constant": "x jest stałą czasu wykonania", "x is a std::string": "x jest std::stringiem", "x is a variable that evaluates to the value held by variable x": "x jest zmienną, której wartością jest wartość przechowywana przez zmienną x", "x is always a 32-bit integer": "x jest zawsze 32-bitową liczbą całkowitą", "x is an in parameter": "x jest parametrem in", "x is an lvalue expression": "x jest wyrażeniem wartości", "x is converted to type int using the user-defined conversion from X to int": "x jest konwertowane na typ int przy użyciu zdefiniowanej przez użytkownika konwersji z X na int", "x is defined within the scope of main()": "x jest zdefiniowane w zakresie main()", "x is evaluated to produce value 2": "x jest oceniane w celu uzyskania wartości 2", "x is evaluated to produce value 5": "x jest oceniane w celu uzyskania wartości 5", "x is incremented to 6, copy of original x is evaluated to the value 5, and 5 is assigned to y": "x jest zwiększane do 6, kopia oryginału x jest oceniana do wartości 5, a 5 jest przypisywane do y", "x is incremented to 6, x is evaluated to the value 6, and 6 is assigned to y": "x jest zwiększane do 6, x jest oceniane do wartości 6, a 6 jest przypisywane do y", "x is known to the compiler at this point": "x jest w tym momencie znane kompilatorowi", "x is no longer known to the compiler": "x nie jest już znane kompilatorowi", "x is non-constexpr": "x nie jest constexpr", "x is not in scope anywhere in this function": "x nie wchodzi w zakres nigdzie tej funkcji", "x is now 5": "x jest teraz 5", "x is now 6": "x wynosi teraz 6", "x is now 7": "x wynosi teraz 7", "x is now const": "x jest teraz const", "x is now passed by reference into reference parameter y (inexpensive)": "x jest teraz przekazywane przez referencję do parametru referencyjnego y (niedrogi)", "x is passed by value (copied) into parameter y (expensive)": "x jest przekazywane przez wartość (kopiowane) do parametru y (drogie)", "x is passed by value (copied) into parameter y (inexpensive)": "x jest przekazywane przez wartość (kopiowane) do parametru y (niedrogi)", "x is qualified by class object obj": "x jest kwalifikowany przez obiekt klasy obj", "x is still alive during this function call": "x jest wciąż aktywny podczas wywołania tej funkcji", "x isn't in scope here": "x nie wchodzi w zakres tutaj", "x makes a copy of its initializer": "x tworzy kopię swojego inicjatora", "x may be 16-bits or 32-bits": "x może być 16-bitowy lub 32-bitowy", "x not declared, cannot assign a value to 5": "x nie zadeklarowany, nie można przypisać wartości 5", "x now has value 6": "x ma teraz wartość 6", "x trivially converted from int to const int": "x w prosty sposób przekonwertowany z int na const int", "x's lifetime begins here": "czas życia x zaczyna się tutaj", "x's lifetime ends here": "czas życia x kończy się tutaj", "y and x go out of scope and are destroyed here": "y i x wychodzą poza zakres i są tutaj niszczone", "y can not be used here because it is out of scope in this block": "y nie mogą być tutaj użyte, ponieważ nie mieszczą się w tym zakresie blok", "y defined here": "y zdefiniowany tutaj", "y enters scope and is created here": "y wchodzi w zakres i jest tutaj tworzony", "y goes out of scope and is destroyed here": "y wychodzi poza zakres i zostaje tutaj zniszczony", "y goes out of scope, and ptr is now dangling": "y wychodzi poza zakres, a ptr jest teraz zwisający", "y is 16 bits, holds from -32768 to 32767": "y ma 16 bitów, utrzymuje się od -32768 do 32767", "y is a const reference": "y jest stałą referencja", "y is a copy of x": "y jest kopią x", "y is bound to the actual object x": "y jest powiązana z rzeczywistym obiektem x", "y is destroyed here": "y jest tutaj niszczone", "y is not an rvalue, but this is legal": "y nie jest wartością, ale jest to dozwolone", "y is of type int": "y jest typu int", "y is only used inside this block, so define it here": "y jest używane tylko w tym bloku, więc zdefiniuj to tutaj", "y is qualified by pointer to class object ptr": "y jest kwalifikowane przez wskaźnik do obiekt klasy ptr", "y not declared yet": "y jeszcze nie zadeklarowany", "y only accepts modifiable lvalues": "y akceptuje tylko modyfikowalne lwartości", "y will use default argument 4, as if we had called print(3, 4)": "y użyje domyślnego argumentu 4, tak jak gdybyśmy wywołali print(3, 4)", "y will use user-supplied argument 2": "y użyje dostarczonego przez użytkownika argumentu 2", "you can return std::size_t if you prefer": "możesz zwrócić std::size_t, jeśli wolisz", "you're probably expecting this to print 65": "prawdopodobnie spodziewasz się, że to wydrukuje 65", "your code here": "twój kod tutaj", "your declarations (and certain types of definitions) here": "twoje deklaracje (i określone typy definicji) tutaj", "z created and initialized here": "z utworzone i zainicjowane tutaj", "z is a local variable": "z jest zmienną lokalną", "z, y, and x destroyed here": "z, y i x zniszczone tutaj", "zero initialized, then default initialized": "zainicjowane zero, następnie domyślnie zainicjowana", "zero() will be evaluated at compile-time": "zero() zostanie obliczona w czasie kompilacji", "zero() will be evaluated at runtime": "zero() zostanie obliczona w czasie wykonania", "{ 10 } interpreted as initializer list, matches list constructor": "{ 10 } zinterpretowana jako lista inicjatorów, pasuje do konstruktora listy", "{} is empty initializer list, matches default constructor": "{} jest pustą listą inicjatorów, pasuje do domyślnego konstruktora", "|| is logical or -- checks if either condition is true": "|| jest logiczne lub -- sprawdza, czy którykolwiek z warunków jest prawdziwy", "\"Alex\" tworzy tymczasowe std::string": "„Alex” tworzywo tymczasowe std::string", "#include <string> // dla C++14": "#include <string> // dla C++14", "'c' skonwertowane na typ int, wypisuje 99": "„c” skonwertowane na typ int, wypisuje 99", "* short, int, long, long long": "* krótki, całkowity, długi, długi, długi", "* unsigned short, unsigned int, unsigned long lub unsigned long long": "* unsigned krótki, unsigned int, unsigned long lub unsigned long long", "... other related constants": "... inne powiązane stałe", "// Rzutowanie x w stylu funkcji na double": "// Rzutowanie x w funkcji rysika na double", "0.0 to double": "0,0 do podwojenia", "1i (uses previously defined variable f)": "1i (wykorzystuje wcześniej zdefiniowaną zmienną f)", "2 calls chained together": "2 połączenia połączone w łańcuch", "3) Choose a random number": "3) Wybierz losową liczbę", "3-elementowa tablica z 5-elementowymi tablicami int": "3-elementowa tablica z 5-elementowymi tablicami int", "30% chance of finding a potion": "30% szans na znalezienie mikstury", "5 przekonwertowane na tymczasowe double, skopiowane do parametru d": "5 przekonwertowane na tymczasowe podwójne, specyficzne do parametru d", "5 to nasz szablon nietypowy argument": "5 na nasz szablon alternatywny argument", "5.0f to typ float": "5.0f, aby wpisać float", "50% chance of fleeing successfully": "50% szans na pomyślną ucieczkę", "5L to typ long": "5L do długiego pisania", "5u to typ unsigned int": "5u, aby wpisać unsigned int", "6 characters + null terminator": "6 znaków + terminator zerowy", "6 to argument przekazany do funkcji printValue()": "6 do argumentu przekazanego do funkcji printValue()", "97 wynosi Kod ASCII dla 'a'": "97 wynosi Kod ASCII dla 'a'", "A better implementation of operator=": "Lepsza implementacja operatora=", "Alex jest naszym najnowszym pracownik": "Alex jest naszym obecnym pracownikiem", "Allocate a Simple dynamically": "Alokuj Simple dynamicznie", "Back up one character": "Utwórz kopię zapasową jednej postaci", "BaseballPlayer publicly inheriting Person": "BaseballPlayer Osoba dziedzicząca publicznie", "Bomb all gone": "Bomba zniknęła", "Brak ucieczki daje potworowi darmowy atak na gracza": "Brak praktycznego potwora, który daje darmowy atak na użytkownika", "C++ 11, wyprowadza std::reference_wrapper<int>": "C++ 11, wyprowadza std::reference_wrapper<int>", "Calculate a multiplication table": "Oblicz tabliczkę mnożenia", "Case 1: Pass variable": "Przypadek 1: Zmienna przekazująca", "Const global variables": "Stałe zmienne globalne", "Constexpr global variables": "Zmienne globalne Constexpr", "Dane sesji gry tutaj": "Dane gry tutaj", "Database creation failed": "Tworzenie bazy danych nie powiodło się", "Declare a char array": "Zadeklaruj tablicę char", "Define some storage units": "Zdefiniuj niektóre jednostki przechowywania", "Deklaracja naszego szablonu klasy Pair": "Deklaracja naszego szablonu klasy Pair", "Dla std::pair, std::make_pair, std::move, std::move_if_noexcept": "Dla std::pair, std::make_pair, std::move, std::move_if_noexcept", "Dla std::string i std::getline": "Dla std::string i std::getline", "Do losowego generowania mikstur": "Do losowego generowania mikstur", "Drukuje posortowane nazwy": "Drukuje posortowane z nazwą", "Dziedzicz z bazy prywatnie": "Dziedzicz z bazy prywatnie", "Dziedzicz z bazy publicznie": "Dziedzicz z bazy publicznej", "Extra credit section": "Dodatkowa sekcja kredytowa", "FcnType trudny do znalezienia": "FcnType wyzwanie do znalezienia", "First randomly generate a monster": "Najpierw losowo wygeneruj potwora", "Foo jest agregatem": "Foo jest agregatem", "Foo jest zdefiniowane w zakresie globalnym": "Foo jest w zakresie globalnym", "Frank got a promotion": "Frank dostał awans", "Game session data": "Dane sesji gry", "Gdy inf wykracza poza zakres, funkcja ifstream": "Gdy w zasięgu poza zakresem, funkcja ifstream", "Generate a random potion": "Wygeneruj losową miksturę", "Handle direction commands": "Obsługuj polecenia kierunku", "Handle division by 0": "Obsługuj dzielenie przez 0", "Handle non-direction commands": "Obsługuj polecenia inne niż kierunkowe", "I am no longer laughing": "Już się nie śmieję", "I saw a blue car yesterday.": "Wczoraj widziałem niebieski samochód.", "Illegal, armor appears twice.": "Nielegalne, zbroja pojawia się dwukrotnie.", "Input validation omitted": "Pominięto sprawdzanie poprawności danych wejściowych", "Instantiate a 32-bit Mersenne Twister": "Utwórz instancję 32-bitowego Mersenne Twister", "Instrukcjacontinue przeskakuje do tego miejsca": "Instrukcjakontynuuj przeskakuje do tego miejsca", "Internal global variables definitions:": "Definicje wewnętrznych zmiennych globalnych:", "Jest to nowa najmniejsza liczba w tej iteracji": "Jest to nowa najmniejsza liczba w tej iteracji", "Joe got a promotion": "Joe dostał awans", "Joe had a birthday": "Joe miał urodziny", "Kiedy outf wykracza poza zakres, ofstream": "Kiedy wychodzi poza zakres, ofstream", "Kilka dodatkowych funkcji tylko dla wygody": "Kilka dodatkowych funkcji tylko dla kobiet", "Klasa Vector3d zdefiniowana w tym pliku": "Klasa Vector3d zdefiniowana w tym pliku", "Konstruktor z parametrami koloru i promienia": "Konstruktor z parametrami koloru promienia", "Kopiuj elementy z oryginalnej tablicy do nowej array": "Kopiuj elementy z oryginalnej tablicy do nowej tablicy", "Kopiuj konstruktor — kopiowanie nie jest dozwolone!": "Kopiuj konstruktor — kopiowanie nie jest oczyszczane!", "Kopiuj przypisanie — kopiowanie jest zabronione!": "Kopiuj przypisanie — kopiowanie jest zabronione!", "Kopiuj src do arr": "Kopiuj src do arr", "Krok 2: zainicjuj rejestrator": "Krok 2: zainijuj rejestrator", "N wydedukowana jako int `5`": "N wydany jako int `5`", "N wydedukowana jako znak `c`": "N jest wyprowadzane jako znak „c”.", "Nadal tak jest?": "Nadal żartuję?", "Najpierw zdefiniuj nasz niewyspecjalizowany szablon klasy": "Najpierw zdefiniuj nasz niewyspecjalizowany szablon klasy", "Napraw to": "Napraw do", "Nasz lekarz doda tego pacjenta": "Nasz lekarz doda tego pacjenta", "No matching id found": "Nie znaleziono pasującego identyfikatora", "Non-constant global variables": "Niestałe zmienne globalne", "Non-optimized version": "Wersja niezoptymalizowana", "Note: no constructors declared": "Uwaga: nie zadeklarowano żadnych konstruktorów", "OK: Deklaracja przekazania funkcji": "OK: Deklaracja przesłania funkcji", "OK: definicja funkcji": "OK: definicja funkcji", "OK: inicjalizacja na false": "OK: inicjalizacja na false", "OK: inicjalizacja na true": "OK: inicjalizacja na prawdę", "OK: int na double jest bezpieczne": "OK: in na double jest bezpieczne", "OK: przypisanie jest dozwolone": "OK: przypisanie jest technologiczne", "OK: ptr wskazuje teraz na const int y": "OK: ptr wskazuje teraz na const int y", "OK: to tylko kolejne identyfikatory/liczby": "OK: do tylko kolejnych identyfikatorów/liczby", "Odpowiednik m_value = 5": "Odpowiednik m_value = 5", "Oto deklaracja funkcji statycznej": "Oto deklaracja funkcji statycznej", "Oto nasz szablon aliasu": "Oto nasz szablon aliasu", "Oto nasza instrukcja przypisania listy": "Oto nasza instrukcja przypisania list", "Oto nasza lambda, bez klauzuli przechwytywania": "Oto nasza lambda, bez stosowania zasad przechwytywania", "Oto nasza zmienna zmiennoprzecinkowa": "Oto nasza zmienna zmiennoprzecinkowa", "Oto podstawienie makra": "Oto podstawnie makra", "Oto przewodnik dedukcji dla naszej pary (wymagany w C++17 lub starszym)": "Oto przewodnik dedukcji dla naszej pary (wymagany w C++17 lub starszym)", "Oto przewodnik po dedukcjach dla nasza para (wymagana tylko w C++17)": "Oto przewodnik po dedukcjach dla naszej para (wymagana tylko w C++17)", "Our extraction succeeded": "Nasza ekstrakcja się powiodła", "Our first fraction": "Nasz pierwszy ułamek", "Our second fraction": "Nasz drugi ułamek", "Overload Cents + int": "Przeciążenie Centy + int", "Overloaded int cast": "Przeciążony incast", "PRAWDA; goo() jest jawnie noexcept(true)": "PRAWDA; goo() jest jawnie noexcept(true)", "Para bailar la bomba": "Aby zatańczyć bombę", "Para jest agregatem": "Para jest agregatem", "Parametr funkcji to kopia argumentu": "Funkcja parametru do kopiowania argumentu", "Parametr non-type kontroluje rozmiar tablicy": "Parametr non-type kontrolowany rozmiar tablicy", "Pierwsza liczba w dowolnym wierszu jest taka sama jak numer wiersza": "Pierwsza liczba w wierszu jest taka sama jak numer wiersza", "Plus jeden znak dla terminatora": "Plus jeden znak dla terminatora", "Point3d jest teraz przyjacielem klasy Vector3d": "Point3d jest teraz przyjacielem klasy Vector3d", "Pracownik publicznie dziedziczy po Person": "Pracownik dziedziczy po Person", "Pracownik to struktura w strukturze Company": "Pracownik do struktury w strukturze firmy", "Pracownik to typ, joe to nazwa zmiennej": "Pracownik do wpisania, joe do nazwy zmiennej", "Private inheritance means:": "Dziedziczenie prywatne oznacza:", "Przed rysowaniem zawsze drukuj puste linie": "Przed rysowaniem zawsze drukuj puste linie", "Przetestuj dodatkowe przypadki -- h/t do czytelnika Sharjeel Safdar za te przypadki testowe": "Przetestuj dodatkowe przypadki -- h/t do czytelnika Sharjeel Safdar za te przypadki testowe", "Przydziel Simple na stosie": "Przydziel Simple na stosie", "Public inheritance means:": "Dziedziczenie publiczne oznacza:", "Query a few states": "Zapytaj o kilka stanów", "Remove any extraneous input": "Usuń wszelkie obce dane wejściowe", "Returns a seeded Mersenne Twister": "Zwraca zaszczepionego Mersenne Twistera", "Rozpocznij jako nullptr": "Rozpocznij jako nullptr", "Run some code x times": "Uruchom jakiś kod x razy", "Rzutowanie x w stylu C na double": "Rzutowanie x w rysiku C na double", "Self-assignment check": "Kontrola samodzielnego przypisania", "Self-assignment detection": "Wykrywanie samodzielnego przypisania", "Square.h zawarty w main.cpp": "Square.h rozwiązania w main.cpp", "Stosuje efekt mikstury do gracza": "Stosuje efekt mikstury do przygotowania", "T jest parametrem szablonu typu": "To jest parametr szablonu typu", "T& operator[](int wiersz, int col) { return m_arr.get()[static_cast<std::size_t>(row * cols() + col)]; }": "T& operator[](int wiersz, int col) { return m_arr.get()[static_cast<std::size_t>(row * cols() + col)]; }", "Ta funkcja dodano": "Ta funkcja została dodana", "Ta funkcja nie zostanie skompilowana": "Ta funkcja nie zostanie skompilowana", "Ta funkcja to constexpr": "Funkcja ta constexpr", "Ta linia zostanie zignorowana.": "Ta linia pozostaniena.", "Teraz dodaj nowy znak": "Teraz nowy dodaj znak", "Teraz ustaw ptr na element 3": "Teraz pt ustawr na element 3", "Teraz zdefiniuj nasz szablon klasy specjalistycznej": "Teraz zdefiniuj nasz szablon klasy specjalistycznej", "Test equality false": "Test równości jest fałszywy", "To jest komentarz wieloliniowy /*": "To jest komentarz wieloliniowy /*", "To jest komentarz wielowierszowy.": "To jest komentarz wielowierszowy.", "To jest proste, to jest int!": "To jest proste, to jest int!", "To jest to samo, co (tablica[9])[4] = 3;": "To żart samo, co (tablica[9])[4] = 3;", "Traditional initialization forms:": "Tradycyjne formy inicjalizacji:", "Tutaj budowane jest PoweredDevice": "Tutaj zbudowany jest PoweredDevice", "Tutaj zdefiniowano KWADRAT_H": "Tutaj zdefiniowano KWADRAT_H", "Twoje inne rzeczy tutaj": "Twoje inne rzeczy tutaj", "Typ userArea jest automatycznie ustalany na podstawie int.": "Typ userArea jest automatycznie ustalany na podstawie int.", "Ustaw maksimum widzianego pierwszego elementu": "Ustaw najważniejszego pierwszego elementu", "Ustaw odpowiednio rozmiar nowej tablicy": "Ustaw odpowiednio rozmiar nowej tablicy", "Ustaw ptr na element 3": "Ustaw ptr na element 3", "Ustaw „Lucy” na „Ricky” i odwrotnie": "Ustaw „Lucy” na „Ricky” i podłącz", "Utworzymy plik o nazwie Sample.txt": "Utworzymy plik o nazwie Sample.txt", "Uwaga: Funkcje w B, C i D to non-const.": "Uwaga: Funkcje w B, C i D na non-const.", "W C++17 typ zmiennej arr jest dedukowany na std::array<int, 7>": "W C++17 typ zmiennej arr jest dedukowany na std::array<int, 7>", "W przeciwnym razie oblicz nowy wynik i dodaj go": "W razie wypadku nowy wynik obliczeniowy i dodaj go", "Wersja akceptowalna, ale nie preferowana": "Wersja akceptowalna, ale nie preferowana", "Whew, no thanks!": "Uff, nie, dziękuję!", "Wstaw nasz nowy element do nowej tablicy": "Wstaw nowy element do nowej tablicy", "Wydedukuj typ i rozmiar": "Wydedukuj typ i rozmiar", "Wydrukuj 10 losowych liczb": "Wydrukuj 10 losowych liczb", "Wydrukuj 100 losowych liczb": "Wydrukuj 100 losowych liczb", "Wydrukuj informacje o Franku": "Wydrukuj informacje o Franku", "Wydrukuj informacje o Joe": "Wydrukuj informacje o Joe", "Wydrukuj kilka losowych liczb": "Wydrukuj kilka losowych liczb", "Wydrukuj statystyki naszego potwora": "Wydrukuj statystyki naszego potwora", "Wydrukuj wszystkie elementy naszego wektora": "Wydrukuj wszystkie elementy naszego wektora", "Wydrukuj wszystkie karty": "Wydrukuj wszystkie karty", "Wydrukuj wszystkie liczby": "Wydrukuj całą liczbę", "Wydrukuj wszystkie liczby od 9 do 0": "Wydrukuj całą liczbę od 9 do 0", "Wymaga C++17 lub nowszy.": "Wymaga C++17 lub nowszy.", "Wyszukaj @search zamiast \"nut\".": "Szukaj @search zamiast \"nakrętka\".", "Zainicjuj wszystkie elementy na 0": "Zainijuj wszystkie elementy na 0", "Zainicjuj wszystkie elementy na 0.0": "Zainijuj wszystkie elementy na 0.0", "Zamiast to:": "Zamiast do:", "Zamknij program teraz": "Zamknij program teraz", "Zapiszemy dwie linie w tym pliku": "Zapisz dwie linie w tym pliku", "Zdefiniuj Storage8 dla bool": "Zdefiniuj Storage8 dla bool", "Zdefiniuj Storage8 dla bool integers": "Zdefiniuj Storage8 dla bool integer", "Zdefiniuj dwuwymiarowy widok w naszej jednowymiarowej tablicy": "Zdefiniuj dwuwymiarowy widok w naszej jednowymiarowej tablicy", "Zdefiniuj dwuwymiarowy zakres w naszej jednowymiarowej tablicy": "Zdefiniuj dwuwymiarowy zakres w naszej jednowymiarowej tablicy", "Zdefiniuj kilka zmiennych typu wyliczeniowego Color": "Zdefiniuj kilka zmiennych typu wyliczeniowego Color", "Zdefiniuj nowe wyliczenie bez zakresu o nazwie Color": "Zdefiniuj nowe wyliczenie bez zakresu o nazwie Color", "Zdefiniuj nowy typ o nazwie Fraction": "Zdefiniuj nowy typ nazwy Fraction", "Zwolnij wszystkie posiadane zasoby": "Zwolnij wszystkie posiadane zasoby", "a has type const double": "a ma typ const double", "a has type const int": "a ma typ const int", "a has type double": "a ma typ double", "a jest tworzone, inicjowane i wchodzi tutaj w zakres": "a jest miejscem, inicjowane i wchodzi tutaj w zakres", "a pair holding two ints": "para zawierająca dwa inty", "a ta linia zawsze zostanie wykonana!": "a ta linia zawsze zostanie wykonana!", "a vector of int pointers": "wektor wskaźników int", "a[row][col], gdzie wiersz = 2 i col = 3": "a[row][col], gdzie wiersz = 2 i col = 3", "access via operator.": "dostęp przez operatora.", "aces start at 11 points": "asy zaczynają się od 11 punktów", "added exclamation point": "dodany wykrzyknik", "aggregate initialize our struct": "agregat inicjuje naszą strukturę", "aktualna definicja getSquareSides": "aktualna definicja getSquareSides", "all arguments defaulted": "wszystkie argumenty domyślnie", "all explicit arguments": "wszystkie jasne argumenty", "arr jest typem niereferencyjnym": "arr jest typem niereferencyjnym", "assume 16-bit ints": "załóż 16-bitowe int", "assume 4 byte integers": "przyjąć 4-bajtowe liczby całkowite", "assume 4 byte ints": "załóż 4-bajtowe int", "assume DMY format": "przyjąć format DMY", "assume a 32-bit application": "załóżmy, że jest to aplikacja 32-bitowa", "automatic duration by default": "domyślnie automatyczny czas trwania", "b jest tworzony, inicjowany i wchodzi tutaj w zakres": "b jest tworzony, inicjowany i wchodzi tutaj w zakres", "b wywnioskowane jako int": "b wywnioskować jako int", "block 1, nesting level 1": "blok 1, poziom zagnieżdżenia 1", "block 2, nesting level 2": "blok 2, poziom zagnieżdżenia 2", "block 3, nesting level 3": "blok 3, poziom zagnieżdżenia 3", "block 4, also nesting level 3": "blok 4, również poziom zagnieżdżenia 3", "blok tutaj zapewnia zakres bloku dla i": "blok tutaj zapewnia zakres prywatny dla i", "brak kopii poprzez przypisanie!": "brak odpowiedzi poprzez przypisanie!", "c jest constexpr int": "c jest constexpr int", "calc average of 4 doubles": "oblicz średnią z 4 dubletów", "calc average of 5 ints": "oblicz średnią z 5 int", "calls operator+(MinMax, int)": "wywołania operatora+(MinMax, int)", "calls overloaded assignment": "wywołania przeciążonego przypisania", "carr przejdzie do typu char*": "Carr przechodzi do typu char*", "case 1: direct binding": "przypadek 1: wiązanie bezpośrednie", "case 2: indirect binding": "przypadek 2: wiązanie pośrednie", "catch-all handler": "moduł obsługi catch-all", "char nietyp parametr szablonu": "char nietypowy parametr szablonu", "clang-format off": "format clang wyłączony", "clang-format on": "włączony format clang", "co doSomething otrzymamy?": "co doCoś otrzymamy?", "co to robi?": "co robić?", "co tutaj robimy?": "co tutaj robimy?", "compile error: ambiguous match": "błąd kompilacji: niejednoznaczne dopasowanie", "compile error: duplicate definition": "błąd kompilacji: zduplikowana definicja", "compile error: narrowing conversion": "błąd kompilacji: zawężanie konwersji", "const T& operator[](int wiersz, int col) const { return m_arr.get()[static_cast<std::size_t>(wiersz * cols() + col)]; }": "const T& operator[](int wiersz, int col) const { return m_arr.get()[static_cast<std::size_t>(wiersz * cols() + col)]; }", "const obiekt typu klasy": "stały obiekt typu klasy", "constexpr ale non-const": "constexpr ale non-const", "copies arr1 into arr2": "kopiuje arr1 do arr2", "cout prints character 'a'": "cout wypisuje znak „a”", "covariant return type": "kowariantny typ zwrotu", "czysty wirtualny funkcja": "czysta funkcja wirtualna", "d utworzony i zainicjalizowany tutaj": "d kontrolowany i zainicjalizowany tutaj", "d wchodzi tutaj w zakres": "d wejdź tutaj w zakres", "declare a normal namespace named V1": "zadeklaruj normalną przestrzeń nazw o nazwie V1", "declare a normal namespace named V2": "zadeklaruj normalną przestrzeń nazw o nazwie V2", "default member initializer": "domyślny inicjator elementu członkowskiego", "define a namespace named Foo": "zdefiniuj przestrzeń nazw o nazwie Foo", "define a namespace named Goo": "zdefiniuj przestrzeń nazw o nazwie Goo", "define a variable named width": "zdefiniuj zmienną o nazwie szerokość", "defines initialized global const": "definiuje zainicjowaną stałą globalną", "defines initialized global constexpr": "definiuje zainicjowany globalny constexpr", "definicja szablonu funkcji": "definicja szablonu funkcji", "definition of variable x": "definicja zmiennej x", "definiuje Random::mt, Random::get() i Random::generate()": "określenie Random::mt, Random::get() i Random::generate()", "definiuje parametr szablonu typu o nazwie Pair (cienie Typ klasy Pair)": "definiuje parametr szablonu typu o parametrze Para (cienie Typ klasy Pair)", "definiuje typ klasy o nazwie Pair": "Określenie typ klasy o nazwie Pair", "deklaracja forward dla Storage potrzebna tutaj w celach informacyjnych": "deklaracja forward dla Storage, zainstalowana tutaj w zakresie komunikacji", "deklaracja forward dla const doSomething": "deklaracja forward dla const doSomething", "deklaracja forward dla funkcji add": "deklaracja forward dla funkcji add", "deklaracja forward dla funkcji foo": "deklaracja forward dla funkcji foo", "deklaracja forward dla funkcji getInteger": "deklaracja forward dla funkcji getInteger", "deklaracja forward dla getSquarePerimeter": "deklaracja forward dla getSquarePerimeter", "deklaracja forward dla getSquareSides": "deklaracja forward dla getSquareSides", "deklaracja forward dla klasy Display": "deklaracja forward dla klasy Display", "deklaracja forward dla klasy Storage": "deklaracja forward dla klasy Storage", "deklaracja forward potrzebna dla tej linii": "deklaracja forward dla tej linii", "deklaracja funkcji forward fcn": "deklaracja funkcji forward fcn", "deleguj do innego konstruktora": "deleguj do innego konstruktora", "destruktor zamknie plik": "destruktor zamknij plik", "direct-list-initialization": "bezpośrednia inicjalizacja listy", "display double first": "najpierw wyświetl podwójnie", "dla CHAR_BIT": "dla CHAR_BIT", "dla EXIT_SUCCESS i EXIT_FAILURE": "dla EXIT_SUCCESS i EXIT_FAILURE", "dla std::as_const": "dla std::as_const", "dla std::copy": "dla std::copy", "dla std::copy()": "dla std::copy()", "dla std::copy_n": "dla std::copy_n", "dla std::is_constant_evaluated": "dla std::is_constant_evaluated", "dla std::is_constant_evaluated()": "dla std::is_constant_evaluated()", "dla std::is_integral i std::is_enum": "dla std::is_integral i std::is_enum", "dla std::is_pointer_v i std::is_null_pointer_v": "dla std::is_pointer_v i std::is_null_pointer_v", "dla std::max i std::copy_n": "dla std::max i std::copy_n", "dla std::reference_wrapper": "dla std::reference_wrapper", "dla std::string": "dla std::string", "dla std::string_view": "dla std::string_view", "dla std::to_underlying() (C++23)": "dla std::to_underlying() (C++23)", "dla std::unique_ptr i std::make_unique": "dla std::unique_ptr i std::make_unique", "dla sufiksu sv": "dla sufiksu sv", "do some random stuff": "zrób jakieś przypadkowe rzeczy", "do something good": "zrobić coś dobrego", "dodaj 5 do akumulatora": "dodaj 5 do zmęczenia", "dodaj obiekt Base do naszego wektora": "dodaj obiekt Baza do naszego wektora", "dodaj obiekt Derived do naszego wektora": "dodaj obiekt Pochodzi z naszego wektora", "dodana nowa funkcja": "dodana nowa funkcja", "dodano tutaj nawias": "dodano tutaj nawias", "doesn't break things": "nie psuje rzeczy", "dopasowuje SomeFcn(float, double) -- float jest promowany do double": "dopasowuje SomeFcn(float, double) -- float jest promowany do double", "dopasowuje SomeFcn(int, double) -- float jest promowany do double": "dopasowuje SomeFcn(int, double) -- float jest promowany do double", "dopasowuje print(Pair<double, int>)": "dopasowuje print(Pair<double, int>)", "dopasowuje print(Point)": "dopasowuje print(Point)", "drukuj 1 -- czy to ma sens?": "drukuj 1 -- czy to ma sens?", "drukuj 27 w formacie szesnastkowym": "drukuj 27 w szesnastkowym", "drukuj e2.m_name": "drukuj e2.m_name", "drukuj oznacza Foo::print": "drukuj oznacza Foo::print", "drukuj wiek Joego": "drukuj wiek Joego", "drukuj wyjustowane do lewej": "drukuj wyjustowane do lewej", "drukuj wyjustowane do prawej": "drukuj wyjustowane do prawa", "drukuje 97 -- czy to ma sens?": "drukuje 97 -- czy to ma sens?", "dwa parametry tego samego typu": "dwa parametry tego samego typu", "dzielenie przez 0 jest niezdefiniowane w matematyce": "podział przez 0 jest niezdefiniowany w matematyce", "dzwoni ::print()": "dzwoni ::print()", "dzwoni Data::print()": "dzwoni Dane::print()", "e to nasza deklaracja zakresu": "e to nasza deklaracja zakresu", "element ma typ const std::reference_wrapper<Base>&": "element ma typ const std::reference_wrapper<Base>&", "end inner/nested block": "koniec bloku wewnętrznego/zagnieżdżonego", "end of lambda": "koniec lambdy", "end of nested block": "koniec zagnieżdżonego bloku", "end of outer block": "koniec bloku zewnętrznego", "end outer block": "koniec bloku zewnętrznego", "error: move assignment deleted": "błąd: usunięto przypisanie przeniesienia", "error: narrowing conversions disallowed": "błąd: niedozwolone zawężanie konwersji", "explicitly defaulted default constructor": "jawnie domyślny konstruktor domyślny", "extern by default": "domyślnie zewnętrzny", "f has 10 significant digits": "f ma 10 cyfr znaczących", "f suffix means float": "przyrostek f oznacza float", "f sufiks powoduje wydedukowanie a jako float": "Przyrostek f powoduje, że a jest traktowane jako liczba zmiennoprzecinkowa", "f4.numerator zainicjalizowany na 5, f4.mianownik zainicjalizowany na 8": "f4.numerator zainicjalizowany na 5, f4.mianownik zainicjalizowany na 8", "faktycznie inicjuje elementy": "faktycznie inicjuje elementy", "floating point version": "wersja zmiennoprzecinkowa", "foo to funkcja": "foo do funkcji", "for Rand() i srand()": "dla Rand() i srand()", "for std::abs (constexpr w C++23)": "dla std::abs (constexpr w C++23)", "forward declaration of Humidity": "deklaracja wilgotności", "funkcja jest constexpr": "funkcja jest constexpr", "funkcja jest teraz consteval": "funkcja jest teraz consteval", "funkcja to constexpr, zwraca const std::string_view&": "funkcja to constexpr, zwraca const std::string_view&", "funkcja wydruku deklaracja": "funkcja wydruku deklaracja", "funkcja zwraca tutaj": "funkcja tutaj zwracająca", "g_x jest inicjalizowane jako pierwsze": "g_x jest inicjalizowane jako pierwsze", "g_x wykracza tutaj poza zakres": "g_x wyprowadza tutaj poza zakres", "generate a random number": "wygenerować liczbę losową", "generate a solved board": "wygeneruj rozwiązaną planszę", "generate a virtual default destructor": "wygeneruj wirtualny domyślny destruktor", "generuje zaszczepiony std::mt19937 i kopiuje go do naszego obiektu globalnego": "zarazi się std::mt19937 i kopiuje go do naszego obiektu globalnego", "getter na rok": "getter to skała", "global variable definitions": "definicje zmiennych globalnych", "good: no conversion required": "dobrze: nie jest wymagana konwersja", "h/t czytelnikowi Waldo za zasugerowanie tego quizu": "h/t czytelnikowi Waldo za zasugerowanie tego quizu", "h/t do czytnika Davida Pinheiro za uproszczenie tego": "h/t do czytnika Davida Pinheiro za uproszczenie tego", "h/t do czytnika EmtyC dla tej wersji": "h/t do czytnika EmtyC dla tej wersji", "h/t do potterman28wxcv dla wariantu tego kodu": "h/t do potterman28wxcv dla wariantu tego kodu", "handle bad input": "poradzić sobie ze złym wejściem", "handle case appropriately": "właściwie obchodzić się ze sprawą", "has a Foo parameter": "ma parametr Foo", "has a double parameter": "ma podwójny parametr", "has default arguments": "ma argumenty domyślne", "has internal linkage": "ma powiązania wewnętrzne", "ignore any extraneous input": "zignoruj ​​wszelkie obce dane wejściowe", "ignore any unanticipated exceptions": "ignorować wszelkie nieprzewidziane wyjątki", "implementacja zdefiniowana przed C++20, -1 od C++20": "implementacja zdefiniowana przed C++20, -1 od C++20", "implicit default constructor": "niejawny konstruktor domyślny", "implicit narrowing conversion": "niejawna konwersja zawężająca", "implicitly generated default constructor": "niejawnie wygenerowany konstruktor domyślny", "indeks 7 jest poza zakresem!": "indeks 7 jest poza zakresem!", "indeks jest bez znaku": "indeks jest bez znaku towarowego", "indeks jest podpisany": "indeks jest podpisany", "inicjator elementu tablicy 0": "inicjator elementu tablicy 0", "inicjator elementu tablicy 1": "inicjator elementu tablicy 1", "inicjator elementu tablicy 2": "inicjator elementu tablicy 2", "initialize a dynamic array since C++11": "zainicjuj tablicę dynamiczną od C++ 11", "inner/nested block": "blok wewnętrzny/zagnieżdżony", "instantiate a VectPairSI variable": "utwórz instancję zmiennej VectPairSI", "int jest typem zwracanym": "int jest typem zwracanym", "int rzutowany na double": "int rzutowany na double", "int8_t jest zwykle typedef dla podpisanego char": "int8_t jest zwykle typedef dla podpisanego char", "invokes move assignment": "wywołuje przypisanie ruchu", "invokes move constructor": "wywołuje konstruktor przenoszenia", "isEven jest false": "jestNawet fałszywe", "iteruj po wszystkich elementach": "iteruj po wszystkich elementach", "jawnie definiujemy typ char tutaj": "jawnie określmy typ char tutaj", "jawnie zamknij plik": "jawnie zamknij plik", "jest tym samym, co": "jest tym samym, co", "klasa mixin Box": "klasa mixin Box", "klasa mixin Label": "klasa mixin Label", "kogo to reprezentuje?": "kogo postawić?", "kompiluje, ale daje niezdefiniowane zachowanie": "kompiluje, ale daje niezdefiniowane zachowanie", "konwertuj 'c' na double i z powrotem": "konwertuj 'c' na double i z powrotem", "konwertuj double 1,23456789 na float i z powrotem": "konwertuj double 1,23456789 na float i z powrotem", "konwertuj double 3,5 na int i z powrotem": "konwertuj double 3,5 na int i z powrotem", "konwertuj double na bool": "konwertuj double na bool", "konwertuj double na float": "konwertuj double na float", "konwertuj double na int": "konwertuj double na int", "konwertuj double na long double": "konwertuj double na long double", "konwertuj int 3 na long i odwrotnie": "konwertuj int 3 na long i odpowiednio", "konwertuj int na bool": "konwertuj na bool", "konwertuj int na double": "konwertuj na double", "konwertuj short na char": "konwertuj krótki na znak", "konwertuj z int na short": "konwertuj z int na short", "konwertuje na typ bazowy, wypisze 1 (C++23)": "konwertuje na typ bazowy, wypisuje 1 (C++23)", "kopia zostanie zniszczona tutaj": "kopia zostanie zniszczona tutaj", "kopiuje m_length elementy str.m_data do m_data": "kopiuje m_length elementy str.m_data do m_data", "kopiuje tutaj #define MY_NAME z Alex.h": "kopiuje tutaj #define MY_NAME z Alex.h", "largest 32-bit unsigned int": "największy 32-bitowy int bez znaku", "left justify output": "lewe wyjustowanie wyjścia", "less-bad version": "mniej zła wersja", "lista do zainicjowania. Drugi argument to ostatnia nieelipsa": "lista do pobrania. Drugi argument do ostatniej nieelipsy", "local variable, no linkage": "zmienna lokalna, bez powiązania", "m/s^2 -- grawitacja jest na tym lekka planet": "m/s^2 -- grawitacja jest na tym lekkiej planecie", "m_data already declared above": "m_data już zadeklarowane powyżej", "m_map.push_back(StudentGrade{std::string{name}});": "m_map.push_back(StudentGrade{std::string{name}});", "main takes no parameters": "main nie przyjmuje żadnych parametrów", "max wchodzi w zakres tutaj": "max wejdź w zakres tutaj", "may throw anything": "może rzucić czymkolwiek", "member initializer list": "lista inicjatorów członków", "missing closing brace": "brak nawiasu zamykającego", "mixin klasa Tooltip": "mixin klasa Podpowiedź", "moja koszula jest zielony": "moja koszula jest zielona", "move backwards 18 bytes": "przejdź do tyłu o 18 bajtów", "move forward 14 bytes": "przejdź do przodu o 14 bajtów", "na samym dole konsoli": "na samym konsoli", "nadal mamy parametr szablonu typu": "nadal mamy parametr szablonu typu", "najpierw modyfikujemy stan": "najpierw modyfikujemy stan", "narr przejdzie do typu int*": "narr przejścia do typu int*", "nasz element jest teraz prywatny": "nasz element jest teraz prywatny", "nasza instrukcja drukowania jest tutaj": "nasza instrukcja jest tutaj", "nasza nowa funkcja pomocnicza": "nasza nowa funkcja pomocnicza", "nasza tablica zawiera elementy typu int": "nasza tablica elementy zawiera typu int", "nauczyciel do niego.": "nauczyciel, zrób to.", "nazywamy to tutaj": "zapraszamy tutaj", "nie definiuj tutaj y": "nie definiuj tutaj y", "nie drukuj liczby, ale wydrukuj dwie spacje": "nie drukuj liczby, ale wydrukuj dwie spacje", "nie jest jasne, czy jest to zmienna lokalna czy globalna z nazwy": "nie jest jasne, czy jest zmienna lokalna czy globalna z nazwą", "nie jest kopiowalna": "nie jest kopiowalna", "nie tworzy kopii": "nie tworzy kopii", "nie tworzy ukrytego bloku": "nie tajnego tajnego prywatnego", "nie znamy jeszcze pracownika": "nie znamy jeszcze pracownika", "niedozwolone: ref jest const": "niedozwolone: ​​ref jest const", "niejawnie iteruje po v": "niejawnie iteruje po v", "niejednoznaczne dopasowanie z int N = 5 i char N = 5": "nie wyjątkowe ograniczenia z int N = 5 i char N = 5", "niejednoznaczne dopasowanie z int N = 99 i char N = 'c'": "nie jednorazowe ograniczenia z int N = 99 i char N = 'c'", "niepoprawne: jest to przypisanie, a nie inicjalizacja": "niepoprawne: jest to przypisanie, a nie inicjalizacja", "niezdefiniowane zachowanie: czy to 5 + 6 czy 6 + 6?": "niezdefiniowane zachowanie: czy do 5 + 6 czy 6 + 6?", "nigdy nie zostanie wykonany": "nigdy nie zostanie wykonane", "no conversion necessary": "nie jest konieczna konwersja", "no extraction took place": "nie doszło do ekstrakcji", "no initializer provided": "nie podano inicjatora", "no nested block needed": "nie jest potrzebny żaden zagnieżdżony blok", "no parameter names": "brak nazw parametrów", "no specified base": "brak określonej bazy", "no suffix means double": "brak przyrostka oznacza podwójne", "no warning generated": "nie wygenerowano żadnego ostrzeżenia", "non-constexpr initialization": "Inicjalizacja inna niż constexpr", "non-default constructor": "konstruktor inny niż domyślny", "non-zero test data": "niezerowe dane testowe", "normal integer variable": "normalna zmienna całkowita", "normalna funkcja niewirtualna": "normalna funkcja niewirtualna", "normalna funkcja wirtualna": "normalna funkcja wirtualna", "note double braces": "zwróć uwagę na podwójne nawiasy klamrowe", "note: no return statement": "uwaga: brak instrukcji return", "note: no virtual keyword": "uwaga: brak wirtualnego słowa kluczowego", "note: private inheritance": "uwaga: spadek prywatny", "note: public inheritance": "uwaga: dziedzictwo publiczne", "nowa int przydziela 4 bajty na stercie": "nowa int przydziela 4 bajty na stercie", "numeryczne awansowanie boola na int": "numeryczne awansowanie boola na int", "numeryczne awansowanie znaku na int": "numeryczne awansowanie na int", "o tym, jak to jest zaimplementowane.": "o tym, jak to jest zaimplementowane.", "obiekt lambda przechowywany w std::function": "obiekt lambda przechowywany w std::function", "obiekt pochodny zostaje tutaj podzielony": "obiekt pochodny pozostałości tutaj", "ok, copies d on heap": "ok, kopiuje d na stertę", "ok: array of 5 ints": "ok: tablica 5 int", "ok: element dnia jest publiczny": "ok: element dnia jest dziennikarz", "ok: list initialized": "ok: lista została zainicjowana", "ok: m_public jest teraz prywatny w Pri": "ok: m_public jest teraz prywatny w Pri", "ok: niedroga konwersja z std::string na std::string_view": "ok: nie można przeprowadzić konwersacji z std::string na std::string_view", "ok: niedroga kopia std::string_view": "ok: niedroga kopia std::string_view", "ok: ocenimy w czasie kompilacji": "ok: zauważmy w czasie przechowywaniai", "ok: ocenimy w czasie wykonywania": "ok: zastosujmy w czasie wykonywania", "ok: to jest std::vector<int>": "ok: żartuję std::vector<int>", "ok: types match": "ok: typy się zgadzają", "okay, array length = 5": "OK, długość tablicy = 5", "okay: m_protected jest teraz prywatny w Pri": "OK: m_protected jest teraz prywatny w Pri", "okay: m_public jest publiczny w Base": "OK: m_public jest ekspertem w Base", "okay: m_public jest publiczny w Pub": "ok: m_public jest profesor w Pub", "okay: m_value jest publiczny w Base": "OK: m_value jest profesorem w Base", "okay: match found": "OK: znaleziono dopasowanie", "okay: ptr wskazuje na „const int”": "OK: ptr wskazuje na „const int”", "oops: operator precedence issue": "ups: problem z pierwszeństwem operatora", "open image file": "otwórz plik obrazu", "operator[] oczekuje indeksu typu std::size_t, konwersja nie jest wymagana": "operator[] indeksu typu std::size_t, konwersja nie jest wymagana", "otherwise do nothing": "w przeciwnym razie nic nie rób", "oto nasza destructor": "oto nasz destruktor", "oto trywialna instrukcja rzutu": "oto trywialna instrukcja rzutu", "our end-expression": "nasze wyrażenie końcowe", "our init-statement": "nasza instrukcja init", "out of range subscript": "indeks dolny poza zakresem", "overwrite our existing point": "nadpisz nasz istniejący punkt", "pass by address": "przejść przez adres", "pass by const address": "przekazać stały adres", "pobierz dwie liczby i zapisz odpowiednio w zmiennych x i y": "pobierz dwie liczby i zapisz odpowiednio w zmiennej x i y", "podajemy argument typu int": "podajemy argument typu int", "podpis print(int)": "wydruk podpisu (int)", "podpis print(int, double)": "podpis print(int, double)", "podpis print(int, int)": "podpis print(int, int)", "podsumuj wszystkie elementy": "podsumuj wszystkie elementy", "poprawna deklaracja funkcji": "poprawna deklaracja funkcji", "poprzez (static_cast<T*>(this))": "poprzez (static_cast<T*>(this))", "posiada parametr Pracownik": "posiada parametr Pracownik", "postfix ma parametr int": "przyrostek ma parametr int", "potrzebuje constexpr i const": "potrzebujesz constexpr i const", "preferuj to jedno": "preferuj do jedno", "preferuj „long long” zamiast „long long int”": "preferuj „to long” zamiast „to long int”", "preferuj „long” zamiast „long int”": "preferuj „long” zamiast „long int”", "preferuj „short” zamiast „short int”": "preferuj „short” zamiast „short int”", "prefix has no parameter": "prefiks nie ma parametru", "prime has length 5": "liczba pierwsza ma długość 5", "printing of a bool": "drukowanie boola", "prints \"Hello world!\"": "drukuje „Witaj, świecie!”", "prints \"Hello, universe!\"": "drukuje „Witaj, wszechświecie!”", "prints 12 (assuming 4 byte ints)": "drukuje 12 (zakładając, że int ma 4 bajty)", "prints 20 (assuming 4 byte ints)": "drukuje 20 (zakładając, że int ma 4 bajty)", "prints 4 (assuming 32-bit addresses)": "drukuje 4 (zakładając adresy 32-bitowe)", "prints 97 rather than a": "drukuje 97 zamiast a", "prints Jim Beam": "drukuje Jim Beam", "prints wrong initial": "drukuje błędny inicjał", "private by default": "domyślnie prywatny", "problem w tej linii": "problem w tej linii", "przechowuje pierwsze 5 liczb pierwszych": "zachowaj pierwsze 5 pierwszych", "przed obecnie „najmniejszym” elementem.": "przed obecnym „najmniejszym” występem.", "przekazuje str przez adres, nie tworzy kopii str": "przekazuje str przez adres, nie tworzy kopii str", "przekazujemy adres x do funkcji": "przekazujemy adres x do funkcji", "przekonwertuj int na long": "przekonwertuj int na long", "przekonwertuj int na unsigned int": "przekonwertuj int na unsigned int", "przydziel miejsce na 1000 elementy": "przydziel miejsce na 1000 elementów", "przypadek 1: zawsze oceniany w czasie kompilacji": "przypadek 1: zawsze powiadomiony w czasie awarii", "przypadek 3: prawdopodobnie oceniany w czasie wykonywania": "Przypadek 3: dostępny w czasie wykonywania", "przypadek 4: zawsze oceniany w czasie wykonywania": "przypadek 4: zawsze zalecany w czasie wykonywania", "przypisz ptr do adresu v2": "przypisz ptr do adresu v2", "ptr jest teraz nullptr": "ptr jest teraz nullptr", "ptr przechowuje adres x": "ptr przechowuje adres x", "ptr wskazuje na const int x": "ptr wskazuje na const int x", "ptr wskazuje na x": "ptr wskazuje na x", "ptr wskazuje na „const int”": "ptr wskazuje na „const int”", "ptr2 jest niezainicjowany": "ptr2 jest niezainicjowany", "public by default": "domyślnie publiczny", "punkt kodowy dla „b” (niepreferowany)": "punkt kodowy dla „b” (niepreferowany)", "ref jest odniesieniem do x": "ref jest odniesieniem do x", "ref jest teraz aliasem dla `x`": "ref jest teraz aliasem dla `x`", "ref jest teraz aliasem dla zmiennej x": "ref jest teraz aliasem dla zmiennej x", "ref jest teraz aliasem for x": "ref jest teraz aliasem dla x", "remove any extra input": "usuń wszelkie dodatkowe dane wejściowe", "remove any extraneous input": "usuń wszelkie obce dane wejściowe", "remove extraneous input": "usuń obce dane wejściowe", "reset any error flags": "zresetuj wszystkie flagi błędów", "reset error flags": "zresetuj flagi błędów", "return by out parameter": "powrót według parametru out", "return saved state": "przywróć zapisany stan", "return std::all_of(nazwa.begin(), nazwa.end(), [](char ch) {": "return std::all_of(nazwa.begin(), nazwa.end(), [](char ch) {", "return temporary result": "zwróć wynik tymczasowy", "return type double": "typ zwracany double", "return type int": "typ powrotu int", "rightmost argument defaulted": "Domyślny argument znajdujący się najbardziej na prawo", "rozpoczyna drukowanie(std::string_view)": "rozpoczynanie drukowania(std::string_view)", "s jest parametrem in": "s jest parametrem w", "s1.x jest niezainicjowany, s1.y wynosi 0, a s1.z wynosi 2": "s1.x jest niezainicjowany, s1.y wynosi 0, a s1.z wynosi 2", "seed our PRNG": "zasiać nasz PRNG", "seed random number generator": "generator liczb losowych nasion", "self-assignment check": "sprawdzenie samodzielnego przypisania", "self-assignment guard": "ochroniarz z własnym przydziałem", "send all data": "wyślij wszystkie dane", "setter na rok": "seter na rok", "should equal 0.01 mathematically": "powinno wynosić matematycznie 0,01", "show 17 digits of precision": "pokaż 17 cyfr precyzji", "simple wykracza poza zakres": "proste wykracza poza zakres", "simple1 umiera tutaj": "simple1 umiera tutaj", "simple2 umiera tutaj": "simple2 umiera tutaj", "size to parametr nietypowy szablonu": "rozmiar do parametru alternatywnego szablonu", "skopiuj bity z n do f": "skopiuj bity z n do f", "skopiuj elementy m_length z arr do m_array": "skopiuj elementy m_length z arr do m_array", "so much simpler!": "o wiele prostsze!", "some default implementation": "jakaś domyślna implementacja", "sort data numerically": "sortować dane numerycznie", "specjalizacja dla typu double": "specjalizacja dla typu double", "square.h zawarte z main.cpp": "kwadrat.h zawiera z main.cpp", "start of nested block": "początek zagnieżdżonego bloku", "start of outer block": "początek bloku zewnętrznego", "static local variable": "statyczna zmienna lokalna", "static_cast<int> konwertuje double na int, inicjuje i z int wynik": "static_cast<int> konwertuje double na int, inicjuje i z int wynik", "std::for_each(arr.begin(), arr.end(), doubleNumber); // Przed C++20": "std::for_each(arr.begin(), arr.end(), doubleNumber); // Przed C++20", "std::from_chars": "std::from_chars", "std::ostream to typ std::cout, std::cerr itp.": "std::ostream na typ std::cout, std::cerr itp.", "std::reference_wrapper": "std::reference_wrapper", "std::string*": "std::string*", "std::string.": "std::string.", "std::string_view wymaga C++17": "std::string_view wymaga C++ 17", "styl „east const”, OK, ale nie preferowany": "styl „east const”, OK, ale nie preferowany", "sufiks sv potrzebny CTAD do wywnioskowania std::string_view": "sufiks sv wyników CTAD do wywnioskowania std::string_view", "syntactically valid, semantically meaningless": "syntaktycznie poprawne, semantycznie bez znaczenia", "szablon funkcji deklaracja przodu": "szablon funkcji deklaracja przedniej", "szablon pojedynczej funkcji dla max": "szablon adaptera funkcji dla max", "ta instrukcja jest wykonywana": "ta instrukcja jest wykonywana", "ta linia jest niejednoznaczna": "ta linia jest niejednoznaczna", "ta linia jest problematyczna": "ta linia jest problematyczna", "ta linia jest teraz jednoznaczna": "ta linia jest teraz jednoznaczna", "ta zainicjalizowana zmienna jest nadal w zakresie na etykiecie instrukcji „skip”": "ta zainicjalizowana zmienna jest nadal w zakresie na etykiecie instrumentu „skip”", "ta zmienna jest niezainicjowana": "ta zmienna jest niezainiczona", "tablica 4x4x4 (tablica 4 tablic po 4 tablice po 4 ints)": "tablica 4x4x4 (tablica 4 tablica po 4 tablica po 4 ints)", "tablica const int": "tablica const int", "tablica constexpr int": "tablica constexpr int", "tablica w stylu C z N elementami typu T": "tablica w stylu C z N elementów typu T", "takie jak instrukcja switch": "takie jak instrukcja przełącznika", "ten konstruktor inicjuje m_isManager": "ten konstruktor inicjuje m_isManager", "teraz OK, wypisuje 3": "OK, teraz wypisuje 3", "teraz funkcja constexpr": "teraz funkcja constexpr", "teraz klasa wyliczeniowa": "teraz klasa wyliczeniowa", "teraz klasa zamiast struktury": "teraz klasa zamiast struktury", "teraz oczywiste, co to 30 oznacza": "teraz oczywiste, co do 30 oznacza", "teraz oznaczone jako jawne": "teraz oznaczone jako jawne", "teraz std::string_view": "teraz std::string_view", "teraz std::string_view tworzy widok argumentu": "teraz std::string_view tworzy widok argumentu", "to definiuje nowy typ o nazwie X": "to nowy typ o nazwie X", "to jest definicja funkcji foo": "to jest definicja funkcji foo", "to jest definicja szablonu funkcji dla max<T>": "to jest definicja szablonu funkcji dla max<T>", "to jest definicja zmiennej x": "do definicji zmiennej x", "to jest deklaracja parametru szablonu": "to jest deklaracja parametru szablonu", "to jest etykieta instrukcji": "to jest etykieta składu", "to jest funkcja constexpr": "to jest funkcja constexpr", "to jest inicjalizacja, a nie blok": "to jest inicjalizacja, a nie blok", "to jest instrukcja goto": "to jest instrukcja goto", "to jest instrukcja null": "to jest instrukcja null", "to modyfikuje rzeczywisty obiekt x": "do modyfikowalnego obiektu x", "to nigdy nie zostanie wydrukowane": "nigdy nie zostanie wydrukowane", "to wyliczenie jest zdefiniowane w globalnej przestrzeni nazw": "do obliczenia jest możliwa w globalnej przestrzeni nazw", "traktowany tak samo jak const int*": "zachowanie tak samo jak const int*", "trudniejsze do odczytania": "użytkowe do odczytania", "true zwraca 1": "prawdziwe zwracanie 1", "turn off decimal output": "wyłącz wyjście dziesiętne", "turn on hexadecimal output": "włącz wyjście szesnastkowe", "turn option 4 off": "wyłącz opcję 4", "turn option 4 on.": "włącz opcję 4.", "tutaj przypadkowe polecenie zerowe": "tutaj następuje decyzja zerowa", "tutaj wprowadzam zakres": "tutaj wprowadzam zakres", "tutaj wspominamy o House": "tutaj wspominamy o House", "two rightmost arguments defaulted": "domyślnie dwa skrajne prawe argumenty", "tylko inicjuje pierwsze 3 elementy": "tylko inicjuje pierwsze 3 elementy", "tymczas umiera tutaj": "tymczas umiera tutaj", "typ wydedukowany jako const char*": "typ wydedukowany jako const char*", "typ wydedukowany jako int prime[5]": "typ wydedukowany jako int prime[5]", "typ wydedukowany jako std::string (nie std::string&)": "typ wydedukowany jako std::string (nie std::string&)", "typ zmieniony na std::string&": "wpisz na std::string&", "u powoduje wydedukowanie b jako unsigned int": "powodujesz wydedukowanie b jako unsigned int", "ukryta konwersja na std::string": "ukryta konwersacja na std::string", "ups, typ zwracany to double zamiast int": "ups, typ zwracany to double zamiast int", "user-defined empty constructor": "pusty konstruktor zdefiniowany przez użytkownika", "uses aggregate initialization": "używa inicjalizacji agregowanej", "uses direct init": "używa bezpośredniego inicjowania", "uses main.cpp's g_x, prints 3": "używa g_x pliku main.cpp, wypisuje 3", "ustaw VectPairSI aliasem dla tego szalonego typu": "ustaw VectPairSI aliasem dla tego szalonego typu", "ustaw bazowe odniesienie do obiektu": "ustawa bazowa odniesienie do obiektu", "ustaw skrajny prawy bit na 1": "ustaw ekstremy prawy bit na 1", "uwaga: baza jest teraz mijana referencja": "uwaga: baza jest teraz mijana referencja", "uwaga: brak definicji funkcji add": "uwaga: brak licznika funkcji add", "uwaga: brak nawiasu": "uwaga: brak nawiasu", "uwaga: brak tutaj funkcji print()": "uwaga: brak tutaj funkcji print()", "uwaga: brak tutaj inicjatora": "uwaga: brak tutaj inijatora", "uwaga: funkcja to const": "uwaga: funkcja do const", "uwaga: nie const": "uwaga: nie const", "uwaga: nie wirtualny": "uwaga: nie wirtualny", "uwaga: rBase jest tym razem B": "uwaga: rBase jest tym razem B", "uwaga: teraz ponownie wrzucamy obiekt tutaj": "uwaga: teraz ponownie wrzucamy obiekt tutaj", "uwaga: teraz wbudowane constexpr": "uwaga: obecnie constexpr", "uwaga: to jest teraz std::weak_ptr": "uwaga: teraz żartuję std::weak_ptr", "val jest parametrem funkcji": "Val jest funkcją parametryczną", "vector containing 0 int elements": "wektor zawierający 0 elementów int", "void tutaj oznacza nie parametry": "void tutaj oznacza nie parametry", "w przeciwnym razie doprowadzi to do niezdefiniowanego zachowania": "w przeciwnym razie doprowadziło to do niezdefiniowanego zachowania", "warning: unreferenced parameter count": "ostrzeżenie: liczba parametrów bez odniesienia", "wave.h zawarte w main.cpp": "wave.h zawiera w main.cpp", "will always execute": "zawsze wykona", "will execute first": "wykona się jako pierwszy", "will execute second": "wykona się jako drugi", "will execute third": "wykona trzeci", "will trigger assert": "wywoła asercję", "works just fine": "działa dobrze", "wpisz alias do std::function": "wpisz alias do std::function", "wpisz tutaj szablon funkcji dodawania": "wpisz tutaj szablon funkcji dodawania", "wprowadzi nas z powrotem do „normalnego” trybu pracy": "wprowadziliśmy nas z powrotem do „normalnego” trybunału pracy", "wydedukuje typ num jako `int`": "wnioskuje o typie num jako `int`", "wydrukuj 4 do konsoli": "wydrukuj 4 do konsoli", "wydrukuj adres trzymany przez ptr": "wydrukuj adres trzymany przez ptr", "wydrukuj bool jako prawda lub false": "wydrukuj bool jako prawdę lub fałsz", "wydrukuj element w wierszu 1, kolumnie 2": "wydrukuj element w wierszu 1, kolumnie 2", "wydrukuj wymiary tablicy": "wydrukuj parametry", "wykonanie jest kontynuowane tutaj": "wykonanie jest tutaj wykonywane", "wykonuje emplace_back": "miejsce emplace_back", "wykonuje warunkowo teraz": "postępowanie warunkowo teraz", "wypisz T, jednak normalnie wypisuje": "wypisz T, jednak normalnie wypisuje", "x has been modified": "x został zmodyfikowany", "x i y utworzone i zainicjowane tutaj": "x i y utworzone i przechowywane tutaj", "x jest kwalifikowany przez obiekt klasy obj": "x jest kwalifikowany przez obiekt klasy obj", "x jest parametrem in": "x jest parametrem w", "x jest teraz const": "x jest teraz const", "x jest w tym momencie znane kompilatorowi": "x jest w tym momencie znanym kompilatorowi", "x maina jest tworzone, inicjowane i wchodzi tutaj w zakres": "x maina jest miejscem, inicjowane i wchodzi tutaj w zakres", "x nie jest constexpr": "x nie jest constexpr", "x nie wchodzi w zakres nigdzie tej funkcji": "x nie wchodzi w zakres tej funkcji", "x nie wchodzi w zakres tutaj": "x nie wchodzi w zakres tutaj", "x wchodzi w zakres i jest tutaj tworzony": "x wchodzi w zakres i jest tutaj tworzony", "x wykracza poza zakres i zostaje tutaj zniszczony": "x wykracza poza zakres i pozostaje tutaj pusty", "x wykracza tutaj poza zakres": "x wyjdzie tutaj poza zakres", "y already declared above": "y już zadeklarowane powyżej", "y jest tutaj niszczone": "y jest tutaj niszczący", "y jest typu int": "jest typu int", "y jeszcze nie zadeklarowany": "y jeszcze nie zadeklarowany", "y wchodzi w zakres i jest tutaj tworzony": "y wchodzisz w zakres i jest tutaj tworzony", "y wychodzi poza zakres i zostaje tutaj zniszczony": "y wychodzi poza zakres i pozostaje tutaj zniszczony", "z utworzone i zainicjowane tutaj": "z utworzonego i dostępnego tutaj", "zadeklaruj iterator tylko do odczytu": "zadeklaruj iterator tylko do odczytu", "zadeklaruj nietypowy parametr szablonu typu int o nazwie N": "zadeklaruj inny parametr szablonu typu w nazwie N", "zaimplementuj to iteracyjnie": "zaimplementuj to iteracyjnie", "zaimplementuj to rekurencyjnie": "zaimplementuj to rekurencyjnie", "zainicjuj ptr adresem v1": "zainicjuj ptr adresu v1", "zainicjuj ptr adresem zmiennej x": "zainicjuj ptr adresu zmiennej x", "zakres natychmiast po tym.": "zakres natychmiast po tym.", "zapomnij o zaimplementowaniu jego skutek.": "zapomnij o zaimplementowaniu jego skutku.", "zawiera std::reference_wrapper i std::ref": "zawiera std::reference_wrapper i std::ref", "zdefiniuj Mile jako alias dla typu long": "zdefiniuj Mile jako alias dla typu long", "zdefiniuj Speed jako alias dla typu long": "zdefiniuj Speed ​​jako alias dla typu long", "zdefiniuj alias typu o nazwie Kolor": "zdefiniuj alias typu o nazwie Kolor", "zignoruj to na razie": "z pominięciem na razie", "zmieniono typ na T": "zmieniano typ na T", "zmodyfikuj obiekt w elemencie tablicy 1": "zmodyfikuj obiekt w elemencie tablicy 1", "znamy teraz identyfikator pracownika": "Znamy teraz identyfikator pracownika", "zostanie wykonany w czasie kompilacji": "zostać wykonane w czasie przechowywania", "zresetuj wszystkie elementy macierzy do 0.0": "zresetuj wszystkie elementy macierzy do 0.0", "zrobimy ten znak po znaku": "zrobimy dziesięć znaków po znaku", "zwraca 0 dla liczb ujemnych": "zwrócić 0 dla alternatywnych", "zwraca joe.m_name przez odniesienie": "uwaga joe.m_name przez odniesienie", "zwraca std::string_view.": "zwracane std::string_view.", "zwraca typowy typ T i U": "charakterystyczny typ T i U", "zwraca, gdy instrukcja if jest prawdziwa": "zwracaj, gdy instrukcja jest prawdziwa"}