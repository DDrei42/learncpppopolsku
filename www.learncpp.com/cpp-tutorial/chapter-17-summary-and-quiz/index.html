<!doctype html><html lang=en-us><head><meta charset=utf-8>





<base href=""><meta name=viewport content="width=device-width,user-scalable=yes,initial-scale=1"><meta http-equiv=x-ua-compatible content="IE=edge"><link rel=profile href="https://gmpg.org/xfn/11"><title>17.x — Podsumowanie i quiz rozdziału 17 — Naucz się C++</title><meta name=robots content="max-image-preview:large"><link rel=dns-prefetch href="https://fd.cleantalk.org/"><link rel=stylesheet id=wgs2-css href="../../blog/wp-content/plugins/wp-google-search/wgs2.css@ver=4084444bfee884f6024e8b1b3cfa6cdd.css" media=all><link rel=stylesheet id=dashicons-css href="../../blog/wp-includes/css/dashicons.min.css@ver=4084444bfee884f6024e8b1b3cfa6cdd.css" media=all><link rel=stylesheet id=font-awesome-css href="../../blog/wp-content/plugins/menu-icons/vendor/codeinwp/icon-picker/css/types/font-awesome.min.css@ver=4.7.0.css" media=all><link rel=stylesheet id=menu-icons-extra-css href="../../blog/wp-content/plugins/menu-icons/css/extra.min.css@ver=0.12.9.css" media=all><link rel=stylesheet id=wp-block-library-css href="../../blog/wp-includes/css/dist/block-library/style.min.css@ver=4084444bfee884f6024e8b1b3cfa6cdd.css" media=all><link rel=stylesheet id=cleantalk-public-css-css href="../../blog/wp-content/plugins/cleantalk-spam-protect/css/cleantalk-public.min.css@ver=6.68_1763367835.css" media=all><link rel=stylesheet id=cleantalk-email-decoder-css-css href="../../blog/wp-content/plugins/cleantalk-spam-protect/css/cleantalk-email-decoder.min.css@ver=6.68_1763367835.css" media=all><link rel=stylesheet id=monacoCSS-css href="../../blog/wp-content/plugins/learncpp-prism/fonts/monaco.css@ver=0.135.css" media=all><link rel=stylesheet id=prismThemeCSS-css href="../../blog/wp-content/plugins/learncpp-prism/prism-theme.css@ver=0.135.css" media=all><link rel=stylesheet id=vscf_style-css href="../../blog/wp-content/plugins/very-simple-contact-form/css/vscf-style.min.css@ver=4084444bfee884f6024e8b1b3cfa6cdd.css" media=all><link rel=stylesheet id=wpdiscuz-frontend-css-css href="../../blog/wp-content/plugins/wpdiscuz/themes/default/style.css@ver=7.3.17.css" media=all><style id=wpdiscuz-frontend-css-inline-css>#wpdcom .wpd-blog-administrator .wpd-comment-label{color:#fff;background-color:#ff451f;border:none}#wpdcom .wpd-blog-administrator .wpd-comment-author,#wpdcom .wpd-blog-administrator .wpd-comment-author a{color:#ff451f}#wpdcom.wpd-layout-1 .wpd-comment .wpd-blog-administrator .wpd-avatar img{border-color:#ff451f}#wpdcom.wpd-layout-2 .wpd-comment.wpd-reply .wpd-comment-wrap.wpd-blog-administrator{border-left:3px solid #ff451f}#wpdcom.wpd-layout-2 .wpd-comment .wpd-blog-administrator .wpd-avatar img{border-bottom-color:#ff451f}#wpdcom.wpd-layout-3 .wpd-blog-administrator .wpd-comment-subheader{border-top:1px dashed #ff451f}#wpdcom.wpd-layout-3 .wpd-reply .wpd-blog-administrator .wpd-comment-right{border-left:1px solid #ff451f}#wpdcom .wpd-blog-author .wpd-comment-label{color:#fff;background-color:#327324;border:none}#wpdcom .wpd-blog-author .wpd-comment-author,#wpdcom .wpd-blog-author .wpd-comment-author a{color:#327324}#wpdcom.wpd-layout-1 .wpd-comment .wpd-blog-author .wpd-avatar img{border-color:#327324}#wpdcom.wpd-layout-2 .wpd-comment .wpd-blog-author .wpd-avatar img{border-bottom-color:#327324}#wpdcom.wpd-layout-3 .wpd-blog-author .wpd-comment-subheader{border-top:1px dashed #327324}#wpdcom.wpd-layout-3 .wpd-reply .wpd-blog-author .wpd-comment-right{border-left:1px solid #327324}#wpdcom .wpd-blog-contributor .wpd-comment-label{color:#fff;background-color:#a240cd;border:none}#wpdcom .wpd-blog-contributor .wpd-comment-author,#wpdcom .wpd-blog-contributor .wpd-comment-author a{color:#a240cd}#wpdcom.wpd-layout-1 .wpd-comment .wpd-blog-contributor .wpd-avatar img{border-color:#a240cd}#wpdcom.wpd-layout-2 .wpd-comment .wpd-blog-contributor .wpd-avatar img{border-bottom-color:#a240cd}#wpdcom.wpd-layout-3 .wpd-blog-contributor .wpd-comment-subheader{border-top:1px dashed #a240cd}#wpdcom.wpd-layout-3 .wpd-reply .wpd-blog-contributor .wpd-comment-right{border-left:1px solid #a240cd}#wpdcom .wpd-blog-editor .wpd-comment-label{color:#fff;background-color:#d36000;border:none}#wpdcom .wpd-blog-editor .wpd-comment-author,#wpdcom .wpd-blog-editor .wpd-comment-author a{color:#d36000}#wpdcom.wpd-layout-1 .wpd-comment .wpd-blog-editor .wpd-avatar img{border-color:#d36000}#wpdcom.wpd-layout-2 .wpd-comment.wpd-reply .wpd-comment-wrap.wpd-blog-editor{border-left:3px solid #d36000}#wpdcom.wpd-layout-2 .wpd-comment .wpd-blog-editor .wpd-avatar img{border-bottom-color:#d36000}#wpdcom.wpd-layout-3 .wpd-blog-editor .wpd-comment-subheader{border-top:1px dashed #d36000}#wpdcom.wpd-layout-3 .wpd-reply .wpd-blog-editor .wpd-comment-right{border-left:1px solid #d36000}#wpdcom .wpd-blog-localization_author .wpd-comment-label{color:#fff;background-color:#31839e;border:none}#wpdcom .wpd-blog-localization_author .wpd-comment-author,#wpdcom .wpd-blog-localization_author .wpd-comment-author a{color:#31839e}#wpdcom.wpd-layout-1 .wpd-comment .wpd-blog-localization_author .wpd-avatar img{border-color:#31839e}#wpdcom.wpd-layout-2 .wpd-comment .wpd-blog-localization_author .wpd-avatar img{border-bottom-color:#31839e}#wpdcom.wpd-layout-3 .wpd-blog-localization_author .wpd-comment-subheader{border-top:1px dashed #31839e}#wpdcom.wpd-layout-3 .wpd-reply .wpd-blog-localization_author .wpd-comment-right{border-left:1px solid #31839e}#wpdcom .wpd-blog-subscriber .wpd-comment-label{color:#fff;background-color:#31839e;border:none}#wpdcom .wpd-blog-subscriber .wpd-comment-author,#wpdcom .wpd-blog-subscriber .wpd-comment-author a{color:#31839e}#wpdcom.wpd-layout-2 .wpd-comment .wpd-blog-subscriber .wpd-avatar img{border-bottom-color:#31839e}#wpdcom.wpd-layout-3 .wpd-blog-subscriber .wpd-comment-subheader{border-top:1px dashed #31839e}#wpdcom .wpd-blog-subadministrator .wpd-comment-label{color:#fff;background-color:#31839e;border:none}#wpdcom .wpd-blog-subadministrator .wpd-comment-author,#wpdcom .wpd-blog-subadministrator .wpd-comment-author a{color:#31839e}#wpdcom.wpd-layout-1 .wpd-comment .wpd-blog-subadministrator .wpd-avatar img{border-color:#31839e}#wpdcom.wpd-layout-2 .wpd-comment .wpd-blog-subadministrator .wpd-avatar img{border-bottom-color:#31839e}#wpdcom.wpd-layout-3 .wpd-blog-subadministrator .wpd-comment-subheader{border-top:1px dashed #31839e}#wpdcom.wpd-layout-3 .wpd-reply .wpd-blog-subadministrator .wpd-comment-right{border-left:1px solid #31839e}#wpdcom .wpd-blog-css_js_designer .wpd-comment-label{color:#fff;background-color:#00b38f;border:none}#wpdcom .wpd-blog-css_js_designer .wpd-comment-author,#wpdcom .wpd-blog-css_js_designer .wpd-comment-author a{color:#00b38f}#wpdcom.wpd-layout-1 .wpd-comment .wpd-blog-css_js_designer .wpd-avatar img{border-color:#00b38f}#wpdcom.wpd-layout-2 .wpd-comment .wpd-blog-css_js_designer .wpd-avatar img{border-bottom-color:#00b38f}#wpdcom.wpd-layout-3 .wpd-blog-css_js_designer .wpd-comment-subheader{border-top:1px dashed #00b38f}#wpdcom.wpd-layout-3 .wpd-reply .wpd-blog-css_js_designer .wpd-comment-right{border-left:1px solid #00b38f}#wpdcom .wpd-blog-post_author .wpd-comment-label{color:#fff;background-color:#07b290;border:none}#wpdcom .wpd-blog-post_author .wpd-comment-author,#wpdcom .wpd-blog-post_author .wpd-comment-author a{color:#07b290}#wpdcom .wpd-blog-post_author .wpd-avatar img{border-color:#07b290}#wpdcom.wpd-layout-1 .wpd-comment .wpd-blog-post_author .wpd-avatar img{border-color:#07b290}#wpdcom.wpd-layout-2 .wpd-comment.wpd-reply .wpd-comment-wrap.wpd-blog-post_author{border-left:3px solid #07b290}#wpdcom.wpd-layout-2 .wpd-comment .wpd-blog-post_author .wpd-avatar img{border-bottom-color:#07b290}#wpdcom.wpd-layout-3 .wpd-blog-post_author .wpd-comment-subheader{border-top:1px dashed #07b290}#wpdcom.wpd-layout-3 .wpd-reply .wpd-blog-post_author .wpd-comment-right{border-left:1px solid #07b290}#wpdcom .wpd-blog-guest .wpd-comment-label{color:#fff;background-color:#898989;border:none}#wpdcom .wpd-blog-guest .wpd-comment-author,#wpdcom .wpd-blog-guest .wpd-comment-author a{color:#898989}#wpdcom.wpd-layout-3 .wpd-blog-guest .wpd-comment-subheader{border-top:1px dashed #898989}#comments,#respond,.comments-area,#wpdcom{}#wpdcom .ql-editor>*{color:#777}#wpdcom .ql-editor::before{}#wpdcom .ql-toolbar{border:1px solid #ddd;border-top:none}#wpdcom .ql-container{border:1px solid #ddd;border-bottom:none}#wpdcom .wpd-form-row .wpdiscuz-item input[type=text],#wpdcom .wpd-form-row .wpdiscuz-item input[type=email],#wpdcom .wpd-form-row .wpdiscuz-item input[type=url],#wpdcom .wpd-form-row .wpdiscuz-item input[type=color],#wpdcom .wpd-form-row .wpdiscuz-item input[type=date],#wpdcom .wpd-form-row .wpdiscuz-item input[type=datetime],#wpdcom .wpd-form-row .wpdiscuz-item input[type=datetime-local],#wpdcom .wpd-form-row .wpdiscuz-item input[type=month],#wpdcom .wpd-form-row .wpdiscuz-item input[type=number],#wpdcom .wpd-form-row .wpdiscuz-item input[type=time],#wpdcom textarea,#wpdcom select{border:1px solid #ddd;color:#777}#wpdcom .wpd-form-row .wpdiscuz-item textarea{border:1px solid #ddd}#wpdcom input::placeholder,#wpdcom textarea::placeholder,#wpdcom input::-moz-placeholder,#wpdcom textarea::-webkit-input-placeholder{}#wpdcom .wpd-comment-text{color:#777}#wpdcom .wpd-thread-head .wpd-thread-info{border-bottom:2px solid #00b38f}#wpdcom .wpd-thread-head .wpd-thread-info.wpd-reviews-tab svg{fill:#00b38f}#wpdcom .wpd-thread-head .wpdiscuz-user-settings{border-bottom:2px solid #00b38f}#wpdcom .wpd-thread-head .wpdiscuz-user-settings:hover{color:#00b38f}#wpdcom .wpd-comment .wpd-follow-link:hover{color:#00b38f}#wpdcom .wpd-comment-status .wpd-sticky{color:#00b38f}#wpdcom .wpd-thread-filter .wpdf-active{color:#00b38f;border-bottom-color:#00b38f}#wpdcom .wpd-comment-info-bar{border:1px dashed #33c3a6;background:#e6f8f4}#wpdcom .wpd-comment-info-bar .wpd-current-view i{color:#00b38f}#wpdcom .wpd-filter-view-all:hover{background:#00b38f}#wpdcom .wpdiscuz-item .wpdiscuz-rating>label{color:#ddd}#wpdcom .wpdiscuz-item .wpdiscuz-rating:not(:checked)>label:hover,.wpdiscuz-rating:not(:checked)>label:hover~label{}#wpdcom .wpdiscuz-item .wpdiscuz-rating>input~label:hover,#wpdcom .wpdiscuz-item .wpdiscuz-rating>input:not(:checked)~label:hover~label,#wpdcom .wpdiscuz-item .wpdiscuz-rating>input:not(:checked)~label:hover~label{color:#ffed85}#wpdcom .wpdiscuz-item .wpdiscuz-rating>input:checked~label:hover,#wpdcom .wpdiscuz-item .wpdiscuz-rating>input:checked~label:hover,#wpdcom .wpdiscuz-item .wpdiscuz-rating>label:hover~input:checked~label,#wpdcom .wpdiscuz-item .wpdiscuz-rating>input:checked+label:hover~label,#wpdcom .wpdiscuz-item .wpdiscuz-rating>input:checked~label:hover~label,.wpd-custom-field .wcf-active-star,#wpdcom .wpdiscuz-item .wpdiscuz-rating>input:checked~label{color:gold}#wpd-post-rating .wpd-rating-wrap .wpd-rating-stars svg .wpd-star{fill:#ddd}#wpd-post-rating .wpd-rating-wrap .wpd-rating-stars svg .wpd-active{fill:gold}#wpd-post-rating .wpd-rating-wrap .wpd-rate-starts svg .wpd-star{fill:#ddd}#wpd-post-rating .wpd-rating-wrap .wpd-rate-starts:hover svg .wpd-star{fill:#ffed85}#wpd-post-rating.wpd-not-rated .wpd-rating-wrap .wpd-rate-starts svg:hover~svg .wpd-star{fill:#ddd}.wpdiscuz-post-rating-wrap .wpd-rating .wpd-rating-wrap .wpd-rating-stars svg .wpd-star{fill:#ddd}.wpdiscuz-post-rating-wrap .wpd-rating .wpd-rating-wrap .wpd-rating-stars svg .wpd-active{fill:gold}#wpdcom .wpd-comment .wpd-follow-active{color:#ff7a00}#wpdcom .page-numbers{color:#555;border:#555 1px solid}#wpdcom span.current{background:#555}#wpdcom.wpd-layout-1 .wpd-new-loaded-comment>.wpd-comment-wrap>.wpd-comment-right{background:#fffad6}#wpdcom.wpd-layout-2 .wpd-new-loaded-comment.wpd-comment>.wpd-comment-wrap>.wpd-comment-right{background:#fffad6}#wpdcom.wpd-layout-2 .wpd-new-loaded-comment.wpd-comment.wpd-reply>.wpd-comment-wrap>.wpd-comment-right{background:0 0}#wpdcom.wpd-layout-2 .wpd-new-loaded-comment.wpd-comment.wpd-reply>.wpd-comment-wrap{background:#fffad6}#wpdcom.wpd-layout-3 .wpd-new-loaded-comment.wpd-comment>.wpd-comment-wrap>.wpd-comment-right{background:#fffad6}#wpdcom .wpd-follow:hover i,#wpdcom .wpd-unfollow:hover i,#wpdcom .wpd-comment .wpd-follow-active:hover i{color:#00b38f}#wpdcom .wpdiscuz-readmore{cursor:pointer;color:#00b38f}.wpd-custom-field .wcf-pasiv-star,#wpcomm .wpdiscuz-item .wpdiscuz-rating>label{color:#ddd}.wpd-wrapper .wpd-list-item.wpd-active{border-top:3px solid #00b38f}#wpdcom.wpd-layout-2 .wpd-comment.wpd-reply.wpd-unapproved-comment .wpd-comment-wrap{border-left:3px solid #fffad6}#wpdcom.wpd-layout-3 .wpd-comment.wpd-reply.wpd-unapproved-comment .wpd-comment-right{border-left:1px solid #fffad6}#wpdcom .wpd-prim-button{background-color:#07b290;color:#fff}#wpdcom .wpd_label__check i.wpdicon-on{color:#07b290;border:1px solid #83d9c8}#wpd-bubble-wrapper #wpd-bubble-all-comments-count{color:#1db99a}#wpd-bubble-wrapper>div{background-color:#1db99a}#wpd-bubble-wrapper>#wpd-bubble #wpd-bubble-add-message{background-color:#1db99a}#wpd-bubble-wrapper>#wpd-bubble #wpd-bubble-add-message::before{border-left-color:#1db99a;border-right-color:#1db99a}#wpd-bubble-wrapper.wpd-right-corner>#wpd-bubble #wpd-bubble-add-message::before{border-left-color:#1db99a;border-right-color:#1db99a}.wpd-inline-icon-wrapper path.wpd-inline-icon-first{fill:#1db99a}.wpd-inline-icon-count{background-color:#1db99a}.wpd-inline-icon-count::before{border-right-color:#1db99a}.wpd-inline-form-wrapper::before{border-bottom-color:#1db99a}.wpd-inline-form-question{background-color:#1db99a}.wpd-inline-form{background-color:#1db99a}.wpd-last-inline-comments-wrapper{border-color:#1db99a}.wpd-last-inline-comments-wrapper::before{border-bottom-color:#1db99a}.wpd-last-inline-comments-wrapper .wpd-view-all-inline-comments{background:#1db99a}.wpd-last-inline-comments-wrapper .wpd-view-all-inline-comments:hover,.wpd-last-inline-comments-wrapper .wpd-view-all-inline-comments:active,.wpd-last-inline-comments-wrapper .wpd-view-all-inline-comments:focus{background-color:#1db99a}#wpdcom .ql-snow .ql-tooltip[data-mode=link]::before{content:"Wpisz link:"}#wpdcom .ql-snow .ql-tooltip.ql-editing a.ql-action::after{content:"Zapisz"}.comments-area{width:auto}</style><link rel=stylesheet id=wpdiscuz-fa-css href="../../blog/wp-content/plugins/wpdiscuz/assets/third-party/font-awesome-5.13.0/css/fa.min.css@ver=7.3.17.css" media=all><link rel=stylesheet id=wpdiscuz-combo-css-css href="../../blog/wp-content/plugins/wpdiscuz/assets/css/wpdiscuz-combo-no_quill.min.css@ver=4084444bfee884f6024e8b1b3cfa6cdd.css" media=all><link rel=stylesheet id=parent-style-css href="../../blog/wp-content/themes/septera/style.css@ver=4084444bfee884f6024e8b1b3cfa6cdd.css" media=all><link rel=stylesheet id=septera-themefonts-css href="../../blog/wp-content/themes/septera/resources/fonts/fontfaces.css@ver=1.5.1.css" media=all><link rel=stylesheet id=septera-googlefonts-css href="../../blog/wp-content/uploads/omgf/septera-googlefonts/septera-googlefonts.css@ver=1700504504.css" media=all><link rel=stylesheet id=septera-main-css href="../../blog/wp-content/themes/septera-child/style.css@ver=1.5.1.css" media=all><style id=septera-main-inline-css>body:not(.septera-landing-page) #container,#site-header-main-inside,#colophon-inside,#footer-inside,#breadcrumbs-container-inside{margin:0 auto;max-width:1920px}#site-header-main{left:0;right:0}#primary{width:200px}#secondary{width:200px}#container.one-column .main{width:100%}#container.two-columns-right #secondary{float:right}#container.two-columns-right .main,.two-columns-right #breadcrumbs{width:calc( 100% - 200px );float:left}#container.two-columns-left #primary{float:left}#container.two-columns-left .main,.two-columns-left #breadcrumbs{width:calc( 100% - 200px );float:right}#container.three-columns-right #primary,#container.three-columns-left #primary,#container.three-columns-sided #primary{float:left}#container.three-columns-right #secondary,#container.three-columns-left #secondary,#container.three-columns-sided #secondary{float:left}#container.three-columns-right #primary,#container.three-columns-left #secondary{margin-left:0%;margin-right:0%}#container.three-columns-right .main,.three-columns-right #breadcrumbs{width:calc( 100% - 400px );float:left}#container.three-columns-left .main,.three-columns-left #breadcrumbs{width:calc( 100% - 400px );float:right}#container.three-columns-sided #secondary{float:right}#container.three-columns-sided .main,.three-columns-sided #breadcrumbs{width:calc( 100% - 400px );float:right}.three-columns-sided #breadcrumbs{margin:0 calc( 0% + 200px )0 -1920px}html{font-family:Open Sans;font-size:14px;font-weight:400;line-height:1.6}#site-title{font-family:Open Sans;font-size:120%;font-weight:700}#access ul li a{font-family:Open Sans;font-size:90%;font-weight:700}.widget-title{font-family:Open Sans;font-size:100%;font-weight:700}.widget-container{font-family:Open Sans;font-size:100%;font-weight:400}.entry-title,#reply-title{font-family:Open Sans;font-size:200%;font-weight:400}.entry-title.singular-title{font-size:200%}.content-masonry .entry-title{font-size:124%}h1{font-size:2.3em}h2{font-size:2em}h3{font-size:1.7em}h4{font-size:1.4em}h5{font-size:1.1em}h6{font-size:.8em}h1,h2,h3,h4,h5,h6{font-family:Open Sans;font-weight:700}body{color:#2d3140;background-color:#d6d6d6}@media(min-width:1152px){.septera-over-menu #site-title a,.septera-over-menu #access>div>ul>li,.septera-over-menu #access>div>ul>li>a,.septera-over-menu #sheader.socials a::before{color:#fff}.septera-landing-page.septera-over-menu #site-title a,.septera-landing-page.septera-over-menu #access>div>ul>li,.septera-landing-page.septera-over-menu #access>div>ul>li>a,.septera-landing-page.septera-over-menu #sheader.socials a::before{color:#fff}}.lp-staticslider .staticslider-caption-title,.seriousslider.seriousslider-theme .seriousslider-caption-title,.lp-staticslider .staticslider-caption-text,.seriousslider.seriousslider-theme .seriousslider-caption-text,.lp-staticslider .staticslider-caption-text a{color:#fff}#site-header-main,#access ul ul,.menu-search-animated .searchform input[type=search],#access::after,.septera-over-menu .header-fixed#site-header-main,.septera-over-menu .header-fixed#site-header-main #access:after{background-color:#fff}.septera-over-menu .header-fixed#site-header-main #site-title a{color:#365da0}#access>div>ul>li,#access>div>ul>li>a,.septera-over-menu .header-fixed#site-header-main #access>div>ul>li:not([class*=current]),.septera-over-menu .header-fixed#site-header-main #access>div>ul>li:not([class*=current])>a,.septera-over-menu .header-fixed#site-header-main #sheader.socials a::before,#sheader.socials a::before,#mobile-menu{color:#365da0}#access ul.sub-menu li a,#access ul.children li a{color:#888}#access ul.sub-menu li a,#access ul.children li a{background-color:#fff}#access>div>ul>li a:hover,#access>div>ul>li:hover,.septera-over-menu .header-fixed#site-header-main #access>div>ul>li>a:hover,.septera-over-menu .header-fixed#site-header-main #access>div>ul>li:hover,.septera-over-menu .header-fixed#site-header-main #sheader.socials a:hover::before,#sheader.socials a:hover::before{color:#365da0}#access>div>ul>li.current_page_item>a,#access>div>ul>li.current-menu-item>a,#access>div>ul>li.current_page_ancestor>a,#access>div>ul>li.current-menu-ancestor>a,#access .sub-menu,#access .children,.septera-over-menu .header-fixed#site-header-main #access>div>ul>li>a{color:#96bbe0}#access ul.children>li.current_page_item>a,#access ul.sub-menu>li.current-menu-item>a,#access ul.children>li.current_page_ancestor>a,#access ul.sub-menu>li.current-menu-ancestor>a{color:#96bbe0}.searchform .searchsubmit{color:#2d3140}.searchform:hover input[type=search],.searchform input[type=search]:focus{border-color:#365da0}body:not(.septera-landing-page) .main,#lp-posts,#lp-page,.searchform{background-color:#fff}.pagination span,.pagination a{background-color:#f3f3f3}#breadcrumbs-container{border-bottom-color:#eee;background-color:#fff}#primary{background-color:#d6d6d6}#secondary{background-color:#d6d6d6}#colophon,#footer{background-color:#d6d6d6;color:#2d3140}.entry-title a:active,.entry-title a:hover{color:#365da0}span.entry-format{color:#365da0}.format-aside{border-top-color:#fff}article.hentry .post-thumbnail-container{background-color:rgba(45,49,64,.15)}article.hentry .post-thumbnail-container a::after{background-color:#365da0}.entry-content blockquote::before,.entry-content blockquote::after{color:rgba(45,49,64,.2)}.entry-content h1,.entry-content h2,.entry-content h3,.entry-content h4,.lp-text-content h1,.lp-text-content h2,.lp-text-content h3,.lp-text-content h4,.entry-title{color:#2d3140}a{color:#365da0}a:hover,.entry-meta span a:hover,.comments-link a:hover{color:#96bbe0}.entry-meta span.comments-link{top:.62em}.continue-reading-link{color:#365da0;background-color:#f5f5f5}.continue-reading-link:hover{color:#96bbe0}.socials a:before{color:#365da0}.socials a:hover:before{color:#96bbe0}.septera-normalizedtags #content .tagcloud a{color:#fff;background-color:#365da0}.septera-normalizedtags #content .tagcloud a:hover{background-color:#96bbe0}#toTop{background-color:rgba(189,189,189,.8);color:#365da0}#toTop:hover{background-color:#365da0;color:#d6d6d6}.entry-meta .icon-metas:before{color:#000}.septera-caption-one .main .wp-caption .wp-caption-text{border-bottom-color:#eee}.septera-caption-two .main .wp-caption .wp-caption-text{background-color:#f5f5f5}.septera-image-one .entry-content img[class*=align],.septera-image-one .entry-summary img[class*=align],.septera-image-two .entry-content img[class*=align],.septera-image-two .entry-summary img[class*=align]{border-color:#eee}.septera-image-five .entry-content img[class*=align],.septera-image-five .entry-summary img[class*=align]{border-color:#365da0}span.edit-link a.post-edit-link,span.edit-link a.post-edit-link:hover,span.edit-link .icon-edit:before{color:#727685}.searchform{border-color:#ebebeb}.entry-meta span,.entry-meta a,.entry-utility span,.entry-utility a,.entry-meta time,#breadcrumbs-nav,.footermenu ul li span.sep{color:#000}.entry-meta span.entry-sticky{background-color:#000;color:#fff}#footer-separator{background:#c7c7c7}#commentform{max-width:1e3px}code,#nav-below .nav-previous a:before,#nav-below .nav-next a:before{background-color:#eee}pre,.page-link>span,.comment-author,.commentlist .comment-body,.commentlist .pingback{border-color:#eee}.page-header.pad-container,#author-info{background-color:#f5f5f5}.comment-meta a{color:#000}.commentlist .reply a{color:#000}select,input[type],textarea{color:#2d3140;border-color:#f0f0f0}input[type]:hover,textarea:hover,select:hover,input[type]:focus,textarea:focus,select:focus{background:#f0f0f0}button,input[type=button],input[type=submit],input[type=reset]{background-color:#365da0;color:#fff}button:hover,input[type=button]:hover,input[type=submit]:hover,input[type=reset]:hover{background-color:#96bbe0}hr{background-color:#f0f0f0}.wp-block-image.alignwide{margin-left:calc( ( 0% + 2.5em ) * -1 );margin-right:calc( ( 0% + 2.5em ) * -1 )}.wp-block-image.alignwide img{width:calc( 100% + 5em );max-width:calc( 100% + 5em )}.has-accent-1-color,.has-accent-1-color:hover{color:#365da0}.has-accent-2-color,.has-accent-2-color:hover{color:#96bbe0}.has-headings-color,.has-headings-color:hover{color:#2d3140}.has-sitetext-color,.has-sitetext-color:hover{color:#2d3140}.has-sitebg-color,.has-sitebg-color:hover{color:#fff}.has-accent-1-background-color{background-color:#365da0}.has-accent-2-background-color{background-color:#96bbe0}.has-headings-background-color{background-color:#2d3140}.has-sitetext-background-color{background-color:#2d3140}.has-sitebg-background-color{background-color:#fff}.has-small-font-size{font-size:8px}.has-regular-font-size{font-size:14px}.has-large-font-size{font-size:22px}.has-larger-font-size{font-size:35px}.has-huge-font-size{font-size:35px}.woocommerce-page #respond input#submit.alt,.woocommerce a.button.alt,.woocommerce-page button.button.alt,.woocommerce input.button.alt,.woocommerce #respond input#submit,.woocommerce a.button,.woocommerce button.button,.woocommerce input.button{background-color:#365da0;color:#fff;line-height:1.6}.woocommerce #respond input#submit:hover,.woocommerce a.button:hover,.woocommerce button.button:hover,.woocommerce input.button:hover{background-color:#587fc2;color:#fff}.woocommerce-page #respond input#submit.alt,.woocommerce a.button.alt,.woocommerce-page button.button.alt,.woocommerce input.button.alt{background-color:#96bbe0;color:#fff;line-height:1.6}.woocommerce-page #respond input#submit.alt:hover,.woocommerce a.button.alt:hover,.woocommerce-page button.button.alt:hover,.woocommerce input.button.alt:hover{background-color:#b8ddff;color:#fff}.woocommerce div.product .woocommerce-tabs ul.tabs li.active{border-bottom-color:#fff}.woocommerce #respond input#submit.alt.disabled,.woocommerce #respond input#submit.alt.disabled:hover,.woocommerce #respond input#submit.alt:disabled,.woocommerce #respond input#submit.alt:disabled:hover,.woocommerce #respond input#submit.alt[disabled]:disabled,.woocommerce #respond input#submit.alt[disabled]:disabled:hover,.woocommerce a.button.alt.disabled,.woocommerce a.button.alt.disabled:hover,.woocommerce a.button.alt:disabled,.woocommerce a.button.alt:disabled:hover,.woocommerce a.button.alt[disabled]:disabled,.woocommerce a.button.alt[disabled]:disabled:hover,.woocommerce button.button.alt.disabled,.woocommerce button.button.alt.disabled:hover,.woocommerce button.button.alt:disabled,.woocommerce button.button.alt:disabled:hover,.woocommerce button.button.alt[disabled]:disabled,.woocommerce button.button.alt[disabled]:disabled:hover,.woocommerce input.button.alt.disabled,.woocommerce input.button.alt.disabled:hover,.woocommerce input.button.alt:disabled,.woocommerce input.button.alt:disabled:hover,.woocommerce input.button.alt[disabled]:disabled,.woocommerce input.button.alt[disabled]:disabled:hover{background-color:#96bbe0}.woocommerce ul.products li.product .price,.woocommerce div.product p.price,.woocommerce div.product span.price{color:#00000e}#add_payment_method #payment,.woocommerce-cart #payment,.woocommerce-checkout #payment{background:#f5f5f5}.woocommerce .main .page-title{}nav#mobile-menu{background-color:#fff}#mobile-menu .mobile-arrow{color:#2d3140}.main .entry-content,.main .entry-summary{text-align:inherit}.main p,.main ul,.main ol,.main dd,.main pre,.main hr{margin-bottom:1em}.main p{text-indent:0}.main a.post-featured-image{background-position:50%}#header-widget-area{width:33%;right:10px}.septera-stripped-table .main thead th,.septera-bordered-table .main thead th,.septera-stripped-table .main td,.septera-stripped-table .main th,.septera-bordered-table .main th,.septera-bordered-table .main td{border-color:#e9e9e9}.septera-clean-table .main th,.septera-stripped-table .main tr:nth-child(even) td,.septera-stripped-table .main tr:nth-child(even) th{background-color:#f6f6f6}article.hentry .article-inner,#content-masonry article.hentry .article-inner{padding:0%}#site-header-main{height:50px}#access .menu-search-animated .searchform{top:52px}.menu-search-animated,#sheader,.identity,#nav-toggle{height:50px;line-height:50px}#access div>ul>li>a{line-height:50px}#branding{height:50px}#header-widget-area{top:60px}.septera-responsive-headerimage #masthead #header-image-main-inside{max-height:10px}.septera-cropped-headerimage #masthead div.header-image{height:10px}#site-description{display:block}#masthead #site-header-main{position:fixed}.septera-fixed-menu #header-image-main{margin-top:50px}.lp-staticslider .staticslider-caption-text a{border-color:#fff}.lp-staticslider .staticslider-caption,.seriousslider.seriousslider-theme .seriousslider-caption,.septera-landing-page .lp-blocks-inside,.septera-landing-page .lp-boxes-inside,.septera-landing-page .lp-text-inside,.septera-landing-page .lp-posts-inside,.septera-landing-page .lp-page-inside,.septera-landing-page .lp-section-header,.septera-landing-page .content-widget{max-width:1920px}.septera-landing-page .content-widget{margin:0 auto}.seriousslider-theme .seriousslider-caption-buttons a:nth-child(2n+1),a.staticslider-button:nth-child(2n+1){color:#2d3140;border-color:#fff;background-color:#fff}.seriousslider-theme .seriousslider-caption-buttons a:nth-child(2n+1):hover,a.staticslider-button:nth-child(2n+1):hover{color:#fff}.seriousslider-theme .seriousslider-caption-buttons a:nth-child(2n),a.staticslider-button:nth-child(2n){border-color:#fff;color:#fff}.seriousslider-theme .seriousslider-caption-buttons a:nth-child(2n):hover,.staticslider-button:nth-child(2n):hover{color:#2d3140;background-color:#fff}.lp-staticslider::before,.lp-dynamic-slider .item>a::before,#header-image-main::before{background-color:#24a7cf}.lp-staticslider::before,.lp-dynamic-slider .item>a::before,#header-image-main::before{z-index:2}.lp-staticslider-image,.header-image,.seriousslider .item-image{-webkit-filter:grayscale(75%)brightness(110%);filter:grayscale(75%)brightness(110%)}@-webkit-keyframes animation-slider-overlay{to{opacity:.75}}@keyframes animation-slider-overlay{to{opacity:.75}}.lp-dynamic-slider .item>a::before{opacity:.75}.lp-blocks{background-color:#fff}.lp-boxes{background-color:#fff}.lp-text{background-color:#f8f8f8}.staticslider-caption-container,.lp-dynamic-slider{background-color:#fff}.lp-block>i::before{color:#365da0}.lp-block:hover i::before{color:#96bbe0}.lp-block i::after{background-color:#365da0}.lp-blocks .lp-block:hover .lp-block-title{color:#365da0}.lp-blocks .lp-block:hover i::after{background-color:#96bbe0}.lp-block-text,.lp-boxes-static .lp-box-text,.lp-section-desc{color:#050918}.lp-boxes .lp-box .lp-box-image{height:300px}.lp-boxes.lp-boxes-animated .lp-box:hover .lp-box-text{max-height:200px}.lp-boxes .lp-box .lp-box-image{height:400px}.lp-boxes.lp-boxes-animated .lp-box:hover .lp-box-text{max-height:300px}.lp-boxes-animated .lp-box-readmore:hover{color:#365da0;opacity:.7}.lp-boxes-static .lp-box-overlay{background-color:rgba(54,93,160,.9)}#cryout_ajax_more_trigger{background-color:#365da0;color:#fff}.lpbox-rnd1{background-color:#c8c8c8}.lpbox-rnd2{background-color:#c3c3c3}.lpbox-rnd3{background-color:#bebebe}.lpbox-rnd4{background-color:#b9b9b9}.lpbox-rnd5{background-color:#b4b4b4}.lpbox-rnd6{background-color:#afafaf}.lpbox-rnd7{background-color:#aaa}.lpbox-rnd8{background-color:#a5a5a5}</style><link rel=https://api.w.org/ href=/www.learncpp.com/wp-json/><link rel=alternate type=application/json href=/www.learncpp.com/wp-json/wp/v2/posts/2809><link rel=canonical href="index.html"><link rel=alternate type=application/json+oembed href="/www.learncpp.com/wp-json/oembed/1.0/embed?url=https%3A%2F%2Fwww.learncpp.com%2Fcpp-tutorial%2Fchapter-17-summary-and-quiz%2F"><link rel=alternate type=text/xml+oembed href="/www.learncpp.com/wp-json/oembed/1.0/embed?url=https%3A%2F%2Fwww.learncpp.com%2Fcpp-tutorial%2Fchapter-17-summary-and-quiz%2F&amp;format=xml"><link rel=stylesheet id=18062-css href="../../blog/wp-content/uploads/custom-css-js/18062.css@v=430.css" media=all><link rel=icon href="../../blog/wp-content/uploads/learncpp.png" sizes=32x32><link rel=icon href="../../blog/wp-content/uploads/learncpp.png" sizes=192x192><link rel=apple-touch-icon href="../../blog/wp-content/uploads/learncpp.png"><meta name=msapplication-TileImage content="/www.learncpp.com/blog/wp-content/uploads/learncpp.png"><style>div.printOnly{margin-left:3em}</style><style media=screen>.printOnly{display:none}</style>
<style id="offline-fix">#site-wrapper{display:block !important;visibility:visible !important;}#container,#content,#main,.main,article.hentry{visibility:visible !important;opacity:1 !important;}.ai-list-data,.lessontables,.lessontables-visible{display:block !important;visibility:visible !important;opacity:1 !important;}.animated-article{opacity:1 !important;transform:none !important;animation:none !important;}.code-block,.cf_monitor,.adsbygoogle,[id^="ezoic-pub-ad-placeholder-"],[class*="ezoic-adpicker-ad"]{display:none !important;width:0 !important;height:0 !important;margin:0 !important;padding:0 !important;overflow:hidden !important;}body{overflow:auto !important;}/* remove top right navigation requested */#access,#mobile-menu,#nav-toggle,#sheader{display:none !important;}#branding{width:100% !important;}#site-header-main-inside{justify-content:flex-start !important;}</style></head><body class="post-template-default single single-post postid-2809 single-format-standard wp-custom-logo wp-embed-responsive septera-image-none septera-caption-one septera-totop-normal septera-bordered-table septera-fixed-menu septera-responsive-headerimage septera-responsive-featured septera-magazine-two septera-magazine-layout septera-comment-placeholder septera-normalizedtags septera-article-animation-slide mobile" itemscope itemtype=http://schema.org/WebPage><div id=site-wrapper><header id=masthead class=cryout itemscope itemtype=http://schema.org/WPHeader role=banner><div id=site-header-main><div id=site-header-main-inside><nav id=mobile-menu><span id=nav-cancel><i class=icon-cancel></i></span><div><ul id=mobile-nav><li id=menu-item-9876 class="menu-item menu-item-type- menu-item-object- menu-item-has-children menu-item-9876"><a><span>Nawiguj</span></a><ul class=sub-menu><li id=menu-item-1009876 class="menu-item menu-item-type- menu-item-object- menu-item-1009876"><a href="../sorting-an-array-using-selection-sort/index.html"><span><i class="cpp_menu _mi _before fa fa-chevron-circle-right"></i>18.1 — Sortowanie tablicy za pomocą sortowania przez wybór</span></a><li class="menu-item menu-item-type- menu-item-object- menu-item-1009876"><a href="/www.learncpp.com/"><span><i class="cpp_menu _mi _before fa fa-home"></i>Spis treści</span></a><li class="menu-item menu-item-type- menu-item-object- menu-item-1009876"><a href="../multidimensional-stdarray/index.html"><span><i class="cpp_menu _mi _before fa fa-chevron-circle-left"></i>17.13 — Wielowymiarowe std::array</span></a></ul><li id=menu-item-6312 class="menu-item menu-item-type-post_type menu-item-object-page menu-item-6312"><a href=/www.learncpp.com/learn-cpp-site-index/><span><i class="_mi _before fa fa-crosshairs" aria-hidden=true></i><span>Indeks witryny</span></span></a><li id=menu-item-12722 class="menu-item menu-item-type-post_type menu-item-object-page menu-item-12722"><a href=/www.learncpp.com/latest-changes/><span><i class="_mi _before fa fa-list" aria-hidden=true></i><span>Najnowsze zmiany</span></span></a><li id=menu-item-6313 class="menu-item menu-item-type-post_type menu-item-object-page menu-item-has-children menu-item-6313"><a href=/www.learncpp.com/about/><span>O </span></a><ul class=sub-menu><li id=menu-item-12083 class="menu-item menu-item-type-post_type menu-item-object-post menu-item-12083"><a href=/www.learncpp.com/leave-feedback-report-issue/><span><i class="_mi _before fa fa-comment" aria-hidden=true></i><span>Wystaw opinię</span></span></a><li id=menu-item-11706 class="menu-item menu-item-type-post_type menu-item-object-post menu-item-11706"><a href=/www.learncpp.com/leave-feedback-report-issue/><span><i class="_mi _before fa fa-bug" aria-hidden=true></i><span>Zgłoś problem</span></span></a><li id=menu-item-11707 class="menu-item menu-item-type-post_type menu-item-object-page menu-item-11707"><a href=/www.learncpp.com/about/><span><i class="_mi _before dashicons dashicons-welcome-write-blog" aria-hidden=true></i><span>Kontakt / wsparcie</span></span></a><li id=menu-item-11705 class="menu-item menu-item-type-custom menu-item-object-custom menu-item-11705"><a href="../introduction-to-these-tutorials.html#FAQ"><span><i class="_mi _before fa fa-question-circle" aria-hidden=true></i><span>Często zadawane pytania dotyczące witryny</span></span></a><li id=menu-item-17734 class="menu-item menu-item-type-custom menu-item-object-custom menu-item-17734"><a href=https://g.ezoic.net/privacy/learncpp.com><span><i class="_mi _before fa fa-bed" aria-hidden=true></i><span>Polityka prywatności</span></span></a><li id=menu-item-16006 class="menu-item menu-item-type-post_type menu-item-object-page menu-item-16006"><a href=/www.learncpp.com/about/><span><i class="_mi _before fa fa-smile-o" aria-hidden=true></i><span>Przekaż darowiznę</span></span></a></ul><li id=menu-item-12082 class="menu-item menu-item-type-custom menu-item-object-custom menu-item-12082"><a title="LearnCPP nie ma natywnego trybu ciemnego, ale ten link przeniesie Cię do wtyczki przeglądarki, która pozwoli Ci przyciemnić dowolną stronę internetową." target=_blank rel=noopener href=https://darkreader.org/><span><i class="_mi _before fa fa-moon-o" aria-hidden=true></i><span> </span></span></a><li class="menu-main-search menu-search-animated"><a role=link "/www.learncpp.com/cpp-tutorial/chapter-17-summary-and-quiz/href"><i class=icon-search></i><span class=screen-reader-text>Szukaj</span></a><form apbct-form-sign=native_search role=search class=searchform action=/www.learncpp.com/><label><span class=screen-reader-text>Szukaj:</span>
<input type=search class=s placeholder=Search name=s></label>
<button class=searchsubmit><span class=screen-reader-text>Szukaj</span><i class=icon-search></i></button>
<input class="apbct_special_field apbct_email_id__search_form" name=apbct__email_id__search_form aria-label=apbct__label_id__search_form size=30 maxlength=200 autocomplete=off><input id=apbct_submit_id__search_form class="apbct_special_field apbct__email_id__search_form" name=apbct__label_id__search_form aria-label=apbct_submit_name__search_form type=submit size=30 maxlength=200 value=48857></form></ul></div></nav><div id=branding><div class=identity><a href=/www.learncpp.com/ id=logo class=custom-logo-link title="Naucz się C++" rel=home><img src="../../blog/wp-content/uploads/learncpp.png" class=custom-logo alt="Naucz się C++"></a></div><div id=site-text><div itemprop=headline id=site-title><span><a href=/www.learncpp.com/ title="Zdobądź umiejętności dzięki naszym darmowym samouczkom" rel=home>Naucz się C++</a></span></div><span id=site-description itemprop=description>Zdobądź umiejętności dzięki naszym darmowym samouczkom</span></div></div><a id=nav-toggle><i class=icon-menu></i></a><nav id=access role=navigation aria-label="Menu główne" itemscope itemtype=http://schema.org/SiteNavigationElement><div class="skip-link screen-reader-text"><a href="index.html#main" title="Przejdź do treść">Przejdź do treść</a></div><div><ul id=prime_nav><li class="menu-item menu-item-type- menu-item-object- menu-item-has-children menu-item-9876"><a><span>Nawiguj</span></a><ul class=sub-menu><li class="menu-item menu-item-type- menu-item-object- menu-item-1009876"><a href="../sorting-an-array-using-selection-sort/index.html"><span><i class="cpp_menu _mi _before fa fa-chevron-circle-right"></i>18.1 — Sortowanie tablicy za pomocą sortowania przez wybór</span></a><li class="menu-item menu-item-type- menu-item-object- menu-item-1009876"><a href="/www.learncpp.com/"><span><i class="cpp_menu _mi _before fa fa-home"></i>Spis treści</span></a><li class="menu-item menu-item-type- menu-item-object- menu-item-1009876"><a href="../multidimensional-stdarray/index.html"><span><i class="cpp_menu _mi _before fa fa-chevron-circle-left"></i>17.13 — Wielowymiarowe std::array</span></a></ul><li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-6312"><a href=/www.learncpp.com/learn-cpp-site-index/><span><i class="_mi _before fa fa-crosshairs" aria-hidden=true></i><span>Indeks witryny</span></span></a><li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-12722"><a href=/www.learncpp.com/latest-changes/><span><i class="_mi _before fa fa-list" aria-hidden=true></i><span>Najnowsze zmiany</span></span></a><li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-has-children menu-item-6313"><a href=/www.learncpp.com/about/><span>O </span></a><ul class=sub-menu><li class="menu-item menu-item-type-post_type menu-item-object-post menu-item-12083"><a href=/www.learncpp.com/leave-feedback-report-issue/><span><i class="_mi _before fa fa-comment" aria-hidden=true></i><span>Wystaw opinię</span></span></a><li class="menu-item menu-item-type-post_type menu-item-object-post menu-item-11706"><a href=/www.learncpp.com/leave-feedback-report-issue/><span><i class="_mi _before fa fa-bug" aria-hidden=true></i><span>Zgłoś problem</span></span></a><li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-11707"><a href=/www.learncpp.com/about/><span><i class="_mi _before dashicons dashicons-welcome-write-blog" aria-hidden=true></i><span>Kontakt / wsparcie</span></span></a><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-11705"><a href="../introduction-to-these-tutorials.html#FAQ"><span><i class="_mi _before fa fa-question-circle" aria-hidden=true></i><span>Często zadawane pytania dotyczące witryny</span></span></a><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-17734"><a href=https://g.ezoic.net/privacy/learncpp.com><span><i class="_mi _before fa fa-bed" aria-hidden=true></i><span>Polityka prywatności</span></span></a><li class="menu-item menu-item-type-post_type menu-item-object-page menu-item-16006"><a href=/www.learncpp.com/about/><span><i class="_mi _before fa fa-smile-o" aria-hidden=true></i><span>Przekaż darowiznę</span></span></a></ul><li class="menu-item menu-item-type-custom menu-item-object-custom menu-item-12082"><a title="LearnCPP nie ma natywnego trybu ciemnego, ale ten link przeniesie Cię do wtyczki przeglądarki, która pozwoli Ci przyciemnić dowolną stronę internetową." target=_blank rel=noopener href=https://darkreader.org/><span><i class="_mi _before fa fa-moon-o" aria-hidden=true></i><span> </span></span></a><li class="menu-main-search menu-search-animated"><a role=link "/www.learncpp.com/cpp-tutorial/chapter-17-summary-and-quiz/href"><i class=icon-search></i><span class=screen-reader-text>Szukaj</span></a><form apbct-form-sign=native_search role=search class=searchform action=/www.learncpp.com/><label><span class=screen-reader-text>Szukaj:</span>
<input type=search class=s placeholder=Search name=s></label>
<button class=searchsubmit><span class=screen-reader-text>Szukaj</span><i class=icon-search></i></button>
<input class="apbct_special_field apbct_email_id__search_form" name=apbct__email_id__search_form aria-label=apbct__label_id__search_form size=30 maxlength=200 autocomplete=off><input id=apbct_submit_id__search_form class="apbct_special_field apbct__email_id__search_form" name=apbct__label_id__search_form aria-label=apbct_submit_name__search_form type=submit size=30 maxlength=200 value=40565></form></ul></div></nav></div></div><div id=header-image-main><div id=header-image-main-inside><div class=header-image style=background-image:url(../../blog/wp-content/uploads/stripe.jpg)></div><img class=header-image alt="17.x — podsumowanie rozdziału 17 i quiz" src="../../blog/wp-content/uploads/stripe.jpg"></div></div></header><div id=content class=cryout><div id=container class=three-columns-sided><main id=main role=main class=main><article id=post-2809 class="post-2809 post type-post status-publish format-standard hentry category-cpp-tutorial" itemscope itemtype=http://schema.org/Article itemprop=mainEntity><div class=schema-image></div><div class=article-inner><header><div class="entry-meta beforetitle-meta"></div><h1 class="entry-title singular-title" itemprop=headline>17.x — podsumowanie rozdziału 17 i quiz</h1><div class="entry-meta aftertitle-meta"><span class="author vcard" itemscope itemtype=http://schema.org/Person itemprop=author><i class="icon-author icon-metas" title=Autor></i><a class="url fn n" rel=author href=/www.learncpp.com/author/Alex/ title="Wyświetl wszystkie posty Alexa" itemprop=url><em itemprop=name>Alex</em></a></span>
<span class="onDate date"><i class="icon-date icon-metas" title=Date></i><time class=published datetime=2015-10-05T16:20:13-07:00 itemprop=datePublished>5 października 2015, 16:20 czasu PDT</time>
<time class=updated datetime=2025-01-06T14:06:38-08:00 itemprop=dateModified>6 stycznia 2025</time></span></div></header><div class=entry-content itemprop=articleBody><div class="code-block code-block-1" style="margin:8px 8px 8px 0;float:left"><div class=cf_monitor style=margin-right:16px><div id=ezoic-pub-ad-placeholder-101></div><ins class=adsbygoogle style=display:inline-block;width:336px;height:280px data-ad-client=ca-pub-0588844875925051 data-ad-slot=7945645163></ins></div></div><p class=cpp-section>Przegląd rozdziału<p><strong>Tablice o stałym rozmiarze</strong> (lub <strong>tablicami o stałej długości</strong>) wymagają, aby długość tablicy była znana w momencie tworzenia instancji i ta długość nie można później zmienić. Tablice w stylu C i  <code>std::array</code> są tablicami o stałym rozmiarze. Rozmiar tablic dynamicznych można zmieniać w czasie wykonywania. <code>std::vector</code> jest tablicą dynamiczną.<p>Długość <code>std::array</code> musi być wyrażeniem stałym. Najczęściej podaną wartością długości będzie literał całkowity, zmienna constexpr lub moduł wyliczający bez zakresu.<p><code>std::array</code> jest agregatem. Oznacza to, że nie ma konstruktorów i zamiast tego jest inicjowany przy użyciu inicjalizacji agregowanej.<p>Zdefiniuj swój <code>std::array</code> jako constexpr, jeśli to możliwe. Jeśli  <code>std::array</code> nie jest constexpr, rozważ użycie  <code>std::vector</code> .<p>Użyj odliczenia argumentów szablonu klasy (CTAD), aby kompilator wywnioskował typ i długość std::array z jej inicjatorów. <div class="code-block code-block-2" style="margin:8px 0;clear:both"><div class=cf_monitor><div id=ezoic-pub-ad-placeholder-130></div></div></div><p><code>std::array</code> jest zaimplementowany jako struktura szablonu, której deklaracja wygląda następująco:<pre class="language-cpp line-numbers"><code class="language-cpp match-braces">template&lt;typename T, std::size_t N&gt; // N is a non-type template parameter
struct array;</code></pre><p>Nietypowy parametr szablonu reprezentujący długość tablicy (<code>N</code>) ma typ <code>std::size_t</code>.<p>Aby uzyskać długość <code>std::array</code>:<ul><li>Możemy zapytać  <code>std::array</code> obiekt o jego długość za pomocą  <code>size()</code> funkcji składowej (która zwraca długość jako bez znaku <code>size_type</code>).<li>W C++17 możemy użyć <code>std::size()</code> nieelementowej (która for <code>std::array</code> po prostu wywołuje funkcję składową <code>size()</code> , zwracając w ten sposób długość bez znaku <code>size_type</code>).<li>W C++20 możemy użyć <code>std::ssize()</code> funkcja niebędąca członkiem, która zwraca długość jako dużą <em>podpisany</em> typ integralny (zwykle<code>std::ptrdiff_t</code>).</ul><p>Wszystkie trzy funkcje zwrócą długość jako wartość constexpr, z wyjątkiem sytuacji, gdy zostaną wywołane w <code>std::array</code> przekazanej przez referencję. Ten defekt został rozwiązany w C++23 przez <a href=https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2280r4.html>P2280</a>.<p>Aby zaindeksować <code>std::array</code>:<ul><li>Użyj operatora indeksu dolnego (<code>operator[]</code>). W tym przypadku nie jest wykonywane żadne sprawdzanie granic, a przekazanie nieprawidłowego indeksu spowoduje niezdefiniowane zachowanie.<li>Użyj  <code>at()</code> funkcji składowej, która wykonuje indeks dolny ze sprawdzaniem granic w czasie wykonywania. Zalecamy unikać tę funkcję, ponieważ zazwyczaj chcemy sprawdzić granice przed indeksowaniem lub chcemy sprawdzić granice w czasie kompilacji.<li>Użyj  <code>std::get()</code> szablonu funkcji, który przyjmuje indeks jako argument szablonu niebędący typem i sprawdza granice w czasie kompilacji.</ul><p>Możesz przekazywać  <code>std::array</code> z różnymi typami elementów i długościami do funkcji, używając szablonu funkcji z parametrem szablonu deklaracja <code>template &lt;typename T, std::size_t N></code>. Lub w C++20 użyj <code>template &lt;typename T, auto N></code>.<div class="code-block code-block-3" style="margin:8px 0;clear:both"><div class=cf_monitor><div id=ezoic-pub-ad-placeholder-108></div></div></div><p>Zwrócenie <code>std::array</code> by wartością spowoduje utworzenie kopii tablicy i wszystkich elementów, ale może to być w porządku, jeśli tablica jest mała, a kopiowanie elementów nie jest drogie. W niektórych kontekstach lepszym wyborem może być użycie parametru out.<p>Podczas inicjalizacji <code>std::array</code> w przypadku struktury, klasy lub tablicy i bez podawania typu elementu przy każdym inicjatorze, będziesz potrzebować dodatkowej pary nawiasów klamrowych, aby kompilator właściwie zinterpretował to, co należy zainicjować. Jest to artefakt inicjowania agregacji, a inne standardowe typy kontenerów bibliotecznych (które używają konstruktorów list) nie wymagają w takich przypadkach podwójnych nawiasów.<p>Agregaty w C++ obsługują koncepcję zwaną <strong>elizja nawiasów</strong>, która określa pewne zasady dotyczące sytuacji, gdy może występować wiele nawiasów klamrowych. ogólnie rzecz biorąc, można pominąć nawiasy klamrowe podczas inicjowania  <code>std::array</code> za pomocą wartości skalarnych (pojedynczych) lub podczas inicjowania z typami klasowymi lub tablicami, gdzie typ jest jawnie nazwany przy każdym elemencie.<p>Nie możesz mieć tablicy odniesień, ale możesz mieć tablicę <code>std::reference_wrapper</code>, która zachowuje się jak modyfikowalne odwołanie do wartości.<p>Jest kilka rzeczy, o których warto pamiętać <code>std::reference_wrapper</code>:<div class="code-block code-block-4" style="margin:8px 0;clear:both"><div class=cf_monitor><div id=ezoic-pub-ad-placeholder-124></div></div></div><ul><li><code>Operator=</code> ponowne osadzenie a <code>std::reference_wrapper</code> (zmiana obiektu, do którego się odwołuje).<li><code>std::reference_wrapper&lt;T></code> będzie niejawnie konwertowana do <code>T&</code>.<li>Klasa <code>get()</code> funkcji składowej, której można użyć do uzyskania <code>T&</code>. Jest to przydatne, gdy chcemy zaktualizować wartość obiektu, do którego się odwołujemy.</ul><p>Klasa <code>std::ref()</code> i <code>std::cref()</code> funkcje zostały udostępnione jako skróty do tworzenia <code>std::reference_wrapper</code> i <code>const std::reference_wrapper</code> owinięte obiektów.<p>Użyj <code>static_assert</code> jeśli to możliwe, upewnij się, <code>constexpr std::array</code> przy użyciu CTAD ma poprawną liczbę inicjatorów.<p>Tablice w stylu C zostały odziedziczone z języka C i są wbudowane w rdzeń języka C++. Ponieważ są częścią języka podstawowego, tablice w stylu C mają własną składnię deklaracji specjalnych. W deklaracji tablicy w stylu C używamy nawiasów kwadratowych ([]), aby poinformować kompilator, że zadeklarowany obiekt jest tablicą w stylu C. Wewnątrz nawiasów kwadratowych możemy opcjonalnie podać długość tablicy, która jest wartością całkowitą typu std::size_t, która informuje kompilator, ile elementów znajduje się w tablicy. Długość tablicy w stylu C musi być wyrażeniem stałym.<p>Tablice w stylu C są agregowane, co oznacza, że ​​można je inicjować przy użyciu inicjalizacji agregowanej. Używając listy inicjatorów do inicjowania wszystkich elementów tablicy w stylu C, lepiej pominąć długość i pozwolić kompilatorowi obliczyć długość tablicy.<p>Tablice w stylu C można indeksować za pomocą <code>operator[]</code>. Indeks tablicy w stylu C może być liczbą całkowitą ze znakiem lub bez znaku, albo wyliczeniem bez zakresu. Oznacza to, że tablice w stylu C nie podlegają wszystkim problemom z indeksowaniem konwersji znaków, które występują w standardowych klasach kontenerów bibliotek!<div class="code-block code-block-5" style="margin:8px 0;clear:both"><div class=cf_monitor><div id=ezoic-pub-ad-placeholder-120></div></div></div><p>Tablice w stylu C mogą być const lub constexpr.<p>Aby uzyskać długość tablicy w stylu C:<ul><li>W C++17 możemy użyć <code>std::size()</code> funkcji niebędącej składową, która zwraca długość jako unsigned <code>std::size_t</code>.<li>W C++20 możemy użyć <code>std::ssize()</code> funkcja niebędąca członkiem, która zwraca długość jako dużą <em>podpisany</em> typ integralny (zwykle<code>std::ptrdiff_t</code>).</ul><p>W większości przypadków, gdy w wyrażeniu używana jest tablica w stylu C, tablica zostanie niejawnie przekonwertowana na wskaźnik do typu elementu, zainicjowany adresem pierwszego elementu (z indeksem 0). Potocznie nazywa się to  <strong>rozpadem tablicy</strong> (lub po prostu w skrócie rozpadu).<p><strong>Arytmetyka wskaźników</strong> to funkcja, która pozwala nam zastosować pewne operatory arytmetyczne na liczbach całkowitych (dodawanie, odejmowanie, zwiększanie lub zmniejszanie) do wskaźnika w celu wygenerowania nowego adresu pamięci. Biorąc pod uwagę pewien wskaźnik <code>ptr</code>, <code>ptr + 1</code> zwraca adres następnego <em>obiektu</em> w pamięci (w zależności od typu, na który wskazuje).<p>Użyj indeksu dolnego podczas indeksowania od początku tablicy (element 0), tak aby indeksy tablicy pokrywały się z elementem.<br>Użyj arytmetyki wskaźników podczas wykonywania względnych pozycjonowanie z danego elementu.<div class="code-block code-block-6" style="margin:8px 0;clear:both"><div class=cf_monitor><div id=ezoic-pub-ad-placeholder-125></div></div></div><p>Ciągi w stylu C to po prostu tablice w stylu C, których typ elementu to <code>char</code> lub <code>const char</code>. W związku z tym ciągi w stylu C będą się rozpadać.<p>Klasa <strong>wymiar</strong> tablicy to liczba indeksów potrzebnych do wybrania elementu.<p>Tablica zawierająca tylko jeden wymiar nazywana jest <strong>tablicą jednowymiarową</strong> lub a <strong>tablicą jednowymiarową</strong> (czasami w skrócie <strong>1d tablica</strong>). Tablica tablic nazywana jest <strong>tablicą dwuwymiarową</strong> (czasami w skrócie <strong>tablicą 2d</strong>), ponieważ ma dwa indeksy dolne. Tablice z więcej niż jednym wymiarem nazywane są <strong>tablicami wielowymiarowymi</strong>. <strong>Spłaszczanie</strong> tablica to proces zmniejszania wymiarowości tablicy (często do jednego wymiaru).<p>W C++23  <code>std::mdspan</code> to widok zapewniający wielowymiarowy interfejs tablicy dla ciągłej sekwencji elementów.<p class="cpp-section cpp-topline" style=clear:both>Czas quizu<p class=cpp-quiz-question style=clear:both>Pytanie nr 1<p>Co jest nie tak z każdym z tych fragmentów i jak to naprawić?<div class="code-block code-block-7" style="margin:8px 0;clear:both"><div class=cf_monitor><div id=ezoic-pub-ad-placeholder-121></div></div></div><p>A)<pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;array&gt;
#include &lt;iostream&gt;

int main()
{
    std::array arr { 0, 1, 2, 3 };

    for (std::size_t count{ 0 }; count &lt;= std::size(arr); ++count)
    {
        std::cout &lt;&lt; arr[count] &lt;&lt; &#39; &#39;;
    }

    std::cout &lt;&lt; &#39;\n&#39;;

    return 0;
}</code></pre><p><a class=solution_link_show href=javascript:void(0) onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_0'),this,'Show Solution','Hide Solution')">Pokaż rozwiązanie</a><div class=wpsolution id=cpp_solution_id_0 style=display:none><p>Pętla for zawiera błąd o jeden i próbuje uzyskać dostęp do elementu tablicy o indeksie 4, który nie istnieje.<p>Rozwiązanie: warunek w pętli for powinien użyć &lt; zamiast &lt;=.</div><p>B)<pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;iostream&gt;

void printArray(int array[])
{
    for (int element : array)
    {
        std::cout &lt;&lt; element &lt;&lt; &#39; &#39;;
    }
}

int main()
{
    int array[] { 9, 7, 5, 3, 1 };

    printArray(array);

    std::cout &lt;&lt; &#39;\n&#39;;

    return 0;
}</code></pre><p><a class=solution_link_show href=javascript:void(0) onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_1'),this,'Show Solution','Hide Solution')">Pokaż rozwiązanie</a><div class=wpsolution id=cpp_solution_id_1 style=display:none><p><code>array</code> zamienia się na wskaźnik, gdy tak się stanie zostaje przekazany do <code>printArray()</code>. Pętle for oparte na zakresach nie mogą działać ze wskaźnikiem do tablicy, ponieważ rozmiar tablicy nie jest znany.<p>Rozwiązanie: zamiast tego użyj <code>std::array</code> , który nie zanika.</div><p>C)<pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;array&gt;
#include &lt;iostream&gt;

int main()
{
    std::cout &lt;&lt; &#34;Enter the number of test scores: &#34;;
    std::size_t length{};
    std::cin &gt;&gt; length;

    std::array&lt;int, length&gt; scores;

    for (std::size_t i { 0 } ; i &lt; length; ++i)
    {
        std::cout &lt;&lt; &#34;Enter score &#34; &lt;&lt; i &lt;&lt; &#34;: &#34;;
        std::cin &gt;&gt; scores[i];
    }
    return 0;
}</code></pre><p><a class=solution_link_show href=javascript:void(0) onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_2'),this,'Show Solution','Hide Solution')">Pokaż rozwiązanie</a><div class=wpsolution id=cpp_solution_id_2 style=display:none><p><code>length</code> nie jest wyrażeniem stałym i nie można go użyć do zdefiniowania długości <code>std::array</code>.<p>Rozwiązanie: użyj  <code>std::vector</code> .</div><p class="cpp-quiz-question cpp-topline" style=clear:both>Pytanie nr 2<p>W tym quizie będziemy uruchom sklep z eliksirami Roscoe, najlepszy sklep z eliksirami w kraju! To będzie większe wyzwanie.<p>Zaimplementuj program, który wyświetli następujące wyniki:<div class="code-block code-block-8" style="margin:8px 0;clear:both"><div class=cf_monitor><div id=ezoic-pub-ad-placeholder-126></div></div></div><pre>Welcome to Roscoe&#39;s potion emporium!
Enter your name: Alex
Hello, Alex, you have 85 gold.

Here is our selection for today:
0) healing costs 20
1) mana costs 30
2) speed costs 12
3) invisibility costs 50
Enter the number of the potion you&#39;d like to buy, or &#39;q&#39; to quit: a
That is an invalid input.  Try again: 3
You purchased a potion of invisibility.  You have 35 gold left.

Here is our selection for today:
0) healing costs 20
1) mana costs 30
2) speed costs 12
3) invisibility costs 50
Enter the number of the potion you&#39;d like to buy, or &#39;q&#39; to quit: 4
That is an invalid input.  Try again: 2
You purchased a potion of speed.  You have 23 gold left.

Here is our selection for today:
0) healing costs 20
1) mana costs 30
2) speed costs 12
3) invisibility costs 50
Enter the number of the potion you&#39;d like to buy, or &#39;q&#39; to quit: 2
You purchased a potion of speed.  You have 11 gold left.

Here is our selection for today:
0) healing costs 20
1) mana costs 30
2) speed costs 12
3) invisibility costs 50
Enter the number of the potion you&#39;d like to buy, or &#39;q&#39; to quit: 4
You can not afford that.

Here is our selection for today:
0) healing costs 20
1) mana costs 30
2) speed costs 12
3) invisibility costs 50
Enter the number of the potion you&#39;d like to buy, or &#39;q&#39; to quit: q

Your inventory contains: 
2x potion of speed
1x potion of invisibility
You escaped with 11 gold remaining.

Thanks for shopping at Roscoe&#39;s potion emporium!
</pre><p>Gracz zaczyna z losową ilością złota od 80 do 120.<p>Brzmi zabawnie? Zróbmy to! Ponieważ trudno będzie wdrożyć to wszystko na raz, będziemy rozwijać to stopniowo.<p class="cpp-quiz-question cpp-topline" style=clear:both>&gt; Krok #1<p>Utwórz <code>Potion</code> przestrzeń nazw zawierająca wyliczenie o nazwie <code>Type</code> zawierające typy mikstur. Utwórz dwa <code>std::array</code>: jakiś <code>int</code> tablica do przechowywania kosztów mikstur, oraz a <code>std::string_view</code> tablica do przechowywania nazw mikstur.<p>Napisz także funkcję o nazwie <code>shop()</code> który wylicza poprzez listę <code>Potions</code> i drukuje ich numery, nazwy i koszt.<p>Program powinien wypisać co następuje:<pre>Here is our selection for today:
0) healing costs 20
1) mana costs 30
2) speed costs 12
3) invisibility costs 50
</pre><p><a class=hint_link_show href=javascript:void(0) onclick="cppHintToggle(document.getElementById('cpp_hint_id_0'),this,'Show Hint','')">Pokaż wskazówkę</a><div class=wphint id=cpp_hint_id_0 style=display:none;margin-bottom:1em>Wskazówka: W lekcji pokażemy metodę iteracji wyliczenia przy użyciu pętli for opartej na zakresie <a href="../stdarray-and-enumerations/index.html">17.6 — std::array i wyliczenia</a>.</div><p><a class=solution_link_show href=javascript:void(0) onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_3'),this,'Show Solution','Hide Solution')">Pokaż rozwiązanie</a><div class=wpsolution id=cpp_solution_id_3 style=display:none><pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;array&gt;
#include &lt;iostream&gt;
#include &lt;string_view&gt;

namespace Potion
{
    enum Type
    {
    healing,
    mana,
    speed,
    invisibility,
    max_potions
    };

    constexpr std::array types { healing, mana, speed, invisibility }; // An array of our enumerators

    // We could put these in a struct, but since we only have two attributes we&#39;ll keep them separate for now
    // We will explicitly define the element type so we don&#39;t have to use the sv suffix
    constexpr std::array&lt;std::string_view, max_potions&gt; name { &#34;healing&#34;, &#34;mana&#34;, &#34;speed&#34;, &#34;invisibility&#34; };
    constexpr std::array cost { 20, 30, 12, 50 };

    static_assert(std::size(types) == max_potions);  // ensure &#39;all&#39; contains the correct number of enumerators
    static_assert(std::size(cost) == max_potions);
    static_assert(std::size(name) == max_potions);
}

void shop()
{
    std::cout &lt;&lt; &#34;Here is our selection for today:\n&#34;;

    for (auto p: Potion::types)
        std::cout &lt;&lt; p &lt;&lt; &#34;) &#34; &lt;&lt; Potion::name[p] &lt;&lt; &#34; costs &#34; &lt;&lt; Potion::cost[p] &lt;&lt; &#39;\n&#39;;
}

int main()
{
    shop();

    return 0;
}</code></pre></div><p class="cpp-quiz-question cpp-topline" style=clear:both>&gt; Krok #2<p>Utwórz <code>Player</code> klasa do przechowywania imienia gracza, ekwipunku mikstur i złota. Dodaj tekst wprowadzający i pożegnalny dotyczący emporium Roscoe. Zdobądź imię gracza i losuj jego złoto.<p>Wykorzystaj na lekcji plik „Random.h”. <a href="../global-random-numbers-random-h/index.html#RandomH">8.15 -- Globalne liczby losowe (Random.h)</a> aby ułatwić randomizację.<p>Program powinien wypisać co następuje:<pre>Welcome to Roscoe&#39;s potion emporium!
Enter your name: Alex
Hello, Alex, you have 84 gold.

Here is our selection for today:
0) healing costs 20
1) mana costs 30
2) speed costs 12
3) invisibility costs 50

Thanks for shopping at Roscoe&#39;s potion emporium!
</pre><p><a class=solution_link_show href=javascript:void(0) onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_4'),this,'Show Solution','Hide Solution')">Pokaż rozwiązanie</a><div class=wpsolution id=cpp_solution_id_4 style=display:none><pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;array&gt;
#include &lt;iostream&gt;
#include &lt;string_view&gt;
#include &#34;Random.h&#34;

namespace Potion
{
    enum Type
    {
        healing,
        mana,
        speed,
        invisibility,
        max_potions
    };

    constexpr std::array types { healing, mana, speed, invisibility }; // An array of our enumerators

    // We could put these in a struct, but since we only have two attributes we&#39;ll keep them separate for now
    // We will explicitly define the element type so we don&#39;t have to use the sv suffix
    constexpr std::array&lt;std::string_view, max_potions&gt; name { &#34;healing&#34;, &#34;mana&#34;, &#34;speed&#34;, &#34;invisibility&#34; };
    constexpr std::array cost { 20, 30, 12, 50 };

    static_assert(std::size(types) == max_potions);  // ensure &#39;all&#39; contains the correct number of enumerators
    static_assert(std::size(cost) == max_potions);
    static_assert(std::size(name) == max_potions);
}

class Player
{
private:
    static constexpr int s_minStartingGold { 80 };
    static constexpr int s_maxStartingGold { 120 };

    std::string m_name {};
    int m_gold {};
    std::array&lt;int, Potion::max_potions&gt; m_inventory { };

public:
    explicit Player(std::string_view name) :
        m_name { name },
        m_gold { Random::get(s_minStartingGold, s_maxStartingGold) }
    { 
    }

    int gold() const { return m_gold; }
    int inventory(Potion::Type p) const { return m_inventory[p]; }
};

void shop()
{
    std::cout &lt;&lt; &#34;Here is our selection for today:\n&#34;;

    for (auto p: Potion::types)
        std::cout &lt;&lt; p &lt;&lt; &#34;) &#34; &lt;&lt; Potion::name[p] &lt;&lt; &#34; costs &#34; &lt;&lt; Potion::cost[p] &lt;&lt; &#39;\n&#39;;
}

int main()
{
    std::cout &lt;&lt; &#34;Welcome to Roscoe&#39;s potion emporium!\n&#34;;
    std::cout &lt;&lt; &#34;Enter your name: &#34;;

    std::string name{};
    std::getline(std::cin &gt;&gt; std::ws, name); // read a full line of text into name

    Player player { name };

    std::cout &lt;&lt; &#34;Hello, &#34; &lt;&lt; name &lt;&lt; &#34;, you have &#34; &lt;&lt; player.gold() &lt;&lt; &#34; gold.\n\n&#34;;

    shop();

    std::cout &lt;&lt; &#34;\nThanks for shopping at Roscoe&#39;s potion emporium!\n&#34;;

    return 0;
}</code></pre></div><p class="cpp-quiz-question cpp-topline" style=clear:both>&gt; Krok #3<p>Dodaj możliwość zakupu mikstur i obsługi nieprawidłowych danych wejściowych (każde obce dane wejściowe traktuj jako awarię). Wydrukuj ekwipunek gracza po jego wyjściu. Po tym kroku program powinien być gotowy.<p>Upewnij się, że testujesz następujące przypadki:<ul><li>Użytkownik wprowadza nieprawidłowy numer mikstury (np. „d”)<li>Użytkownik wprowadza prawidłowy numer mikstury, ale z dodatkowymi danymi (np. <code>2d</code>, <code>25</code>)</ul><p>Na lekcji omówimy obsługę nieprawidłowych danych wejściowych <a href="../stdcin-and-handling-invalid-input/index.html">9.5 — std::cin i obsługa nieprawidłowych danych wejściowych</a>.<p><a class=hint_link_show href=javascript:void(0) onclick="cppHintToggle(document.getElementById('cpp_hint_id_1'),this,'Show Hint','')">Pokaż wskazówkę</a><div class=wphint id=cpp_hint_id_1 style=display:none;margin-bottom:1em>Wskazówka: użytkownik może wprowadzić liczbę lub „q”, dlatego wyodrębnij dane wprowadzone przez użytkownika, aby wpisać <code>char</code>.<p><p>Aby przekonwertować znak liczby ASCII na liczbę typu int (np. <code>'5'</code> Do <code>5</code>), możesz użyć następujących opcji:<pre class="language-cpp line-numbers"><code class="language-cpp match-braces">int charNumToInt(char c)
{
    return c - &#39;0&#39;;
}</code></pre></div><p><a class=hint_link_show href=javascript:void(0) onclick="cppHintToggle(document.getElementById('cpp_hint_id_2'),this,'Show Hint','')">Pokaż wskazówkę</a><div class=wphint id=cpp_hint_id_2 style=display:none;margin-bottom:1em>Wskazówka: Napisz funkcję obsługującą dane wprowadzane przez użytkownika. Powinien zwrócić <code>Potion::Type</code> wybrany przez użytkownika. Jeśli zamiast tego użytkownik zakończy działanie, funkcja może powrócić <code>Potion::max_potions</code>. Będziesz musiał static_cast wprowadzić dane użytkownika do a <code>Potion::Type</code>.</div><p><a class=solution_link_show href=javascript:void(0) onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_5'),this,'Show Solution','Hide Solution')">Pokaż rozwiązanie</a><div class=wpsolution id=cpp_solution_id_5 style=display:none><pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;array&gt;
#include &lt;iostream&gt;
#include &lt;limits&gt; // for std::numeric_limits
#include &lt;string_view&gt;
#include &#34;Random.h&#34;

namespace Potion
{
    enum Type
    {
        healing,
        mana,
        speed,
        invisibility,
        max_potions
    };

    constexpr std::array types { healing, mana, speed, invisibility }; // An array of our enumerators

    // We could put these in a struct, but since we only have two attributes we&#39;ll keep them separate for now
    // We will explicitly define the element type so we don&#39;t have to use the sv suffix
    constexpr std::array&lt;std::string_view, max_potions&gt; name { &#34;healing&#34;, &#34;mana&#34;, &#34;speed&#34;, &#34;invisibility&#34; };
    constexpr std::array cost { 20, 30, 12, 50 };

    static_assert(std::size(types) == max_potions);  // ensure &#39;all&#39; contains the correct number of enumerators
    static_assert(std::size(cost) == max_potions);
    static_assert(std::size(name) == max_potions);
}

class Player
{
private:
    static constexpr int s_minStartingGold { 80 };
    static constexpr int s_maxStartingGold { 120 };

    std::string m_name {};
    int m_gold {};
    std::array&lt;int, Potion::max_potions&gt; m_inventory { };

public:
    explicit Player(std::string_view name) :
        m_name { name },
        m_gold { Random::get(s_minStartingGold, s_maxStartingGold) }
    { 
    }

    // returns false if can&#39;t afford, true if purchased
    bool buy(Potion::Type type)
    {
        if (m_gold &lt; Potion::cost[type])
            return false;

        m_gold -= Potion::cost[type];
        ++m_inventory[type];
        return true;
    }

    int gold() const { return m_gold; }
    int inventory(Potion::Type p) const { return m_inventory[p]; }
};

void ignoreLine()
{
    std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), &#39;\n&#39;);
}

int charNumToInt(char c)
{
    return c - &#39;0&#39;;
}

Potion::Type whichPotion()
{
    std::cout &lt;&lt; &#34;Enter the number of the potion you&#39;d like to buy, or &#39;q&#39; to quit: &#34;;
    char input{};
    while (true)
    {
        std::cin &gt;&gt; input;
        if (!std::cin)
        {
            std::cin.clear(); // put us back in &#39;normal&#39; operation mode
            ignoreLine(); // and remove the bad input
            continue;
        }

        // If there is extraneous input, treat as failure case
        if (!std::cin.eof() &amp;&amp; std::cin.peek() != &#39;\n&#39;)
        {
            std::cout &lt;&lt; &#34;I didn&#39;t understand what you said.  Try again: &#34;;
            ignoreLine(); // ignore any extraneous input
            continue;
        }

        if (input == &#39;q&#39;)
            return Potion::max_potions;

        // Convert the char to a number and see if it&#39;s a valid potion selection
        int val { charNumToInt(input) };
        if (val &gt;= 0 &amp;&amp; val &lt; Potion::max_potions)
            return static_cast&lt;Potion::Type&gt;(val);

        // It wasn&#39;t a valid potion selection
        std::cout &lt;&lt; &#34;I didn&#39;t understand what you said.  Try again: &#34;;
        ignoreLine();
    }
}

void shop(Player &amp;player)
{
    while (true)
    {
        std::cout &lt;&lt; &#34;Here is our selection for today:\n&#34;;

        for (auto p: Potion::types)
            std::cout &lt;&lt; p &lt;&lt; &#34;) &#34; &lt;&lt; Potion::name[p] &lt;&lt; &#34; costs &#34; &lt;&lt; Potion::cost[p] &lt;&lt; &#39;\n&#39;;
        
        Potion::Type which { whichPotion() };
        if (which == Potion::max_potions)
            return;

        bool success { player.buy(which) };
        if (!success)
            std::cout &lt;&lt; &#34;You can not afford that.\n\n&#34;;
        else
            std::cout &lt;&lt; &#34;You purchased a potion of &#34; &lt;&lt; Potion::name[which] &lt;&lt; &#34;.  You have &#34; &lt;&lt; player.gold() &lt;&lt; &#34; gold left.\n\n&#34;;
    }
}

void printInventory(Player&amp; player)
{
    std::cout &lt;&lt; &#34;Your inventory contains: \n&#34;;
    
    for (auto p: Potion::types)
    {
        if (player.inventory(p) &gt; 0)
            std::cout &lt;&lt; player.inventory(p) &lt;&lt; &#34;x potion of &#34; &lt;&lt; Potion::name[p] &lt;&lt; &#39;\n&#39;;
    }

    std::cout &lt;&lt; &#34;You escaped with &#34; &lt;&lt; player.gold() &lt;&lt; &#34; gold remaining.\n&#34;;
}

int main()
{
    std::cout &lt;&lt; &#34;Welcome to Roscoe&#39;s potion emporium!\n&#34;;
    std::cout &lt;&lt; &#34;Enter your name: &#34;;

    std::string name{};
    std::cin &gt;&gt; name;

    Player player { name };

    std::cout &lt;&lt; &#34;Hello, &#34; &lt;&lt; name &lt;&lt; &#34;, you have &#34; &lt;&lt; player.gold() &lt;&lt; &#34; gold.\n\n&#34;;

    shop(player);

    std::cout &lt;&lt; &#39;\n&#39;;

    printInventory(player);

    std::cout &lt;&lt; &#34;\nThanks for shopping at Roscoe&#39;s potion emporium!\n&#34;;

    return 0;
}</code></pre></div><p class="cpp-quiz-question cpp-topline" style=clear:both>Pytanie nr 3<p>Załóżmy, że chcemy napisać grę karcianą wykorzystującą standardową talię kart. Aby to zrobić, będziemy potrzebować sposobu na przedstawienie tych kart i talii kart. Zbudujmy tę funkcjonalność.<p>Wykorzystamy go w następnym pytaniu quizu, aby faktycznie zaimplementować grę.<p class="cpp-quiz-question cpp-topline" style=clear:both>&gt; Krok #1<p>Talia kart składa się z 52 unikalnych kart (13 szeregów kart po 4 kolory). Twórz wyliczenia dla rang kart (as, 2, 3, 4, 5, 6, 7, 8, 9, 10, walet, dama, król) i kolorów (trefl, karo, kier, pik).<p><a class=solution_link_show href=javascript:void(0) onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_6'),this,'Show Solution','Hide Solution')">Pokaż rozwiązanie</a><div class=wpsolution id=cpp_solution_id_6 style=display:none><pre class="language-cpp line-numbers"><code class="language-cpp match-braces">// Because identifiers can&#39;t start with a number, we&#39;ll use a &#34;rank_&#34; prefix for these
enum Rank
{
    rank_ace,
    rank_2,
    rank_3,
    rank_4,
    rank_5,
    rank_6,
    rank_7,
    rank_8,
    rank_9,
    rank_10,
    rank_jack,
    rank_queen,
    rank_king,

    max_ranks
};

// We&#39;ll also prefix these for consistency
enum Suit
{
    suit_club,
    suit_diamond,
    suit_heart,
    suit_spade,

    max_suits
};</code></pre></div><p class="cpp-quiz-question cpp-topline" style=clear:both>&gt; Krok #2<p>Każda karta będzie reprezentowana przez strukturę o nazwie <code>Card</code> który zawiera rangę i członka koloru. Utwórz strukturę i przenieś do niej wyliczenia.<p><a class=solution_link_show href=javascript:void(0) onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_7'),this,'Show Solution','Hide Solution')">Pokaż rozwiązanie</a><div class=wpsolution id=cpp_solution_id_7 style=display:none><pre class="language-cpp line-numbers"><code class="language-cpp match-braces">struct Card
{
    enum Rank
    {
        rank_ace,
        rank_2,
        rank_3,
        rank_4,
        rank_5,
        rank_6,
        rank_7,
        rank_8,
        rank_9,
        rank_10,
        rank_jack,
        rank_queen,
        rank_king,

        max_ranks
    };

    enum Suit
    {
        suit_club,
        suit_diamond,
        suit_heart,
        suit_spade,

        max_suits
    };

    Rank rank{};
    Suit suit{};
};</code></pre></div><p class="cpp-quiz-question cpp-topline" style=clear:both>&gt; Krok #3<p>Następnie dodajmy kilka przydatnych funkcji do naszej struktury Card. Po pierwsze, przeciążenie <code>operator&lt;&lt;</code> aby wydrukować rangę i kolor karty w postaci dwuliterowego kodu (np. walet pik zostanie wydrukowany jako JS). Można to zrobić wypełniając następującą funkcję:<pre class="language-cpp line-numbers"><code class="language-cpp match-braces">struct Card
{
    // Your other stuff here

    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Card &amp;card)
    {
        out &lt;&lt; // print your card rank and suit here
        return out;
    }
};</code></pre><p>Po drugie dodaj funkcję zwracającą wartość karty. Traktuj asa jako wartość 11. Na koniec dodaj a <code>std::array</code> rangi i koloru (o nazwie <code>allRanks</code> i <code>allSuits</code> odpowiednio), aby można było je iterować. Ponieważ są one częścią struktury (nie przestrzeni nazw), uczyń je statycznymi, aby były tworzone tylko raz (nie z każdym obiektem).<p>Poniższe powinno się skompilować:<pre class="language-cpp line-numbers"><code class="language-cpp match-braces">int main()
{
    // Print one card
    Card card { Card::rank_5, Card::suit_heart };
    std::cout &lt;&lt; card &lt;&lt; &#39;\n&#39;;

    // Print all cards
    for (auto suit : Card::allSuits)
        for (auto rank : Card::allRanks)
            std::cout &lt;&lt; Card { rank, suit } &lt;&lt; &#39; &#39;;
    std::cout &lt;&lt; &#39;\n&#39;;

    return 0;
}</code></pre><p>i wygenerowany zostanie następujący wynik:<pre>5H
AC 2C 3C 4C 5C 6C 7C 8C 9C TC JC QC KC AD 2D 3D 4D 5D 6D 7D 8D 9D TD JD QD KD AH 2H 3H 4H 5H 6H 7H 8H 9H TH JH QH KH AS 2S 3S 4S 5S 6S 7S 8S 9S TS JS QS KS 
</pre><p><a class=solution_link_show href=javascript:void(0) onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_8'),this,'Show Solution','Hide Solution')">Pokaż rozwiązanie</a><div class=wpsolution id=cpp_solution_id_8 style=display:none><pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;array&gt;
#include &lt;iostream&gt;

struct Card
{
    enum Rank
    {
        rank_ace,
        rank_2,
        rank_3,
        rank_4,
        rank_5,
        rank_6,
        rank_7,
        rank_8,
        rank_9,
        rank_10,
        rank_jack,
        rank_queen,
        rank_king,

        max_ranks
    };

    enum Suit
    {
        suit_club,
        suit_diamond,
        suit_heart,
        suit_spade,

        max_suits
    };

    // These need to be static so they are only created once per program, not once per Card
    static constexpr std::array allRanks { rank_ace, rank_2, rank_3, rank_4, rank_5, rank_6, rank_7, rank_8, rank_9, rank_10, rank_jack, rank_queen, rank_king };
    static constexpr std::array allSuits { suit_club, suit_diamond, suit_heart, suit_spade };

    Rank rank{};
    Suit suit{};

    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Card &amp;card)
    {
        static constexpr std::array ranks { &#39;A&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;T&#39;, &#39;J&#39;, &#39;Q&#39;, &#39;K&#39; };
        static constexpr std::array suits { &#39;C&#39;, &#39;D&#39;, &#39;H&#39;, &#39;S&#39; };

        out &lt;&lt; ranks[card.rank] &lt;&lt; suits[card.suit];
        return out;
    }

    int value() const
    {
        static constexpr std::array rankValues { 11, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10 };
        return rankValues[rank];
    }
};

int main()
{
    // Print one card
    Card card { Card::rank_5, Card::suit_heart };
    std::cout &lt;&lt; card &lt;&lt; &#39;\n&#39;;

    // Print all cards
    for (auto suit : Card::allSuits)
        for (auto rank : Card::allRanks)
            std::cout &lt;&lt; Card { rank, suit } &lt;&lt; &#39; &#39;;
    std::cout &lt;&lt; &#39;\n&#39;;

    return 0;
}</code></pre></div><p class="cpp-quiz-question cpp-topline" style=clear:both>&gt; Krok 4<p>Następnie stwórzmy naszą talię kart. Utwórz klasę o nazwie <code>Deck</code> zawierającą a <code>std::array</code> Kart. Możesz założyć, że talia składa się z 52 kart.<p>Talia powinna spełniać trzy funkcje:<p>Po pierwsze, konstruktor domyślny powinien zainicjować tablicę kart. Aby przeglądać wszystkie kolory i stopnie, możesz użyć pętli for ranged podobnej do tej w funkcji main() z poprzedniego przykładu.<p>Po drugie, dodaj a <code>dealCard()</code> funkcja, która zwraca następną kartę w talii według wartości. Od <code>std::array</code> jest tablicą o stałym rozmiarze, zastanów się, w jaki sposób będziesz śledzić, gdzie znajduje się następna karta. Ta funkcja powinna zostać potwierdzona, jeśli zostanie wywołana, gdy Deck przejdzie przez wszystkie karty.<p>Po trzecie napisz A <code>shuffle()</code> funkcja członkowska, która tasuje talię. Aby to ułatwić, skorzystamy z pomocy <code>std::shuffle</code>:<pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;algorithm&gt; // for std::shuffle
#include &#34;Random.h&#34;  // for Random::mt

    // Put this line in your shuffle function to shuffle m_cards using the Random::mt Mersenne Twister
    // This will rearrange all the Cards in the deck randomly
    std::shuffle(m_cards.begin(), m_cards.end(), Random::mt);</code></pre><p>Klasa <code>shuffle()</code> funkcja powinna również zostać zresetowana, jednakże śledzisz miejsce, w którym znajduje się następna karta na początek talii.<p>Powinien uruchomić się następujący program:<pre class="language-cpp line-numbers"><code class="language-cpp match-braces">int main()
{
    Deck deck{};
    std::cout &lt;&lt; deck.dealCard() &lt;&lt; &#39; &#39; &lt;&lt; deck.dealCard() &lt;&lt; &#39; &#39; &lt;&lt; deck.dealCard() &lt;&lt; &#39;\n&#39;;

    deck.shuffle();
    std::cout &lt;&lt; deck.dealCard() &lt;&lt; &#39; &#39; &lt;&lt; deck.dealCard() &lt;&lt; &#39; &#39; &lt;&lt; deck.dealCard() &lt;&lt; &#39;\n&#39;;

    return 0;
}</code></pre><p>i otrzymasz następujący wynik (ostatnie 3 karty powinny zostać losowane):<pre>AC 2C 3C
2H 7H 9C
</pre><p><a class=solution_link_show href=javascript:void(0) onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_9'),this,'Show Solution','Hide Solution')">Pokaż rozwiązanie</a><div class=wpsolution id=cpp_solution_id_9 style=display:none><pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;algorithm&gt; // for std::shuffle
#include &lt;array&gt;
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &#34;Random.h&#34;

struct Card
{
    enum Rank
    {
        rank_ace,
        rank_2,
        rank_3,
        rank_4,
        rank_5,
        rank_6,
        rank_7,
        rank_8,
        rank_9,
        rank_10,
        rank_jack,
        rank_queen,
        rank_king,

        max_ranks
    };

    enum Suit
    {
        suit_club,
        suit_diamond,
        suit_heart,
        suit_spade,

        max_suits
    };

    static constexpr std::array allRanks { rank_ace, rank_2, rank_3, rank_4, rank_5, rank_6, rank_7, rank_8, rank_9, rank_10, rank_jack, rank_queen, rank_king };
    static constexpr std::array allSuits { suit_club, suit_diamond, suit_heart, suit_spade };

    Rank rank{};
    Suit suit{};

    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Card &amp;card)
    {
        static constexpr std::array ranks { &#39;A&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;T&#39;, &#39;J&#39;, &#39;Q&#39;, &#39;K&#39; };
        static constexpr std::array suits { &#39;C&#39;, &#39;D&#39;, &#39;H&#39;, &#39;S&#39; };

        out &lt;&lt; ranks[card.rank] &lt;&lt; suits[card.suit];
        return out;
    }

    int value() const
    {
        static constexpr std::array rankValues { 11, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10 };
        return rankValues[rank];
    }
};

class Deck
{
private:
    std::array&lt;Card, 52&gt; m_cards {};
    std::size_t m_nextCardIndex { 0 };

public:
    Deck()
    {
        std::size_t count { 0 };
        for (auto suit: Card::allSuits)
            for (auto rank: Card::allRanks)
                m_cards[count++] = Card{rank, suit};
    }

    void shuffle()
    {
        std::shuffle(m_cards.begin(), m_cards.end(), Random::mt);
        m_nextCardIndex = 0;
    }

    Card dealCard()
    {
        assert(m_nextCardIndex != 52 &amp;&amp; &#34;Deck::dealCard ran out of cards&#34;);
        return m_cards[m_nextCardIndex++];
    }
};

int main()
{
    Deck deck{};
    std::cout &lt;&lt; deck.dealCard() &lt;&lt; &#39; &#39; &lt;&lt; deck.dealCard() &lt;&lt; &#39; &#39; &lt;&lt; deck.dealCard() &lt;&lt; &#39;\n&#39;;

    deck.shuffle();
    std::cout &lt;&lt; deck.dealCard() &lt;&lt; &#39; &#39; &lt;&lt; deck.dealCard() &lt;&lt; &#39; &#39; &lt;&lt; deck.dealCard() &lt;&lt; &#39;\n&#39;;

    return 0;
}</code></pre></div><p class="cpp-quiz-question cpp-topline" style=clear:both>Pytanie nr 4<p>W porządku, teraz użyjmy naszej karty i talii, aby wdrożyć uproszczoną wersję blackjacka! Jeśli nie znasz jeszcze Blackjacka, w Wikipedii znajdziesz artykuł na temat <a href=https://en.wikipedia.org/wiki/Blackjack>Blackjack</a> , który zawiera podsumowanie.<p>Oto zasady naszej wersji Blackjacka:<ul><li>Kurier otrzymuje na początek jedną kartę (w prawdziwym życiu krupier otrzymuje dwie, ale jedna jest zakryta, więc w tym momencie nie ma to znaczenia).<li>Gracz otrzymuje dwie karty do rozdania. start.<li>Gracz zaczyna.<li>Gracz może wielokrotnie „trafić” lub „wstać”.<li>Jeśli gracz „wstanie”, jego tura dobiega końca, a jego wynik jest obliczany na podstawie kart, które otrzymał.<li>Jeśli gracz „trafia”, otrzymuje kolejną kartę, a wartość tej karty jest dodawana do jego całkowitego wyniku.<li>Zwykle as liczy się jako 1 lub 11 (w zależności od tego, co jest lepsze dla całkowitego wyniku). Dla uproszczenia policzymy to tutaj jako 11.<li>Jeśli gracz przekroczy wynik 21, odpada i natychmiast przegrywa.<li>Gdy gracz skończy, nadchodzi kolej krupiera.<li>Krucznik wielokrotnie dobiera, aż osiągnie wynik 17 lub więcej, w którym to momencie musi przestać dobierać.<li>Jeśli krupier przekroczy wynik 17 21, odpada i gracz natychmiast wygrywa.<li>W przeciwnym razie, jeśli gracz ma wyższy wynik niż krupier, wygrywa. W przeciwnym razie gracz przegrywa (dla uproszczenia uznamy remis za wygraną krupiera).</ul><p>W naszej uproszczonej wersji Blackjacka nie będziemy śledzić, jakie konkretne karty otrzymali gracz i krupier. Będziemy śledzić jedynie sumę wartości kart, które otrzymali gracz i krupier. To upraszcza sprawę.<p>Zacznij od kodu, który napisałeś w poprzednim quizie (lub skorzystaj z naszego rozwiązania referencyjnego).<p class="cpp-quiz-question cpp-topline" style=clear:both>&gt; Krok #1<p>Utwórz strukturę o nazwie <code>Player</code> która będzie reprezentować uczestnika naszej gry (albo krupiera, albo gracza). Ponieważ w tej grze interesuje nas tylko wynik gracza, ta struktura potrzebuje tylko jednego członka.<p>Napisz funkcję, która (ostatecznie) rozegra rundę blackjacka. Na razie ta funkcja powinna losować jedną losową kartę dla krupiera i dwie losowe karty dla gracza. Powinien zwrócić wartość bool wskazującą, kto ma większy wynik.<p>Kod powinien wyprowadzić następującą treść:<pre>The dealer is showing: 10
You have score: 13
You win!
</pre><pre>The dealer is showing: 10
You have score: 8
You lose!
</pre><p><a class=solution_link_show href=javascript:void(0) onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_10'),this,'Show Solution','Hide Solution')">Pokaż rozwiązanie</a><div class=wpsolution id=cpp_solution_id_10 style=display:none><pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;algorithm&gt; // for std::shuffle
#include &lt;array&gt;
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &#34;Random.h&#34;

struct Card
{
    enum Rank
    {
        rank_ace,
        rank_2,
        rank_3,
        rank_4,
        rank_5,
        rank_6,
        rank_7,
        rank_8,
        rank_9,
        rank_10,
        rank_jack,
        rank_queen,
        rank_king,

        max_ranks
    };

    enum Suit
    {
        suit_club,
        suit_diamond,
        suit_heart,
        suit_spade,

        max_suits
    };

    static constexpr std::array allRanks { rank_ace, rank_2, rank_3, rank_4, rank_5, rank_6, rank_7, rank_8, rank_9, rank_10, rank_jack, rank_queen, rank_king };
    static constexpr std::array allSuits { suit_club, suit_diamond, suit_heart, suit_spade };

    Rank rank{};
    Suit suit{};

    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Card &amp;card)
    {
        static constexpr std::array ranks { &#39;A&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;T&#39;, &#39;J&#39;, &#39;Q&#39;, &#39;K&#39; };
        static constexpr std::array suits { &#39;C&#39;, &#39;D&#39;, &#39;H&#39;, &#39;S&#39; };

        out &lt;&lt; ranks[card.rank] &lt;&lt; suits[card.suit];
        return out;
    }

    int value() const
    {
        static constexpr std::array rankValues { 11, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10 };
        return rankValues[rank];
    }
};

class Deck
{
private:
    std::array&lt;Card, 52&gt; m_cards {};
    std::size_t m_nextCardIndex { 0 };

public:
    Deck()
    {
        std::size_t count { 0 };
        for (auto suit: Card::allSuits)
            for (auto rank: Card::allRanks)
                m_cards[count++] = Card{rank, suit};
    }

    void shuffle()
    {
        std::shuffle(m_cards.begin(), m_cards.end(), Random::mt);
        m_nextCardIndex = 0;
    }

    Card dealCard()
    {
        assert(m_nextCardIndex != 52 &amp;&amp; &#34;Deck::dealCard ran out of cards&#34;);
        return m_cards[m_nextCardIndex++];
    }
};

struct Player
{
    int score{};
};

bool playBlackjack()
{
    Deck deck{};
    deck.shuffle();

    Player dealer{ deck.dealCard().value() };

    std::cout &lt;&lt; &#34;The dealer is showing: &#34; &lt;&lt; dealer.score &lt;&lt; &#39;\n&#39;;

    Player player { deck.dealCard().value() + deck.dealCard().value() };

    std::cout &lt;&lt; &#34;You have score: &#34; &lt;&lt; player.score &lt;&lt; &#39;\n&#39;;

    return (player.score &gt; dealer.score);
}

int main()
{
    if (playBlackjack())
    {
        std::cout &lt;&lt; &#34;You win!\n&#34;;
    }
    else
    {
        std::cout &lt;&lt; &#34;You lose!\n&#34;;
    }

    return 0;
}</code></pre></div><p class="cpp-quiz-question cpp-topline" style=clear:both>&gt; Krok #2<p>Dodaj <code>Settings</code> przestrzeń nazw zawierającą dwie stałe: wartość, powyżej której gracz odpada, oraz wartość, przy której krupier musi przestać dobierać karty.<p>Dodaj logikę obsługującą turę krupiera. Krupier będzie dobierać karty, dopóki nie osiągnie 17, po czym musi się zatrzymać. Jeśli odpadną, gracz wygrywa.<p>Oto przykładowe wyniki:<pre>The dealer is showing: 8
You have score: 9
The dealer flips a 4D.  They now have: 12
The dealer flips a JS.  They now have: 22
The dealer went bust!
You win!
</pre><pre>The dealer is showing: 6
You have score: 13
The dealer flips a 3D.  They now have: 9
The dealer flips a 3H.  They now have: 12
The dealer flips a 9S.  They now have: 21
You lose!
</pre><pre>The dealer is showing: 7
You have score: 21
The dealer flips a JC.  They now have: 17
You win!
</pre><p><a class=solution_link_show href=javascript:void(0) onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_11'),this,'Show Solution','Hide Solution')">Pokaż rozwiązanie</a><div class=wpsolution id=cpp_solution_id_11 style=display:none><pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;algorithm&gt; // for std::shuffle
#include &lt;array&gt;
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &#34;Random.h&#34;

struct Card
{
    enum Rank
    {
        rank_ace,
        rank_2,
        rank_3,
        rank_4,
        rank_5,
        rank_6,
        rank_7,
        rank_8,
        rank_9,
        rank_10,
        rank_jack,
        rank_queen,
        rank_king,

        max_ranks
    };

    enum Suit
    {
        suit_club,
        suit_diamond,
        suit_heart,
        suit_spade,

        max_suits
    };

    static constexpr std::array allRanks { rank_ace, rank_2, rank_3, rank_4, rank_5, rank_6, rank_7, rank_8, rank_9, rank_10, rank_jack, rank_queen, rank_king };
    static constexpr std::array allSuits { suit_club, suit_diamond, suit_heart, suit_spade };

    Rank rank{};
    Suit suit{};

    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Card &amp;card)
    {
        static constexpr std::array ranks { &#39;A&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;T&#39;, &#39;J&#39;, &#39;Q&#39;, &#39;K&#39; };
        static constexpr std::array suits { &#39;C&#39;, &#39;D&#39;, &#39;H&#39;, &#39;S&#39; };

        out &lt;&lt; ranks[card.rank] &lt;&lt; suits[card.suit];
        return out;
    }

    int value() const
    {
        static constexpr std::array rankValues { 11, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10 };
        return rankValues[rank];
    }
};

class Deck
{
private:
    std::array&lt;Card, 52&gt; m_cards {};
    std::size_t m_nextCardIndex { 0 };

public:
    Deck()
    {
        std::size_t count { 0 };
        for (auto suit: Card::allSuits)
            for (auto rank: Card::allRanks)
                m_cards[count++] = Card{rank, suit};
    }

    void shuffle()
    {
        std::shuffle(m_cards.begin(), m_cards.end(), Random::mt);
        m_nextCardIndex = 0;
    }

    Card dealCard()
    {
        assert(m_nextCardIndex != 52 &amp;&amp; &#34;Deck::dealCard ran out of cards&#34;);
        return m_cards[m_nextCardIndex++];
    }

};

struct Player
{
    int score{};
};

namespace Settings
{
    // Maximum score before losing.
    constexpr int bust{ 21 };

    // Minium score that the dealer has to have.
    constexpr int dealerStopsAt{ 17 };
}

// Returns true if the dealer went bust. False otherwise.
bool dealerTurn(Deck&amp; deck, Player&amp; dealer)
{
    while (dealer.score &lt; Settings::dealerStopsAt)
    {
        Card card { deck.dealCard() };
        dealer.score += card.value();
        std::cout &lt;&lt; &#34;The dealer flips a &#34; &lt;&lt; card &lt;&lt; &#34;.  They now have: &#34; &lt;&lt; dealer.score &lt;&lt; &#39;\n&#39;;
    }

    if (dealer.score &gt; Settings::bust)
    {
        std::cout &lt;&lt; &#34;The dealer went bust!\n&#34;;
        return true;
    }
    
    return false;
}

bool playBlackjack()
{
    Deck deck{};
    deck.shuffle();

    Player dealer{ deck.dealCard().value() };

    std::cout &lt;&lt; &#34;The dealer is showing: &#34; &lt;&lt; dealer.score &lt;&lt; &#39;\n&#39;;

    Player player { deck.dealCard().value() + deck.dealCard().value() };

    std::cout &lt;&lt; &#34;You have score: &#34; &lt;&lt; player.score &lt;&lt; &#39;\n&#39;;

    if (dealerTurn(deck, dealer))
        return true;

    return (player.score &gt; dealer.score);
}

int main()
{
    if (playBlackjack())
    {
        std::cout &lt;&lt; &#34;You win!\n&#34;;
    }
    else
    {
        std::cout &lt;&lt; &#34;You lose!\n&#34;;
    }

    return 0;
}</code></pre></div><p class="cpp-quiz-question cpp-topline" style=clear:both>&gt; Krok #3<p>Na koniec dodaj logikę dla tury gracza. To zakończy grę.<p>Oto przykładowe wyniki:<pre>The dealer is showing: 2
You have score: 14
(h) to hit, or (s) to stand: h
You were dealt KH.  You now have: 24
You went bust!
You lose!
</pre><pre>The dealer is showing: 10
You have score: 9
(h) to hit, or (s) to stand: h
You were dealt TH.  You now have: 19
(h) to hit, or (s) to stand: s
The dealer flips a 3D.  They now have: 13
The dealer flips a 7H.  They now have: 20
You lose!
</pre><pre>The dealer is showing: 7
You have score: 12
(h) to hit, or (s) to stand: h
You were dealt 7S.  You now have: 19
(h) to hit, or (s) to stand: h
You were dealt 2D.  You now have: 21
(h) to hit, or (s) to stand: s
The dealer flips a 6H.  They now have: 13
The dealer flips a QC.  They now have: 23
The dealer went bust!
You win!
</pre><p><a class=solution_link_show href=javascript:void(0) onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_12'),this,'Show Solution','Hide Solution')">Pokaż rozwiązanie</a><div class=wpsolution id=cpp_solution_id_12 style=display:none><pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;algorithm&gt; // for std::shuffle
#include &lt;array&gt;
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &#34;Random.h&#34;

struct Card
{
    enum Rank
    {
        rank_ace,
        rank_2,
        rank_3,
        rank_4,
        rank_5,
        rank_6,
        rank_7,
        rank_8,
        rank_9,
        rank_10,
        rank_jack,
        rank_queen,
        rank_king,

        max_ranks
    };

    enum Suit
    {
        suit_club,
        suit_diamond,
        suit_heart,
        suit_spade,

        max_suits
    };

    static constexpr std::array allRanks { rank_ace, rank_2, rank_3, rank_4, rank_5, rank_6, rank_7, rank_8, rank_9, rank_10, rank_jack, rank_queen, rank_king };
    static constexpr std::array allSuits { suit_club, suit_diamond, suit_heart, suit_spade };

    Rank rank{};
    Suit suit{};

    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Card &amp;card)
    {
        static constexpr std::array ranks { &#39;A&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;T&#39;, &#39;J&#39;, &#39;Q&#39;, &#39;K&#39; };
        static constexpr std::array suits { &#39;C&#39;, &#39;D&#39;, &#39;H&#39;, &#39;S&#39; };

        out &lt;&lt; ranks[card.rank] &lt;&lt; suits[card.suit];
        return out;
    }

    int value() const
    {
        static constexpr std::array rankValues { 11, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10 };
        return rankValues[rank];
    }
};

class Deck
{
private:
    std::array&lt;Card, 52&gt; m_cards {};
    std::size_t m_nextCardIndex { 0 };

public:
    Deck()
    {
        std::size_t count { 0 };
        for (auto suit: Card::allSuits)
            for (auto rank: Card::allRanks)
                m_cards[count++] = Card{rank, suit};
    }

    void shuffle()
    {
        std::shuffle(m_cards.begin(), m_cards.end(), Random::mt);
        m_nextCardIndex = 0;
    }

    Card dealCard()
    {
        assert(m_nextCardIndex != 52 &amp;&amp; &#34;Deck::dealCard ran out of cards&#34;);
        return m_cards[m_nextCardIndex++];
    }

};

struct Player
{
    int score{};
};

namespace Settings
{
    // Maximum score before losing.
    constexpr int bust{ 21 };

    // Minium score that the dealer has to have.
    constexpr int dealerStopsAt{ 17 };
}

bool playerWantsHit()
{
    while (true)
    {
        std::cout &lt;&lt; &#34;(h) to hit, or (s) to stand: &#34;;

        char ch{};
        std::cin &gt;&gt; ch;

        switch (ch)
        {
            case &#39;h&#39;:
                return true;
            case &#39;s&#39;:
                return false;
        }
    }
}

// Returns true if the player went bust. False otherwise.
bool playerTurn(Deck&amp; deck, Player&amp; player)
{
    while (player.score &lt; Settings::bust &amp;&amp; playerWantsHit())
    {
        Card card { deck.dealCard() };
        player.score += card.value();

        std::cout &lt;&lt; &#34;You were dealt &#34; &lt;&lt; card  &lt;&lt; &#34;. You now have: &#34; &lt;&lt; player.score &lt;&lt; &#39;\n&#39;;
    }

    if (player.score &gt; Settings::bust)
    {
        std::cout &lt;&lt; &#34;You went bust!\n&#34;;
        return true;
    }

    return false;
}

// Returns true if the dealer went bust. False otherwise.
bool dealerTurn(Deck&amp; deck, Player&amp; dealer)
{
    while (dealer.score &lt; Settings::dealerStopsAt)
    {
        Card card { deck.dealCard() };
        dealer.score += card.value();
        std::cout &lt;&lt; &#34;The dealer flips a &#34; &lt;&lt; card &lt;&lt; &#34;.  They now have: &#34; &lt;&lt; dealer.score &lt;&lt; &#39;\n&#39;;
    }

    if (dealer.score &gt; Settings::bust)
    {
        std::cout &lt;&lt; &#34;The dealer went bust!\n&#34;;
        return true;
    }

    return false;
}

bool playBlackjack()
{
    Deck deck{};
    deck.shuffle();

    Player dealer{ deck.dealCard().value() };

    std::cout &lt;&lt; &#34;The dealer is showing: &#34; &lt;&lt; dealer.score &lt;&lt; &#39;\n&#39;;

    Player player { deck.dealCard().value() + deck.dealCard().value() };

    std::cout &lt;&lt; &#34;You have score: &#34; &lt;&lt; player.score &lt;&lt; &#39;\n&#39;;

    if (playerTurn(deck, player))
        return false;

    if (dealerTurn(deck, dealer))
        return true;

    return (player.score &gt; dealer.score);
}

int main()
{
    if (playBlackjack())
    {
        std::cout &lt;&lt; &#34;You win!\n&#34;;
    }
    else
    {
        std::cout &lt;&lt; &#34;You lose!\n&#34;;
    }

    return 0;
}</code></pre></div><p class="cpp-quiz-question cpp-topline" style=clear:both>Pytanie #5<p>a) Opisz, w jaki sposób możesz zmodyfikować powyższy program, aby obsługiwał przypadek, w którym asy mogą być równe 1 lub 11.<p>Ważne jest, aby pamiętać, że śledzimy tylko sumę kart, a nie konkretne karty posiadane przez użytkownika.<p><a class=solution_link_show href=javascript:void(0) onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_13'),this,'Show Solution','Hide Solution')">Pokaż rozwiązanie</a><div class=wpsolution id=cpp_solution_id_13 style=display:none><p>Jednym ze sposobów byłoby śledzenie, ile asy, które gracz i krupier otrzymali (w strukturze <code>Player</code> , jako liczba całkowita). Jeśli gracz lub krupier przekroczy 21, a jego licznik asów będzie większy od zera, możesz zmniejszyć jego wynik o 10 (przeliczyć asa z 11 punktów na 1 punkt) i zmniejszyć licznik asów. Można to zrobić tyle razy, ile potrzeba, aż licznik asów osiągnie zero.</div><p>b) W prawdziwym blackjacku, jeśli gracz i krupier mają ten sam wynik (a gracz nie przegrał), wynikiem jest remis i żaden nie wygrywa. Opisz, jak zmodyfikowałbyś powyższy program, aby to uwzględnić.<p><a class=solution_link_show href=javascript:void(0) onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_14'),this,'Show Solution','Hide Solution')">Pokaż rozwiązanie</a><div class=wpsolution id=cpp_solution_id_14 style=display:none><p>Nasza wersja <code>playBlackjack()</code> obecnie zwraca wartość bool wskazującą, czy gracz wygrał, czy nie. Będziemy musieli zaktualizować tę funkcję, aby uzyskać trzy możliwości: wygrana krupiera, wygrana gracza, remis. Najlepszym sposobem na osiągnięcie tego byłoby zdefiniowanie wyliczenia dla tych trzech opcji i umożliwienie funkcji zwrócenia odpowiedniego modułu wyliczającego.</div><p>c) Dodatkowy kredyt: zaimplementuj powyższe dwa pomysły w swojej grze w blackjacka. Pamiętaj, że będziesz musiał pokazać początkową kartę krupiera i początkowe dwie karty gracza, aby wiedzieli, czy ma asa, czy nie.<p>Oto przykładowy wynik:<pre>The dealer is showing JH (10)
You are showing AH 7D (18)
(h) to hit, or (s) to stand: h
You were dealt JD.  You now have: 18
(h) to hit, or (s) to stand: s
The dealer flips a 6C.  They now have: 16
The dealer flips a AD.  They now have: 17
You win!
</pre><p><a class=solution_link_show href=javascript:void(0) onclick="cppSolutionToggle(document.getElementById('cpp_solution_id_15'),this,'Show Solution','Hide Solution')">Pokaż rozwiązanie</a><div class=wpsolution id=cpp_solution_id_15 style=display:none><pre class="language-cpp line-numbers"><code class="language-cpp match-braces">#include &lt;algorithm&gt; // for std::shuffle
#include &lt;array&gt;
#include &lt;cassert&gt;
#include &lt;iostream&gt;
#include &#34;Random.h&#34;

namespace Settings
{
    // Maximum score before losing.
    constexpr int bust{ 21 };

    // Minium score that the dealer has to have.
    constexpr int dealerStopsAt{ 17 };
}

struct Card
{
    enum Rank
    {
        rank_ace,
        rank_2,
        rank_3,
        rank_4,
        rank_5,
        rank_6,
        rank_7,
        rank_8,
        rank_9,
        rank_10,
        rank_jack,
        rank_queen,
        rank_king,

        max_ranks
    };

    enum Suit
    {
        suit_club,
        suit_diamond,
        suit_heart,
        suit_spade,

        max_suits
    };

    static constexpr std::array allRanks { rank_ace, rank_2, rank_3, rank_4, rank_5, rank_6, rank_7, rank_8, rank_9, rank_10, rank_jack, rank_queen, rank_king };
    static constexpr std::array allSuits { suit_club, suit_diamond, suit_heart, suit_spade };

    Rank rank{};
    Suit suit{};

    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const Card &amp;card)
    {
        static constexpr std::array ranks { &#39;A&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;, &#39;T&#39;, &#39;J&#39;, &#39;Q&#39;, &#39;K&#39; };
        static constexpr std::array suits { &#39;C&#39;, &#39;D&#39;, &#39;H&#39;, &#39;S&#39; };

        out &lt;&lt; ranks[card.rank] &lt;&lt; suits[card.suit];
        return out;
    }

    int value() const
    {
        static constexpr std::array rankValues { 11, 2, 3, 4, 5, 6, 7, 8, 9, 10, 10, 10, 10 };
        return rankValues[rank];
    }
};

class Deck
{
private:
    std::array&lt;Card, 52&gt; m_cards {};
    std::size_t m_nextCardIndex { 0 };

public:
    Deck()
    {
        std::size_t count { 0 };
        for (auto suit: Card::allSuits)
            for (auto rank: Card::allRanks)
                m_cards[count++] = Card{rank, suit};
    }

    void shuffle()
    {
        std::shuffle(m_cards.begin(), m_cards.end(), Random::mt);
        m_nextCardIndex = 0;
    }

    Card dealCard()
    {
        assert(m_nextCardIndex != 52 &amp;&amp; &#34;Deck::dealCard ran out of cards&#34;);
        return m_cards[m_nextCardIndex++];
    }

};

class Player
{
private:
    int m_score{ };
    int m_ace11Count { 0 }; // how many aces worth 11 points the player has

public:
    // We&#39;ll use a function to add the card to the player&#39;s score
    // Since we now need to count aces
    void addToScore(Card card)
    {
        m_score += card.value();
        if (card.rank == Card::rank_ace)
            ++m_ace11Count; // aces start at 11 points
        consumeAces();
    }

    // Decrease aceCount by 1 and 
    void consumeAces()
    {
        // If the player would bust, see if we can switch aces from 11 points to 1
        while (m_score &gt; Settings::bust &amp;&amp; m_ace11Count &gt; 0)
        {
            m_score -= 10;
            --m_ace11Count;
        }
    }

    int score() { return m_score; }
};

bool playerWantsHit()
{
    while (true)
    {
        std::cout &lt;&lt; &#34;(h) to hit, or (s) to stand: &#34;;

        char ch{};
        std::cin &gt;&gt; ch;

        switch (ch)
        {
            case &#39;h&#39;:
                return true;
            case &#39;s&#39;:
                return false;
        }
    }
}

// Returns true if the player went bust. False otherwise.
bool playerTurn(Deck&amp; deck, Player&amp; player)
{
    while (player.score() &lt; Settings::bust &amp;&amp; playerWantsHit())
    {
        Card card { deck.dealCard() };
        player.addToScore(card);

        std::cout &lt;&lt; &#34;You were dealt &#34; &lt;&lt; card  &lt;&lt; &#34;. You now have: &#34; &lt;&lt; player.score() &lt;&lt; &#39;\n&#39;;
    }

    if (player.score() &gt; Settings::bust)
    {
        std::cout &lt;&lt; &#34;You went bust!\n&#34;;
        return true;
    }

    return false;
}


// Returns true if the dealer went bust. False otherwise.
bool dealerTurn(Deck&amp; deck, Player&amp; dealer)
{
    while (dealer.score() &lt; Settings::dealerStopsAt)
    {
        Card card { deck.dealCard() };
        dealer.addToScore(card);

        std::cout &lt;&lt; &#34;The dealer flips a &#34; &lt;&lt; card &lt;&lt; &#34;.  They now have: &#34; &lt;&lt; dealer.score() &lt;&lt; &#39;\n&#39;;
    }

    if (dealer.score() &gt; Settings::bust)
    {
        std::cout &lt;&lt; &#34;The dealer went bust!\n&#34;;
        return true;
    }

    return false;
}

enum class GameResult
{
    playerWon,
    dealerWon,
    tie
};

GameResult playBlackjack()
{
    Deck deck{};
    deck.shuffle();

    Player dealer{};
    Card card1 { deck.dealCard() };
    dealer.addToScore(card1);
    std::cout &lt;&lt; &#34;The dealer is showing &#34; &lt;&lt; card1 &lt;&lt; &#34; (&#34; &lt;&lt; dealer.score() &lt;&lt; &#34;)\n&#34;;

    Player player{};
    Card card2 { deck.dealCard() };
    Card card3 { deck.dealCard() };
    player.addToScore(card2);
    player.addToScore(card3);
    std::cout &lt;&lt; &#34;You are showing &#34; &lt;&lt; card2 &lt;&lt; &#39; &#39; &lt;&lt; card3 &lt;&lt; &#34; (&#34; &lt;&lt; player.score() &lt;&lt; &#34;)\n&#34;;

    if (playerTurn(deck, player)) // if player busted
        return GameResult::dealerWon;

    if (dealerTurn(deck, dealer)) // if dealer busted
        return GameResult::playerWon;

    if (player.score() == dealer.score())
        return GameResult::tie;

    return (player.score() &gt; dealer.score() ? GameResult::playerWon : GameResult::dealerWon);
}

int main()
{
    switch (playBlackjack())
    {
    case GameResult::playerWon:
        std::cout &lt;&lt; &#34;You win!\n&#34;;
        return 0;
    case GameResult::dealerWon:
        std::cout &lt;&lt; &#34;You lose!\n&#34;;
        return 0;
    case GameResult::tie:
        std::cout &lt;&lt; &#34;It&#39;s a tie.\n&#34;;
        return 0;
    }

    return 0;
}</code></pre></div><div class=prevnext><div class=prevnext-inline><a class=nav-link href="../sorting-an-array-using-selection-sort/index.html"><div class="nav-button nav-button-next"><div class=nav-button-icon><i class="fa fa-chevron-circle-right" aria-hidden=true></i></div><div class=nav-button-text><div class=nav-button-title>Następna lekcja</div><div class=nav-button-lesson><span class=nav-button-lesson-number>18.1</span>Sortowanie tablicy za pomocą sortowania przez wybór</div></div></div></a><a class=nav-link href="/www.learncpp.com/"><div class="nav-button nav-button-index"><div class=nav-button-icon><i class="fa fa-home" aria-hidden=true></i></div><div class=nav-button-text><div class=nav-button-title>Powrót do spisu treści</div></div></div></a><a class=nav-link href="../multidimensional-stdarray/index.html"><div class="nav-button nav-button-prev"><div class=nav-button-icon><i class="fa fa-chevron-circle-left" aria-hidden=true></i></div><div class=nav-button-text><div class=nav-button-title>Poprzednia lekcja</div><div class=nav-button-lesson><span class=nav-button-lesson-number>17.13</span>Wielowymiarowy std::array</div></div></div></a></div></div><div class="code-block code-block-10" style="margin:8px 0;clear:both"><div class=cf_monitor><div id=ezoic-pub-ad-placeholder-106></div><ins class=adsbygoogle style=display:inline-block;width:336px;height:280px data-ad-client=ca-pub-0588844875925051 data-ad-slot=8689484849></ins></div></div></div><footer class="entry-meta entry-utility"></footer></div><span class=schema-publisher itemprop=publisher itemscope itemtype=https://schema.org/Organization><span itemprop=logo itemscope itemtype=https://schema.org/ImageObject><meta itemprop=url content="/www.learncpp.com/blog/wp-content/uploads/learncpp.png"></span><meta itemprop=name content="Learn C++"></span><link itemprop=mainEntityOfPage href=/www.learncpp.com/chapter-17-summary-and-quiz/></article><nav id=nav-below class=navigation role=navigation><div class=nav-previous><em>Poprzedni post</em><a href="../introduction-to-stdvector-and-list-constructors/index.html" rel=prev><span>16.2 — Wprowadzenie do std::vector i listy konstruktory</span></a></div><div class=nav-next><em>Następny post</em><a href="../stdvector-resizing-and-capacity/index.html" rel=next><span>16.10 — std::vector zmiana rozmiaru i pojemność</span></a></div></nav><div class=wpdiscuz_top_clearing></div><div id=comments class=comments-area><div id=respond style=width:0;height:0;clear:both;margin:0;padding:0></div><div id=wpdcom class="wpdiscuz_unauth wpd-default wpd-layout-2 wpd-comments-open"><div class=wc_social_plugin_wrapper></div><div class=wpd-form-wrap><div class=wpd-form-head><div class=wpd-auth><div class=wpd-login></div></div></div><div class="wpd-form wpd-form-wrapper wpd-main-form-wrapper" id=wpd-main-form-wrapper-0_0><form class="wpd_comm_form wpd_main_comm_form" method=post enctype=multipart/form-data data-uploading=false><div class=wpd-field-comment><div class="wpdiscuz-item wc-field-textarea"><div class="wpdiscuz-textarea-wrap wpd-txt"><div class=wpd-avatar><img alt=guest src="https://secure.gravatar.com/avatar/?s=56&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/?s=112&amp;d=mm&amp;r=g 2x" class="avatar avatar-56 photo avatar-default" height=56 width=56 loading=lazy></div><div class=wpd-textarea-wrap><div id=wpd-editor-char-counter-0_0 class=wpd-editor-char-counter></div><label style=display:none for=wc-textarea-0_0>Etykieta</label>
<textarea id=wc-textarea-0_0 placeholder="Zostaw komentarz..." aria-label="Zostaw komentarz..." required name=wc_comment class="wc_comment wpd-field"></textarea></div><div class=wpd-editor-buttons-right></div></div></div></div><div class=wpd-form-foot><div class=wpdiscuz-textarea-foot><div class=wpdiscuz-button-actions></div></div><div class=wpd-form-row><div class=wpd-form-col-left><div class="wpdiscuz-item wc_name-wrapper wpd-has-icon"><div class=wpd-field-icon><i class="fas fa-user"></i></div><input id=wc_name-0_0 required aria-required=true class="wc_name wpd-field" name=wc_name placeholder=Imię* maxlength=50 pattern=.{3,50}>
<label for=wc_name-0_0 class=wpdlb>Imię*</label></div><div class="wpdiscuz-item wc_email-wrapper wpd-has-icon"><div class=wpd-field-icon><i class="fas fa-at"></i></div><input id=wc_email-0_0 required aria-required=true class="wc_email wpd-field" type=email name=wc_email placeholder=E-mail*>
<label for=wc_email-0_0 class=wpdlb>E-mail*</label><div class=wpd-field-desc><i class="far fa-question-circle"></i><span>Twój adres e-mail nie zostanie wyświetlony</span></div></div><div class=cpp_correction_div style=padding-bottom:4px><div class=wpd-field-icon style=display:inline-block;width:20px><i style=opacity:.6 class="fas fa-regular fa-bug"></i></div>Znalazłeś błąd? Zostaw komentarz powyżej!<div class=wpd-field-desc><i class="far fa-question-circle"></i><span>Komentarze związane z poprawkami zostaną usunięte po przetworzeniu, aby pomóc zmniejszyć bałagan. Dziękujemy za pomoc w ulepszaniu witryny dla wszystkich!</span></div></div><div class=cpp_avatar_div style=padding-bottom:4px><div class=wpd-field-icon style=display:inline-block;width:20px><i style=opacity:.6 class="fas fa-user"></i></div>Awatary z <a target=_blank rel="noopener noreferrer" href=https://gravatar.com/>https://gravatar.com/</a> są połączone z podanym adresem e-mail.</div></div><div class=wpd-form-col-right><div class=wc-field-submit><span style=margin-top:6px>Powiadamiaj mnie o odpowiedziach:  </span>
<label class=wpd_label wpd-tooltip="Powiadamiaj mnie o nowych odpowiedziach na ten komentarz"><input id=wc_notification_new_comment-0_0 class="wc_notification_new_comment-0_0 wpd_label__checkbox" value=comment type=checkbox name=wpdiscuz_notification_type checked>
<span class=wpd_label__text><span class=wpd_label__check><i class="fas fa-bell wpdicon wpdicon-on"></i><i class="fas fa-bell-slash wpdicon wpdicon-off"></i></span></span></label><input id=wpd-field-submit-0_0 class="wc_comm_submit wpd_not_clicked wpd-prim-button" type=submit name=submit value="Dodaj komentarz"></div></div><div class=clearfix></div></div></div><input type=hidden class=wpdiscuz_unique_id value=0_0 name=wpdiscuz_unique_id></form></div><div id=wpdiscuz_hidden_secondary_form style=display:none><div class="wpd-form wpd-form-wrapper wpd-secondary-form-wrapper" id=wpd-secondary-form-wrapper-wpdiscuzuniqueid style=display:none><div class=wpd-secondary-forms-social-content></div><div class=clearfix></div><form class="wpd_comm_form wpd-secondary-form-wrapper" method=post enctype=multipart/form-data data-uploading=false><div class=wpd-field-comment><div class="wpdiscuz-item wc-field-textarea"><div class="wpdiscuz-textarea-wrap wpd-txt"><div class=wpd-avatar><img alt=guest src="https://secure.gravatar.com/avatar/?s=56&amp;d=mm&amp;r=g" srcset="https://secure.gravatar.com/avatar/?s=112&amp;d=mm&amp;r=g 2x" class="avatar avatar-56 photo avatar-default" height=56 width=56 loading=lazy></div><div class=wpd-textarea-wrap><div id=wpd-editor-char-counter-wpdiscuzuniqueid class=wpd-editor-char-counter></div><label style=display:none for=wc-textarea-wpdiscuzuniqueid>Etykieta</label>
<textarea id=wc-textarea-wpdiscuzuniqueid placeholder="Zostaw komentarz..." aria-label="Zostaw komentarz..." required name=wc_comment class="wc_comment wpd-field"></textarea></div><div class=wpd-editor-buttons-right></div></div></div></div><div class=wpd-form-foot><div class=wpdiscuz-textarea-foot><div class=wpdiscuz-button-actions></div></div><div class=wpd-form-row><div class=wpd-form-col-left><div class="wpdiscuz-item wc_name-wrapper wpd-has-icon"><div class=wpd-field-icon><i class="fas fa-user"></i></div><input id=wc_name-wpdiscuzuniqueid required aria-required=true class="wc_name wpd-field" name=wc_name placeholder=Imię* maxlength=50 pattern=.{3,50}>
<label for=wc_name-wpdiscuzuniqueid class=wpdlb>Imię*</label></div><div class="wpdiscuz-item wc_email-wrapper wpd-has-icon"><div class=wpd-field-icon><i class="fas fa-at"></i></div><input id=wc_email-wpdiscuzuniqueid required aria-required=true class="wc_email wpd-field" type=email name=wc_email placeholder=E-mail*>
<label for=wc_email-wpdiscuzuniqueid class=wpdlb>E-mail*</label><div class=wpd-field-desc><i class="far fa-question-circle"></i><span>Twój adres e-mail nie zostanie wyświetlony</span></div></div><div class=cpp_correction_div style=padding-bottom:4px><div class=wpd-field-icon style=display:inline-block;width:20px><i style=opacity:.6 class="fas fa-regular fa-bug"></i></div>Znalazłeś błąd? Zostaw komentarz powyżej!<div class=wpd-field-desc><i class="far fa-question-circle"></i><span>Komentarze związane z poprawkami zostaną usunięte po przetworzeniu, aby pomóc zmniejszyć bałagan. Dziękujemy za pomoc w ulepszaniu witryny dla wszystkich!</span></div></div><div class=cpp_avatar_div style=padding-bottom:4px><div class=wpd-field-icon style=display:inline-block;width:20px><i style=opacity:.6 class="fas fa-user"></i></div>Awatary z <a target=_blank rel="noopener noreferrer" href=https://gravatar.com/>https://gravatar.com/</a> są połączone z podanym adresem e-mail.</div></div><div class=wpd-form-col-right><div class=wc-field-submit><label class=wpd_label wpd-tooltip="Powiadamiaj mnie o nowych odpowiedziach na ten komentarz"><input id=wc_notification_new_comment-wpdiscuzuniqueid class="wc_notification_new_comment-wpdiscuzuniqueid wpd_label__checkbox" value=comment type=checkbox name=wpdiscuz_notification_type checked>
<span class=wpd_label__text><span class=wpd_label__check><i class="fas fa-bell wpdicon wpdicon-on"></i><i class="fas fa-bell-slash wpdicon wpdicon-off"></i></span></span></label><input id=wpd-field-submit-wpdiscuzuniqueid class="wc_comm_submit wpd_not_clicked wpd-prim-button" type=submit name=submit value="Dodaj komentarz"></div></div><div class=clearfix></div></div></div><input type=hidden class=wpdiscuz_unique_id value=wpdiscuzuniqueid name=wpdiscuz_unique_id></form></div></div></div><div id=wpd-threads class=wpd-thread-wrapper><div class=wpd-thread-head><div class=wpd-thread-info data-comments-count=1581><span class=wpdtc title=1581>1.6K</span> Komentarze</div><div class=wpd-space></div><div class=wpd-thread-filter><div class="wpd-filter wpdf-sorting"><span class="wpdiscuz-sort-button wpdiscuz-date-sort-desc wpdiscuz-sort-button-active" data-sorting=newest>Najnowsze</span>
<i class="fas fa-sort-down"></i><div class=wpdiscuz-sort-buttons><span class="wpdiscuz-sort-button wpdiscuz-date-sort-asc" data-sorting=oldest>Najstarsze</span>
<span class="wpdiscuz-sort-button wpdiscuz-vote-sort-up" data-sorting=by_vote>Najczęściej głosowane</span></div></div></div></div><div class=wpd-comment-info-bar><div class=wpd-current-view><i class="fas fa-quote-left"></i>Wbudowane opinie</div><div class=wpd-filter-view-all>Wyświetl wszystkie komentarze</div></div><div class=wpd-thread-list><div class=wpdiscuz-comment-pagination style=display:none><div class=wpd-load-more-submit-wrap><button name=submit data-lastparentid=0 class="wpd-load-more-submit wpd-loaded wpd-prim-button">
Wczytaj więcej komentarzy</button></div><input id=wpdiscuzHasMoreComments type=hidden value=0></div></div></div></div></div><div id=wpdiscuz-loading-bar class=wpdiscuz-loading-bar-unauth></div><div id=wpdiscuz-comment-message class=wpdiscuz-comment-message-unauth></div></main><aside id=primary class="widget-area sidey" role=complementary itemscope itemtype=http://schema.org/WPSideBar><section id=custom_html-2 class="widget_text widget-container widget_custom_html"><div class="textwidget custom-html-widget"><div class=cf_monitor style=float:right><div id=ezoic-pub-ad-placeholder-103></div><ins class=adsbygoogle style=display:inline-block;width:160px;height:600px data-ad-client=ca-pub-0588844875925051 data-ad-slot=6408671241></ins></div></div></section></aside><aside id=secondary class="widget-area sidey" role=complementary itemscope itemtype=http://schema.org/WPSideBar><section id=custom_html-3 class="widget_text widget-container widget_custom_html"><div class="textwidget custom-html-widget"><div class=cf_monitor style=float:left><div id=ezoic-pub-ad-placeholder-102></div><ins class=adsbygoogle style=display:inline-block;width:160px;height:600px data-ad-client=ca-pub-0588844875925051 data-ad-slot=1425558446></ins></div></div></section></aside></div><aside id=colophon role=complementary itemscope itemtype=http://schema.org/WPSideBar><div id=colophon-inside class=footer-one><section id=text-10 class="widget-container widget_text"><div class=footer-widget-inside><div class=textwidget><p><em>©2024 Naucz się C++</em> <a href=https://g.ezoic.net/privacy/learncpp.com>Polityka prywatności</a></div></div></section></div></aside></div><footer id=footer class=cryout role=contentinfo itemscope itemtype=http://schema.org/WPFooter><div id=footer-inside></div></footer></div><a href=javascript:void(0); id=wpdUserContentInfoAnchor style=display:none rel=#wpdusercontentinfo data-wpd-lity>wpDiscuz</a><div id=wpdUserContentInfo style=overflow:auto;background:#fdfdf6;padding:20px;width:600px;max-width:100%;border-radius:6px class=lity-hide></div><div id=wpd-editor-source-code-wrapper-bg></div><div id=wpd-editor-source-code-wrapper><textarea id=wpd-editor-source-code></textarea><button id=wpd-insert-source-code>Wstaw</button><input type=hidden id=wpd-editor-uid></div><div class=wpdiscuz-fem-email style=display:none></div><div class=wpdiscuz-fem-email-form style=display:none><span class=wpdiscuz-fem-author>Zamierzasz wysłać e-mail na adres <em></em></span><i class="fas fa-times"></i><div class=wpdiscuz_clear></div><input placeholder="Temat e-maila" class=wpdiscuz-fem-subj><textarea class=wpdiscuz-fem-msg placeholder="Wpisz tutaj wiadomość"></textarea><br><div class=wpdiscuz-fem-button-align><button type=button class=wpdiscuz-fem-send>Wyślij</button></div><input type=hidden id=wpdiscuz_fem_email_comment_id></div><div class=wpdiscuz-fem-moving style=display:none></div><div class=wpdiscuz-fem-move-form style=display:none><span class=wpdiscuz-fem-author>Przenieś Komentarz<br><em></em></span><i class="fas fa-times"></i><div class=wpdiscuz_clear></div><div class=wpdiscuz-fem-posts-search><input class=wpdiscuz-fem-post placeholder="Wprowadź tytuł posta..."><div class=wpdiscuz-fem-posts></div></div><div class=wpdiscuz-fem-button-align><button type=button class=wpdiscuz-fem-move>Przenieś</button></div><input type=hidden id=wpdiscuz_fem_move_comment_id></div></body></html>